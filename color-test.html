<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Data Source Color Test - Lineage Graph</title>
    <link rel="stylesheet" href="./styles.css" />
    <link rel="stylesheet" href="./lineage-graph.css" />
    <!-- React Flow CSS -->
    <link rel="stylesheet" href="https://unpkg.com/reactflow@11.11.4/dist/style.css" />
    <style>
      /* CSS Custom Properties for theming */
      :root {
        --bg-page: #fbfbfb;
        --bg-header: #fff;
        --bg-control: #f8fafc;
        --bg-item: #FFF;
        --bg-dots: rgba(200, 205, 215, 1);
        --border-header: #e2e8f0;
        --border-control: #e2e8f0;
        --border-item: #D5DAE4;
        --border-item-hover: #9FABC1;
        --text-primary: #1e252f;
        --text-secondary: #5d6a85;
        --text-tertiary: #475569;
        --text-muted: #94a3b8;
        --text-item: #1E252F;
        --text-label: #64748b;
        --icon-filter: invert(43%) sepia(12%) saturate(749%) hue-rotate(186deg) brightness(93%) contrast(89%);
        --accent: #3b82f6;
        --accent-selected: #1A6CE7;
      }

      /* Dark mode */
      [data-theme="dark"] {
        --bg-page: #0F161E;
        --bg-header: #1a1f26;
        --bg-control: #242b33;
        --bg-item: #1a1f26;
        --bg-dots: rgba(45, 55, 72, 0.8);
        --border-header: #2d3640;
        --border-control: #3d4650;
        --border-item: #3d4650;
        --border-item-hover: #5d6a78;
        --text-primary: #f1f5f9;
        --text-secondary: #94a3b8;
        --text-tertiary: #a0aec0;
        --text-muted: #64748b;
        --text-item: #e2e8f0;
        --text-label: #94a3b8;
        --icon-filter: invert(70%) sepia(10%) saturate(300%) hue-rotate(186deg) brightness(95%) contrast(90%);
        --accent: #60a5fa;
        --accent-selected: #3b82f6;
      }

      /* Page-specific styles */
      body {
        margin: 0;
        padding: 0;
        font-family: "Inter", -apple-system, BlinkMacSystemFont, sans-serif;
        background: var(--bg-page);
        height: 100vh;
        overflow: hidden;
        transition: background-color 0.3s ease;
      }

      .page-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      .page-header {
        padding: 16px 24px;
        background: var(--bg-header);
        border-bottom: 1px solid var(--border-header);
        display: flex;
        align-items: center;
        gap: 16px;
        flex-shrink: 0;
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }

      .page-header h1 {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-primary);
        margin: 0;
        transition: color 0.3s ease;
      }

      .page-header .meta {
        font-size: 13px;
        color: var(--text-secondary);
        transition: color 0.3s ease;
      }

      .header-controls {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-left: auto;
      }

      .slider-control {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 8px 16px;
        background: var(--bg-control);
        border-radius: 8px;
        border: 1px solid var(--border-control);
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }

      .slider-control label {
        font-size: 13px;
        font-weight: 500;
        color: var(--text-tertiary);
        white-space: nowrap;
        transition: color 0.3s ease;
      }

      .slider-control input[type="range"] {
        width: 120px;
        height: 6px;
        -webkit-appearance: none;
        appearance: none;
        background: var(--border-control);
        border-radius: 3px;
        cursor: pointer;
      }

      .slider-control input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        background: var(--accent);
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      }

      .slider-control input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        background: var(--accent);
        border-radius: 50%;
        cursor: pointer;
        border: none;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      }

      #opacity-value {
        font-size: 13px;
        font-weight: 600;
        color: var(--text-primary);
        min-width: 36px;
        transition: color 0.3s ease;
      }

      /* Theme toggle button */
      .theme-toggle {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        background: var(--bg-control);
        border: 1px solid var(--border-control);
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }

      .theme-toggle:hover {
        background: var(--border-control);
      }

      .theme-toggle svg {
        width: 20px;
        height: 20px;
        color: var(--text-secondary);
        transition: color 0.3s ease;
      }

      .theme-toggle .sun-icon {
        display: none;
      }

      .theme-toggle .moon-icon {
        display: block;
      }

      [data-theme="dark"] .theme-toggle .sun-icon {
        display: block;
      }

      [data-theme="dark"] .theme-toggle .moon-icon {
        display: none;
      }

      .graph-container {
        flex: 1;
        position: relative;
        overflow: hidden;
      }

      #lineage-graph-container {
        width: 100%;
        height: 100%;
      }

      /* Placeholder icon for missing icons */
      .placeholder-icon {
        width: 16px;
        height: 16px;
        background: var(--border-control);
        border-radius: 4px;
        flex-shrink: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 8px;
        color: var(--text-muted);
        font-weight: 600;
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      /* Dynamic data source container backgrounds */
      .graph-datasource-container {
        border-radius: 8px;
        padding: 8px;
        min-width: 340px;
        z-index: 1;
      }

      .graph-datasource-header {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        margin-bottom: 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.15s;
      }

      .graph-datasource-header:hover {
        background-color: rgba(128, 128, 128, 0.1);
      }

      .graph-datasource-icon {
        width: 16px;
        height: 16px;
        flex-shrink: 0;
        object-fit: contain;
      }

      .graph-datasource-name {
        color: var(--text-label);
        font-family: Inter, sans-serif;
        font-size: 12px;
        font-style: normal;
        font-weight: 500;
        line-height: 20px;
        letter-spacing: 0;
        text-transform: uppercase;
        transition: color 0.3s ease;
      }

      .graph-datasource-items {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 24px;
      }

      .graph-datasource-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        background: var(--bg-item);
        border: 1px solid var(--border-item);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.15s;
        position: relative;
        width: 280px;
      }

      .graph-datasource-item:hover {
        border-color: var(--border-item-hover);
      }

      .graph-datasource-item.selected {
        border: 2.5px solid var(--accent-selected);
        background: var(--bg-item);
      }

      .graph-datasource-item-icon {
        width: 16px;
        height: 16px;
        flex-shrink: 0;
        object-fit: contain;
        filter: var(--icon-filter);
        transition: filter 0.3s ease;
      }

      /* Color info badge */
      .color-info {
        position: absolute;
        bottom: -20px;
        left: 8px;
        font-size: 10px;
        font-family: monospace;
        color: var(--text-muted);
        white-space: nowrap;
        transition: color 0.3s ease;
      }

      .graph-datasource-container:hover .color-info {
        color: var(--text-secondary);
      }

      /* Group label */
      .group-label {
        position: absolute;
        top: -20px;
        left: 8px;
        font-size: 11px;
        font-weight: 500;
        color: var(--text-label);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        transition: color 0.3s ease;
      }

      .graph-datasource-item-name {
        overflow: hidden;
        color: var(--text-item);
        text-overflow: ellipsis;
        font-family: Inter, sans-serif;
        font-size: 13px;
        font-weight: 600;
        line-height: 20px;
        letter-spacing: 0;
        text-transform: uppercase;
        flex: 1;
        transition: color 0.3s ease;
      }

      /* ReactFlow overrides for dark mode */
      [data-theme="dark"] .react-flow__background {
        background-color: var(--bg-page);
      }

      [data-theme="dark"] .react-flow__controls {
        background: var(--bg-header);
        border-color: var(--border-header);
      }

      [data-theme="dark"] .react-flow__controls-button {
        background: var(--bg-header);
        fill: var(--text-secondary);
        border-bottom-color: var(--border-header);
      }

      [data-theme="dark"] .react-flow__controls-button:hover {
        background: var(--bg-control);
      }

      /* Dark mode: brighten dark source icons */
      [data-theme="dark"] .graph-datasource-icon {
        filter: brightness(1.3) saturate(1.1);
      }

      /* Dark mode: invert item icons for visibility */
      [data-theme="dark"] .graph-datasource-item-icon {
        filter: invert(80%) sepia(10%) saturate(300%) hue-rotate(186deg) brightness(100%) contrast(90%);
      }

      /* Side Panel Styles */
      .side-panel {
        position: fixed;
        right: 0;
        top: 0;
        bottom: 0;
        width: 280px;
        background: var(--bg-header);
        border-left: 1px solid var(--border-header);
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 24px;
        z-index: 1000;
        overflow-y: auto;
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }

      .side-panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--border-control);
      }

      .side-panel-title {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary);
        margin: 0;
      }

      .side-panel-section {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .side-panel-section-title {
        font-size: 11px;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin: 0;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .control-label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 13px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .control-value {
        font-size: 12px;
        font-weight: 600;
        color: var(--text-primary);
        min-width: 45px;
        text-align: right;
      }

      .control-slider {
        width: 100%;
        height: 6px;
        -webkit-appearance: none;
        appearance: none;
        background: var(--border-control);
        border-radius: 3px;
        cursor: pointer;
      }

      .control-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 14px;
        height: 14px;
        background: var(--accent);
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      }

      .control-slider::-moz-range-thumb {
        width: 14px;
        height: 14px;
        background: var(--accent);
        border-radius: 50%;
        cursor: pointer;
        border: none;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      }

      /* Adjust graph container to account for side panel */
      .graph-container {
        margin-right: 280px;
      }

      /* Hide old header controls - now in side panel */
      .header-controls {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="page-container">
      <header class="page-header">
        <h1>Data Source Color Test</h1>
        <span class="meta">Testing color combinations for external data sources in lineage graph view</span>
        <div class="header-controls">
          <div class="slider-control">
            <label for="opacity-slider">Background Opacity:</label>
<input type="range" id="opacity-slider" min="0" max="100" value="4" />
          <span id="opacity-value">4%</span>
          </div>
          <button class="theme-toggle" id="theme-toggle" title="Toggle dark/light mode">
            <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
            </svg>
            <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
            </svg>
          </button>
        </div>
      </header>
      <div class="graph-container">
        <div id="lineage-graph-container"></div>
      </div>

      <!-- Side Panel Controls -->
      <aside class="side-panel">
        <div class="side-panel-header">
          <h2 class="side-panel-title">Color Controls</h2>
          <button class="theme-toggle" id="theme-toggle-panel" title="Toggle dark/light mode">
            <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
            </svg>
            <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
            </svg>
          </button>
        </div>

        <div class="side-panel-section">
          <h3 class="side-panel-section-title">Transparency</h3>
          
          <div class="control-group">
            <div class="control-label">
              <span>Background</span>
              <span class="control-value" id="bg-opacity-value">3%</span>
            </div>
            <input type="range" class="control-slider" id="bg-opacity-slider" min="0" max="100" value="3" />
          </div>

          <div class="control-group">
            <div class="control-label">
              <span>Border</span>
              <span class="control-value" id="border-opacity-value">12%</span>
            </div>
            <input type="range" class="control-slider" id="border-opacity-slider" min="0" max="100" value="12" />
          </div>
        </div>

        <div class="side-panel-section">
          <h3 class="side-panel-section-title">Color Adjustments</h3>
          
          <div class="control-group">
            <div class="control-label">
              <span>Saturation</span>
              <span class="control-value" id="saturation-value">+40%</span>
            </div>
            <input type="range" class="control-slider" id="saturation-slider" min="-50" max="100" value="40" />
          </div>

          <div class="control-group">
            <div class="control-label">
              <span>Lightness (L)</span>
              <span class="control-value" id="lightness-value">50</span>
            </div>
            <input type="range" class="control-slider" id="lightness-slider" min="20" max="80" value="50" />
          </div>
        </div>
      </aside>
    </div>

    <!-- React Flow Graph View - UMD builds -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/reactflow@11.11.4/dist/umd/index.js"></script>
    <script src="https://unpkg.com/elkjs@0.9.3/lib/elk.bundled.js"></script>

    <script>
      // Helper: Convert hex to RGB
      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (!result) return null;
        return {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        };
      }

      // Helper: Convert RGB to HSL
      function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
            case g: h = ((b - r) / d + 2) / 6; break;
            case b: h = ((r - g) / d + 4) / 6; break;
          }
        }
        return { h: h * 360, s: s * 100, l: l * 100 };
      }

      // Helper: Convert HSL to RGB
      function hslToRgb(h, s, l) {
        h /= 360; s /= 100; l /= 100;
        let r, g, b;

        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        return {
          r: Math.round(r * 255),
          g: Math.round(g * 255),
          b: Math.round(b * 255)
        };
      }

      // Background colors for contrast calculation
      const LIGHT_BG = '#fbfbfb';
      const DARK_BG = '#0F161E';

      // Helper: Linearize RGB channel for luminance calculation
      function linearize(channel) {
        const c = channel / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      }

      // Helper: Calculate relative luminance
      function getLuminance(r, g, b) {
        return 0.2126 * linearize(r) + 0.7152 * linearize(g) + 0.0722 * linearize(b);
      }

      // Helper: Calculate contrast ratio between two colors
      function getContrastRatio(rgb1, rgb2) {
        const l1 = getLuminance(rgb1.r, rgb1.g, rgb1.b);
        const l2 = getLuminance(rgb2.r, rgb2.g, rgb2.b);
        const lighter = Math.max(l1, l2);
        const darker = Math.min(l1, l2);
        return (lighter + 0.05) / (darker + 0.05);
      }

      // Helper: Adjust color to meet minimum contrast ratio
      // For light backgrounds: darken the color (decrease lightness)
      // For dark backgrounds: lighten the color (increase lightness)
      function adjustColorForContrast(hex, bgHex, minContrast = 3) {
        const rgb = hexToRgb(hex);
        const bgRgb = hexToRgb(bgHex);
        if (!rgb || !bgRgb) return hex;

        const currentContrast = getContrastRatio(rgb, bgRgb);
        if (currentContrast >= minContrast) {
          return hex; // Already meets contrast requirement
        }

        // Convert to HSL for adjustment
        const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
        const bgLuminance = getLuminance(bgRgb.r, bgRgb.g, bgRgb.b);
        
        // Determine if we need to lighten or darken
        const isLightBg = bgLuminance > 0.5;
        
        // Binary search to find the right lightness
        let minL = 0, maxL = 100;
        let bestL = hsl.l;
        let bestS = hsl.s;
        
        for (let i = 0; i < 20; i++) { // 20 iterations for precision
          const testL = isLightBg 
            ? (minL + bestL) / 2  // Darken for light bg
            : (bestL + maxL) / 2; // Lighten for dark bg
          
          // Also boost saturation slightly when adjusting
          const testS = Math.min(100, hsl.s * 1.1);
          
          const testRgb = hslToRgb(hsl.h, testS, testL);
          const testContrast = getContrastRatio(testRgb, bgRgb);
          
          if (testContrast >= minContrast) {
            bestL = testL;
            bestS = testS;
            if (isLightBg) {
              minL = testL; // Can be lighter, try to find less extreme
            } else {
              maxL = testL; // Can be darker, try to find less extreme
            }
          } else {
            if (isLightBg) {
              bestL = testL; // Need darker
            } else {
              bestL = testL; // Need lighter
            }
          }
        }
        
        // Final adjustment - ensure we meet contrast
        let finalL = bestL;
        let finalS = Math.min(100, hsl.s * 1.15); // Boost saturation
        let finalRgb = hslToRgb(hsl.h, finalS, finalL);
        let finalContrast = getContrastRatio(finalRgb, bgRgb);
        
        // If still not meeting contrast, be more aggressive
        while (finalContrast < minContrast && ((isLightBg && finalL > 5) || (!isLightBg && finalL < 95))) {
          finalL = isLightBg ? finalL - 5 : finalL + 5;
          finalRgb = hslToRgb(hsl.h, finalS, finalL);
          finalContrast = getContrastRatio(finalRgb, bgRgb);
        }
        
        // Convert back to hex
        const toHex = (n) => n.toString(16).padStart(2, '0');
        return `#${toHex(finalRgb.r)}${toHex(finalRgb.g)}${toHex(finalRgb.b)}`;
      }

      // Helper: Normalize lightness to a fixed value (default 50)
      function normalizeLightness(hex, targetL = 50) {
        const rgb = hexToRgb(hex);
        if (!rgb) return hex;
        const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
        const normalizedRgb = hslToRgb(hsl.h, hsl.s, targetL);
        const toHex = (n) => n.toString(16).padStart(2, '0');
        return `#${toHex(normalizedRgb.r)}${toHex(normalizedRgb.g)}${toHex(normalizedRgb.b)}`;
      }

      // Helper: Adjust saturation and brightness of a hex color
      function adjustSaturationBrightness(hex, satBoost, brightBoost) {
        const rgb = hexToRgb(hex);
        if (!rgb) return hex;
        const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
        const newSaturation = Math.min(100, Math.max(0, hsl.s + satBoost));
        const newLightness = Math.min(100, Math.max(0, hsl.l + brightBoost));
        const adjustedRgb = hslToRgb(hsl.h, newSaturation, newLightness);
        const toHex = (n) => n.toString(16).padStart(2, '0');
        return `#${toHex(adjustedRgb.r)}${toHex(adjustedRgb.g)}${toHex(adjustedRgb.b)}`;
      }

      // Pre-calculate contrast-adjusted colors for both themes
      function getAdjustedColors(colors, isDarkMode, saturationAdjust = 40, targetLightness = 50) {
        const bgHex = isDarkMode ? DARK_BG : LIGHT_BG;
        
        // Normalize lightness to the target value (controlled by brightness slider)
        let primary = normalizeLightness(colors.primary, targetLightness);
        let secondary = normalizeLightness(colors.secondary, targetLightness);
        
        // Apply user-controlled saturation adjustment
        if (!isDarkMode) {
          primary = adjustSaturationBrightness(primary, saturationAdjust, 0);
          secondary = adjustSaturationBrightness(secondary, saturationAdjust, 0);
        } else {
          // In dark mode, also apply adjustments but maybe differently
          primary = adjustSaturationBrightness(primary, saturationAdjust * 0.5, 0);
          secondary = adjustSaturationBrightness(secondary, saturationAdjust * 0.5, 0);
        }
        
        return {
          primary: adjustColorForContrast(primary, bgHex, 3),
          secondary: adjustColorForContrast(secondary, bgHex, 3)
        };
      }

      // Helper: Convert hex color to rgba with transparency
      // When alpha decreases, increase saturation to keep color visible
      function hexToRgba(hex, alpha = 0.65, isDarkMode = false, satAdjust = 40) {
        const rgb = hexToRgb(hex);
        if (!rgb) return hex;
        
        // Convert to HSL to adjust saturation
        const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
        
        // Calculate adjustment factor (more adjustment when alpha is lower)
        // At alpha=1, no adjustment. At alpha=0, maximum adjustment.
        const adjustmentFactor = 1 - alpha;
        
        // Use user-controlled saturation adjustment
        const baseSaturationBoost = isDarkMode ? satAdjust * 0.5 : satAdjust;
        
        // Additional saturation boost based on transparency (up to +40% when fully transparent)
        const saturationBoost = adjustmentFactor * 40 + baseSaturationBoost;
        const newSaturation = Math.min(100, Math.max(0, hsl.s + saturationBoost));
        
        // Adjust lightness based on theme for visibility at low alpha
        let newLightness;
        if (isDarkMode) {
          // In dark mode, increase lightness when more transparent
          const lightnessIncrease = adjustmentFactor * 25;
          newLightness = Math.min(95, Math.max(5, hsl.l + lightnessIncrease));
        } else {
          // In light mode, decrease lightness when more transparent
          const lightnessDecrease = adjustmentFactor * 20;
          newLightness = Math.min(95, Math.max(5, hsl.l - lightnessDecrease));
        }
        
        // Convert back to RGB
        const adjustedRgb = hslToRgb(hsl.h, newSaturation, newLightness);
        
        return `rgba(${adjustedRgb.r}, ${adjustedRgb.g}, ${adjustedRgb.b}, ${alpha})`;
      }

      // Data source color definitions
      const NODE_COLORS = {
        airflow: { primary: "#087B88", secondary: "#E6F4F5" },
        azure_sql_data_warehouse: { primary: "#2687CF", secondary: "#E8F4FC" },
        azure_sql_database: { primary: "#2687CF", secondary: "#E8F4FC" },
        bigquery: { primary: "#5086EC", secondary: "#F6F7FB" },
        braze: { primary: "#801ED7", secondary: "#F5EBFC" },
        cockroachdb: { primary: "#6431F9", secondary: "#F0EBFE" },
        cosmos: { primary: "#59B3D8", secondary: "#EBF7FC" },
        data_studio: { primary: "#1A73E8", secondary: "#EEF6FC" },
        databricks: { primary: "#475467", secondary: "#F2F5F9" },
        db2: { primary: "#009A2C", secondary: "#E6F7EB" },
        dbt: { primary: "#FB6514", secondary: "#FFF6ED" },
        documentdb: { primary: "#242527", secondary: "#F2F2F3" },
        dynamodb: { primary: "#242527", secondary: "#F2F2F3" },
        ehr: { primary: "#242527", secondary: "#F2F2F3" },
        fivetran: { primary: "#242527", secondary: "#F2F2F3" },
        glue: { primary: "#FB6514", secondary: "#FFF6ED" },
        google_sheets: { primary: "#0F9D58", secondary: "#E7F6EE" },
        hex: { primary: "#473982", secondary: "#F2F1F6" },
        hubspot: { primary: "#FF7A59", secondary: "#FFF2EE" },
        intercom: { primary: "#081D34", secondary: "#E7EAF0" },
        looker: { primary: "#33059F", secondary: "#F9F8FB" },
        mailchimp: { primary: "#006F7B", secondary: "#E6F3F4" },
        maria: { primary: "#32818E", secondary: "#EAF4F6" },
        marketo: { primary: "#473866", secondary: "#F2F0F5" },
        metabase: { primary: "#227DE1", secondary: "#EEF6FC" },
        mode: { primary: "#1D5243", secondary: "#EEF2E3" },
        mongo: { primary: "#26BC6A", secondary: "#E9F9F0" },
        mssql: { primary: "#EA1B22", secondary: "#FCE9EA" },
        mysql: { primary: "#00546B", secondary: "#E6EFF2" },
        omni: { primary: "#0176D3", secondary: "#E6F0FA" },
        oracle: { primary: "#EA1B22", secondary: "#FCE9EA" },
        periscope: { primary: "#F79009", secondary: "#FEF0C7" },
        postgres: { primary: "#336791", secondary: "#EFF2F3" },
        power_bi: { primary: "#F79009", secondary: "#FEF0C7" },
        quicksight: { primary: "#00B7F4", secondary: "#EEF6FC" },
        redshift: { primary: "#205B99", secondary: "#F6F7FB" },
        salesforce: { primary: "#00A1E0", secondary: "#E6F5FF" },
        salesforce_crma: { primary: "#0176D3", secondary: "#E6F0FA" },
        sap_hana_db: { primary: "#1161B7", secondary: "#E8F0F9" },
        sigma: { primary: "#101828", secondary: "#F1FFFD" },
        snowflake: { primary: "#29B5E8", secondary: "#E7F6FD" },
        splunk: { primary: "#242527", secondary: "#F2F2F3" },
        tableau: { primary: "#2A5875", secondary: "#F5F5F5" },
        thoughtspot: { primary: "#4E55FD", secondary: "#E8EFFD" },
        workday: { primary: "#1565C0", secondary: "#E9F1FA" },
        zendesk: { primary: "#17494D", secondary: "#E8F0F1" },
      };

      // Generate mock data for each data source
      function generateMockData() {
        const mockData = {};
        
        Object.keys(NODE_COLORS).forEach(source => {
          const sourceName = source.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          mockData[source] = {
            id: source,
            name: sourceName,
            colors: NODE_COLORS[source],
            items: generateMockItems(source, sourceName)
          };
        });
        
        return mockData;
      }

      // Simple hash function for deterministic pseudo-random
      function simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        return Math.abs(hash);
      }

      function generateMockItems(source, sourceName) {
        // Generate 2-4 mock items per data source (deterministic based on source name)
        const hash = simpleHash(source);
        const itemCount = (hash % 3) + 2; // 2-4 items
        const items = [];
        
        // Different item definitions with types
        const itemDefs = [
          { name: 'customers', type: 'table' },
          { name: 'orders', type: 'table' },
          { name: 'products', type: 'table' },
          { name: 'transactions', type: 'view' },
          { name: 'users', type: 'table' },
          { name: 'events', type: 'table' },
          { name: 'metrics_summary', type: 'view' },
          { name: 'analytics_dashboard', type: 'dashboard' },
          { name: 'revenue_report', type: 'dashboard' },
          { name: 'user_model', type: 'model' },
          { name: 'sales_dataset', type: 'dataset' },
          { name: 'inventory', type: 'table' }
        ];
        
        // Start at a deterministic index based on hash
        const startIndex = hash % itemDefs.length;
        
        for (let i = 0; i < itemCount; i++) {
          const itemDef = itemDefs[(startIndex + i) % itemDefs.length];
          
          items.push({
            id: `${source}_${itemDef.name}`,
            name: itemDef.name,
            type: itemDef.type,
            columns: generateMockColumns(source + itemDef.name)
          });
        }
        
        return items;
      }

      function generateMockColumns(seed) {
        const columnDefs = [
          { name: 'id', type: 'INTEGER', isPrimaryKey: true },
          { name: 'created_at', type: 'TIMESTAMP' },
          { name: 'updated_at', type: 'TIMESTAMP' },
          { name: 'name', type: 'VARCHAR' },
          { name: 'email', type: 'VARCHAR' },
          { name: 'status', type: 'VARCHAR' },
          { name: 'amount', type: 'DECIMAL' },
          { name: 'quantity', type: 'INTEGER' },
          { name: 'is_active', type: 'BOOLEAN' },
          { name: 'metadata', type: 'JSON' }
        ];
        
        // Return 3-6 columns (deterministic)
        const hash = simpleHash(seed);
        const count = (hash % 4) + 3;
        return columnDefs.slice(0, count);
      }

      // Wait for DOM and libraries to load
      document.addEventListener('DOMContentLoaded', function() {
        const { useState, useCallback, useEffect, useMemo, createElement } = React;
        const { createRoot } = ReactDOM;
        
        // Extract ReactFlow components
        const ReactFlowComponent = window.ReactFlow.ReactFlow;
        const Controls = window.ReactFlow.Controls;
        const Background = window.ReactFlow.Background;
        const useNodesState = window.ReactFlow.useNodesState;
        const useEdgesState = window.ReactFlow.useEdgesState;
        const Position = window.ReactFlow.Position;
        const Handle = window.ReactFlow.Handle;
        const ReactFlowProvider = window.ReactFlow.ReactFlowProvider;
        const useReactFlow = window.ReactFlow.useReactFlow;
        const BackgroundVariant = window.ReactFlow.BackgroundVariant;
        
        if (!ReactFlowComponent) {
          console.error('ReactFlow not loaded');
          return;
        }
        
        const ELK = window.ELK;

        // =============================================
        // Placeholder Icon Component
        // =============================================
        function PlaceholderIcon({ label }) {
          return createElement('div', { 
            className: 'placeholder-icon',
            title: label
          }, label ? label.slice(0, 2).toUpperCase() : '??');
        }

        // =============================================
        // Helper: Get column type icon image path
        // =============================================
        function getColumnTypeIcon(type) {
          const normalizedType = (type || '').toUpperCase();
          
          if (['VARCHAR', 'TEXT', 'STRING', 'CHAR'].some(t => normalizedType.includes(t))) {
            return 'img/text.svg';
          }
          if (['INTEGER', 'INT', 'BIGINT', 'NUMBER', 'SMALLINT', 'TINYINT'].some(t => normalizedType.includes(t))) {
            return 'img/number.svg';
          }
          if (['DECIMAL', 'FLOAT', 'DOUBLE', 'NUMERIC', 'REAL'].some(t => normalizedType.includes(t))) {
            return 'img/number.svg';
          }
          if (['BOOLEAN', 'BOOL'].some(t => normalizedType.includes(t))) {
            return 'img/boolean.svg';
          }
          if (normalizedType.includes('DATE') && !normalizedType.includes('TIME')) {
            return 'img/date.svg';
          }
          if (['TIMESTAMP', 'DATETIME', 'TIME'].some(t => normalizedType.includes(t))) {
            return 'img/timestamp.svg';
          }
          if (['JSON', 'VARIANT'].some(t => normalizedType.includes(t))) {
            return 'img/code.svg';
          }
          return 'img/column.svg';
        }

        // =============================================
        // Component: Column Type Icon
        // =============================================
        function ColumnTypeIcon({ type }) {
          const iconSrc = getColumnTypeIcon(type);
          return React.createElement('img', { 
            className: 'graph-child-type-icon',
            src: iconSrc,
            alt: type || 'column',
            title: type,
            width: 16,
            height: 16
          });
        }

        // =============================================
        // Custom Node: Data Source Group
        // =============================================
        function DataSourceNode({ data, id }) {
          const { source, items, colors, onItemClick, selectedItemId, bgOpacity = 0.04, borderOpacity = 0.20, saturationAdjust = 40, lightnessValue = 50, isDarkMode = false } = data;
          const sourceName = source.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

          // Get logo icon for data source (returns null if no logo available)
          const getDataSourceLogo = (sourceId) => {
            const logoMap = {
              'snowflake': 'img/logo-snowflake.svg',
              'databricks': 'img/databricks.svg',
              'bigquery': 'img/google-cloud.svg',
              'looker': 'img/looker.svg',
              'tableau': 'img/tableau.svg',
              'redshift': 'img/aws-redshift-sub.svg',
              'postgres': 'img/postgresql.svg',
              'mysql': 'img/mysql.svg',
              'google_sheets': 'img/google-cloud.svg',
              'data_studio': 'img/google-cloud.svg',
              'quicksight': 'img/aws-quicksight.svg',
              'athena': 'img/aws-athena-sub.svg',
              'sagemaker': 'img/aws-sagemaker-sub.svg',
              's3': 'img/aws-s3-copy-and-transform-sub.svg',
              'clickhouse': 'img/clickhouse-lightmode.svg',
              'dremio': 'img/dremio.svg',
              'duckdb': 'img/duckdb-lightmode.svg',
              'spark': 'img/spark.svg',
              'great_expectations': 'img/great-expectations.svg',
              'gcs': 'img/google-cloud-storage-sub.svg',
              'airflow': 'img/airflow-lightmode.svg',
              'glue': 'img/aws-glue-sub.svg',
              'azure_sql_data_warehouse': 'img/azure.svg',
              'azure_sql_database': 'img/azure.svg',
              'metabase': 'img/metabase.svg',
              'mssql': 'img/ms-sql-server.svg',
              'oracle': 'img/oracle.svg',
              'power_bi': 'img/powerbi.svg',
              'sigma': 'img/sigma-lightmode.svg',
              'trino': 'img/trino-lightmode.svg',
              'dbt': 'img/dbt.svg',
              'flink': 'img/apache-flink.svg',
              'apache_flink': 'img/apache-flink.svg',
            };
            return logoMap[sourceId] || null;
          };

          const dataSourceLogo = getDataSourceLogo(source);

          // Get icon for item type
          const getItemIcon = (itemType) => {
            const iconMap = {
              'table': 'img/table.svg',
              'view': 'img/view.svg',
              'dashboard': 'img/dashboard.svg',
              'dataset': 'img/dataset.svg',
              'model': 'img/model.svg',
              'schema': 'img/schema.svg',
              'database': 'img/database.svg',
              'column': 'img/column.svg',
              'function': 'img/function.svg',
              'api': 'img/api.svg'
            };
            return iconMap[itemType] || 'img/table.svg';
          };

          const renderItem = (item, index) => {
            const isSelected = selectedItemId === item.id;
            const iconSrc = getItemIcon(item.type);
            
            return createElement('div', {
              key: item.id,
              className: `graph-datasource-item ${isSelected ? 'selected' : ''}`,
              onClick: (e) => {
                e.stopPropagation();
                onItemClick?.(item, id);
              }
            },
              createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: 'auto', bottom: 'auto' }
              }),
              // Use actual SVG icon - 16x16
              createElement('img', { 
                className: 'graph-datasource-item-icon',
                src: iconSrc,
                alt: item.type || 'table',
                width: 16,
                height: 16
              }),
              createElement('span', { className: 'graph-datasource-item-name' }, item.name),
              createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: 'auto', bottom: 'auto' }
              })
            );
          };

          // Get contrast-adjusted colors with saturation and lightness adjustments
          const adjustedColors = getAdjustedColors(colors, isDarkMode, saturationAdjust, lightnessValue);

          // Calculate background color based on theme with contrast-adjusted colors
          const getBgColor = () => {
            if (isDarkMode) {
              // In dark mode, use adjusted primary color
              return hexToRgba(adjustedColors.primary, bgOpacity * 0.6, true, saturationAdjust);
            }
            return hexToRgba(adjustedColors.secondary, bgOpacity, false, saturationAdjust);
          };

          // Calculate border color based on theme with adjusted colors
          const getBorderColor = () => {
            // Convert borderOpacity (0-1) to hex (00-FF)
            const hexOpacity = Math.round(borderOpacity * 255).toString(16).padStart(2, '0');
            return `${adjustedColors.primary}${hexOpacity}`;
          };

          return createElement('div', { 
            className: 'graph-datasource-container',
            style: { 
              background: getBgColor(),
              border: `1px solid ${getBorderColor()}`,
              position: 'relative'
            }
          },
            // Color info (shown on hover) - show original and adjusted colors
            createElement('div', { 
              className: 'color-info'
            }, isDarkMode 
              ? `Adj: ${adjustedColors.primary} (from ${colors.primary})`
              : `Adj: ${adjustedColors.secondary} (from ${colors.secondary})`
            ),
            // Header
            createElement('div', { className: 'graph-datasource-header' },
              // Use logo if available, otherwise placeholder icon - 16x16
              dataSourceLogo 
                ? createElement('img', {
                    className: 'graph-datasource-icon',
                    src: dataSourceLogo,
                    alt: sourceName,
                    width: 16,
                    height: 16,
                    style: isDarkMode ? { filter: 'brightness(1.2)' } : {}
                  })
                : createElement('div', { 
                    className: 'placeholder-icon',
                    style: { background: colors.primary, color: '#fff' }
                  }, source.slice(0, 2).toUpperCase()),
              createElement('span', { 
                className: 'graph-datasource-name'
              }, sourceName)
            ),
            // Items
            createElement('div', { className: 'graph-datasource-items' },
              items.map(renderItem)
            )
          );
        }

        // =============================================
        // Node Types Registry
        // =============================================
        const nodeTypes = {
          dataSourceNode: DataSourceNode,
        };

        // =============================================
        // ELK Layout Configuration
        // =============================================
        const elk = new ELK();

        const elkLayoutOptions = {
          'elk.algorithm': 'layered',
          'elk.direction': 'RIGHT',
          'elk.spacing.nodeNode': '48',
          'elk.layered.spacing.nodeNodeBetweenLayers': '80',
          'elk.layered.spacing.edgeNodeBetweenLayers': '40',
          'elk.edgeRouting': 'SPLINES',
          'elk.layered.nodePlacement.strategy': 'BRANDES_KOEPF',
          'elk.layered.nodePlacement.bk.fixedAlignment': 'BALANCED',
          'elk.layered.crossingMinimization.strategy': 'LAYER_SWEEP',
          'elk.contentAlignment': 'V_CENTER',
        };

        async function calculateLayout(nodes, edges) {
          const elkGraph = {
            id: 'root',
            layoutOptions: elkLayoutOptions,
            children: nodes.map(node => ({
              id: node.id,
              width: node.data.width || 320,
              height: node.data.height || 200,
              layoutOptions: {
                'elk.layered.layerConstraint': node.data.layer !== undefined ? node.data.layer.toString() : undefined,
              }
            })),
            edges: edges.map(edge => ({
              id: edge.id,
              sources: [edge.source],
              targets: [edge.target],
            })),
          };

          const layoutedGraph = await elk.layout(elkGraph);

          const layoutedNodes = nodes.map(node => {
            const layoutedNode = layoutedGraph.children.find(n => n.id === node.id);
            return {
              ...node,
              position: {
                x: layoutedNode?.x || 0,
                y: layoutedNode?.y || 0,
              },
            };
          });

          return { nodes: layoutedNodes, edges };
        }

        // =============================================
        // Transform mock data to ReactFlow nodes
        // =============================================
        function transformToNodes(mockData, callbacks) {
          const nodes = [];
          const sources = Object.keys(mockData);
          
          // Arrange in a grid layout (5 columns)
          const columns = 5;
          const nodeWidth = 340;
          const gapX = 80;
          const gapY = 60;
          
          // Calculate heights for each node
          const nodeHeights = sources.map(source => {
            const data = mockData[source];
            const itemHeight = 48;
            const headerHeight = 44;
            const padding = 32;
            return headerHeight + padding + (data.items.length * itemHeight);
          });
          
          // Calculate row heights (max height in each row)
          const rowHeights = [];
          for (let i = 0; i < sources.length; i += columns) {
            const rowNodeHeights = nodeHeights.slice(i, i + columns);
            rowHeights.push(Math.max(...rowNodeHeights));
          }
          
          // Calculate cumulative Y positions for each row
          const rowYPositions = [0];
          for (let i = 0; i < rowHeights.length - 1; i++) {
            rowYPositions.push(rowYPositions[i] + rowHeights[i] + gapY);
          }
          
          sources.forEach((source, index) => {
            const data = mockData[source];
            const col = index % columns;
            const row = Math.floor(index / columns);
            const calculatedHeight = nodeHeights[index];
            
            nodes.push({
              id: source,
              type: 'dataSourceNode',
              position: { 
                x: col * (nodeWidth + gapX), 
                y: rowYPositions[row]
              },
              data: {
                source: source,
                items: data.items,
                colors: data.colors,
                width: nodeWidth,
                height: calculatedHeight,
                layer: col,
                ...callbacks
              }
            });
          });
          
          return nodes;
        }

        // =============================================
        // Main Graph Component
        // =============================================
        // Theme presets for light and dark mode
        const THEME_PRESETS = {
          light: {
            bgOpacity: 0.03,      // 3%
            borderOpacity: 0.12,  // 12%
            saturation: 40,       // +40%
            lightness: 50         // L=50
          },
          dark: {
            bgOpacity: 0.06,      // 6%
            borderOpacity: 0.16,  // 16%
            saturation: 60,       // +60%
            lightness: 50         // L=50
          }
        };

        function ColorTestGraph() {
          const [nodes, setNodes, onNodesChange] = useNodesState([]);
          const [edges, setEdges, onEdgesChange] = useEdgesState([]);
          const [selectedItemId, setSelectedItemId] = useState(null);
          const [bgOpacity, setBgOpacity] = useState(THEME_PRESETS.light.bgOpacity);
          const [borderOpacity, setBorderOpacity] = useState(THEME_PRESETS.light.borderOpacity);
          const [saturationAdjust, setSaturationAdjust] = useState(THEME_PRESETS.light.saturation);
          const [lightnessValue, setLightnessValue] = useState(THEME_PRESETS.light.lightness);
          const [isDarkMode, setIsDarkMode] = useState(false);
          
          const reactFlowInstance = useReactFlow();

          // Apply theme preset and update UI
          const applyThemePreset = useCallback((dark) => {
            const preset = dark ? THEME_PRESETS.dark : THEME_PRESETS.light;
            
            // Update state
            setBgOpacity(preset.bgOpacity);
            setBorderOpacity(preset.borderOpacity);
            setSaturationAdjust(preset.saturation);
            setLightnessValue(preset.lightness);
            
            // Update slider UI elements
            const bgSlider = document.getElementById('bg-opacity-slider');
            const bgValue = document.getElementById('bg-opacity-value');
            const borderSlider = document.getElementById('border-opacity-slider');
            const borderValue = document.getElementById('border-opacity-value');
            const satSlider = document.getElementById('saturation-slider');
            const satValue = document.getElementById('saturation-value');
            const lightSlider = document.getElementById('lightness-slider');
            const lightValue = document.getElementById('lightness-value');
            
            if (bgSlider) bgSlider.value = preset.bgOpacity * 100;
            if (bgValue) bgValue.textContent = `${preset.bgOpacity * 100}%`;
            if (borderSlider) borderSlider.value = preset.borderOpacity * 100;
            if (borderValue) borderValue.textContent = `${preset.borderOpacity * 100}%`;
            if (satSlider) satSlider.value = preset.saturation;
            if (satValue) satValue.textContent = preset.saturation >= 0 ? `+${preset.saturation}%` : `${preset.saturation}%`;
            if (lightSlider) lightSlider.value = preset.lightness;
            if (lightValue) lightValue.textContent = `${preset.lightness}`;
          }, []);

          const handleItemClick = useCallback((item, nodeId) => {
            setSelectedItemId(prev => prev === item.id ? null : item.id);
          }, []);

          // Listen to all slider changes
          useEffect(() => {
            // Background opacity slider
            const bgSlider = document.getElementById('bg-opacity-slider');
            const bgValue = document.getElementById('bg-opacity-value');
            const handleBgSlider = (e) => {
              setBgOpacity(e.target.value / 100);
              bgValue.textContent = `${e.target.value}%`;
            };
            bgSlider?.addEventListener('input', handleBgSlider);

            // Border opacity slider
            const borderSlider = document.getElementById('border-opacity-slider');
            const borderValue = document.getElementById('border-opacity-value');
            const handleBorderSlider = (e) => {
              setBorderOpacity(e.target.value / 100);
              borderValue.textContent = `${e.target.value}%`;
            };
            borderSlider?.addEventListener('input', handleBorderSlider);

            // Saturation slider
            const satSlider = document.getElementById('saturation-slider');
            const satValue = document.getElementById('saturation-value');
            const handleSatSlider = (e) => {
              const val = parseInt(e.target.value);
              setSaturationAdjust(val);
              satValue.textContent = val >= 0 ? `+${val}%` : `${val}%`;
            };
            satSlider?.addEventListener('input', handleSatSlider);

            // Lightness slider
            const lightSlider = document.getElementById('lightness-slider');
            const lightValue = document.getElementById('lightness-value');
            const handleLightSlider = (e) => {
              const val = parseInt(e.target.value);
              setLightnessValue(val);
              lightValue.textContent = `${val}`;
            };
            lightSlider?.addEventListener('input', handleLightSlider);

            return () => {
              bgSlider?.removeEventListener('input', handleBgSlider);
              borderSlider?.removeEventListener('input', handleBorderSlider);
              satSlider?.removeEventListener('input', handleSatSlider);
              lightSlider?.removeEventListener('input', handleLightSlider);
            };
          }, []);

          // Listen to theme toggle (both header and panel buttons)
          useEffect(() => {
            const themeToggle = document.getElementById('theme-toggle');
            const themeTogglePanel = document.getElementById('theme-toggle-panel');
            
            const handleThemeToggle = () => {
              const html = document.documentElement;
              const currentTheme = html.getAttribute('data-theme');
              const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
              const newIsDark = newTheme === 'dark';
              html.setAttribute('data-theme', newIsDark ? 'dark' : '');
              setIsDarkMode(newIsDark);
              applyThemePreset(newIsDark);
            };
            
            themeToggle?.addEventListener('click', handleThemeToggle);
            themeTogglePanel?.addEventListener('click', handleThemeToggle);
            return () => {
              themeToggle?.removeEventListener('click', handleThemeToggle);
              themeTogglePanel?.removeEventListener('click', handleThemeToggle);
            };
          }, [applyThemePreset]);

          // Initialize nodes
          useEffect(() => {
            const mockData = generateMockData();
            const initialNodes = transformToNodes(mockData, {
              onItemClick: handleItemClick,
              selectedItemId: selectedItemId
            });
            setNodes(initialNodes);
          }, []);

          // Update nodes when any control changes
          useEffect(() => {
            setNodes(nds => nds.map(node => ({
              ...node,
              data: {
                ...node.data,
                selectedItemId: selectedItemId,
                onItemClick: handleItemClick,
                bgOpacity: bgOpacity,
                borderOpacity: borderOpacity,
                saturationAdjust: saturationAdjust,
                lightnessValue: lightnessValue,
                isDarkMode: isDarkMode
              }
            })));
          }, [selectedItemId, handleItemClick, bgOpacity, borderOpacity, saturationAdjust, lightnessValue, isDarkMode]);

          // Handle wheel events: Command+scroll to zoom, regular scroll to pan
          useEffect(() => {
            const container = document.getElementById('lineage-graph-container');
            const handleWheel = (e) => {
              if (!reactFlowInstance) return;
              
              const { x, y, zoom } = reactFlowInstance.getViewport();
              
              if (e.metaKey || e.ctrlKey) {
                // Command/Ctrl + scroll = zoom
                const zoomSensitivity = 0.01;
                const delta = -e.deltaY * zoomSensitivity;
                const newZoom = Math.min(Math.max(zoom + delta, 0.1), 3);
                
                // Zoom towards cursor position
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate new position to zoom towards cursor
                const scale = newZoom / zoom;
                const newX = mouseX - (mouseX - x) * scale;
                const newY = mouseY - (mouseY - y) * scale;
                
                reactFlowInstance.setViewport({
                  x: newX,
                  y: newY,
                  zoom: newZoom
                });
              } else {
                // Regular scroll = pan
                reactFlowInstance.setViewport({
                  x: x - e.deltaX,
                  y: y - e.deltaY,
                  zoom: zoom
                });
              }
              e.preventDefault();
            };
            
            container?.addEventListener('wheel', handleWheel, { passive: false });
            return () => container?.removeEventListener('wheel', handleWheel);
          }, [reactFlowInstance]);

          return createElement(ReactFlowComponent, {
            nodes,
            edges,
            onNodesChange,
            onEdgesChange,
            nodeTypes,
            fitView: false,
            minZoom: 0.1,
            maxZoom: 3,
            defaultViewport: { x: 0, y: 0, zoom: 1 },
            nodesDraggable: false,
            nodesConnectable: false,
            elementsSelectable: true,
            panOnDrag: true,
            zoomOnScroll: false,
            zoomOnPinch: false,
            zoomOnDoubleClick: false,
            panOnScroll: true,
            preventScrolling: false,
            proOptions: { hideAttribution: true }
          },
            createElement(Controls, { showInteractive: false }),
            createElement(Background, { 
              variant: BackgroundVariant.Dots, 
              gap: 20, 
              size: 1.5, 
              color: isDarkMode ? 'rgba(45, 55, 72, 0.8)' : 'rgba(200, 205, 215, 1)' 
            })
          );
        }

        // =============================================
        // Render the app
        // =============================================
        const container = document.getElementById('lineage-graph-container');
        if (container) {
          const root = createRoot(container);
          root.render(
            createElement(ReactFlowProvider, null,
              createElement(ColorTestGraph)
            )
          );
        }
      });
    </script>
  </body>
</html>
