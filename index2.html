<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lineage List</title>
    <link rel="stylesheet" href="./styles.css" />
    <link rel="stylesheet" href="./lineage-graph.css" />
    <!-- React Flow CSS -->
    <link rel="stylesheet" href="https://unpkg.com/reactflow@11.11.4/dist/style.css" />
  </head>
  <body>
    <script>
      // Disable browser's automatic scroll restoration on reload
      if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
      }
      
      document.addEventListener('DOMContentLoaded', () => {
        const HEADER_HEIGHT = 28;
        const CONTAINER_PADDING = 16;
        const PANEL_WIDTH = 280;
        const scrollContainer = document.querySelector('.lineage-scroll');
        const headers = Array.from(document.querySelectorAll('.depth-header'));
        
        // Store header data with order and natural positions
        const headerData = headers.map((header, index) => {
          return {
            el: header,
            order: index,
            naturalTop: 0 // Will be calculated after load
          };
        });

        function updateStickyHeaders() {
          if (!scrollContainer) return;
          
          const scrollTop = scrollContainer.scrollTop;
          const containerHeight = scrollContainer.clientHeight;
          const scrollBottom = scrollTop + containerHeight;
          
          // Calculate cumulative offsets for each header based on content above it
          let cumulativeOffset = 0;
          headerData.forEach((data, index) => {
            // Get the header's position relative to the scroll container's content
            const headerOffsetTop = data.el.offsetTop;
            
            // Calculate top sticky offset (how many headers above are stuck)
            const topOffset = index * HEADER_HEIGHT;
            
            // Calculate bottom sticky offset (how many headers below could be stuck)
            const bottomIndex = headerData.length - 1 - index;
            const bottomOffset = bottomIndex * HEADER_HEIGHT;
            
            // Apply sticky positioning with calculated offsets
            data.el.style.position = 'sticky';
            data.el.style.top = topOffset + 'px';
            data.el.style.bottom = bottomOffset + 'px';
            data.el.style.zIndex = 100 - index;
          });
        }

        // Function to recalculate natural positions
        function recalculateNaturalPositions() {
          if (!scrollContainer) return;
          headerData.forEach((data) => {
            data.naturalTop = getOffsetInContainer(data.el);
          });
        }

        // Run on scroll and resize
        scrollContainer.addEventListener('scroll', updateStickyHeaders, { passive: true });
        window.addEventListener('resize', () => {
          recalculateNaturalPositions();
          updateStickyHeaders();
        });
        
        // Initial calls - ensure layout is computed after images load
        updateStickyHeaders();
        requestAnimationFrame(updateStickyHeaders);
        
        // Helper to get element's top position relative to scroll container
        function getOffsetInContainer(element) {
          if (!scrollContainer) return 0;
          let offset = 0;
          let el = element;
          while (el && el !== scrollContainer && el !== document.body) {
            offset += el.offsetTop;
            el = el.offsetParent;
          }
          return offset;
        }

        // Also run after all resources (images) are loaded
        window.addEventListener('load', () => {
          // Calculate and store natural positions for all headers
          headerData.forEach((data) => {
            data.naturalTop = getOffsetInContainer(data.el);
          });
          
          // Scroll to center the focus section
          const focalHeader = document.querySelector('.depth-header--focal');
          const focalData = headerData.find(d => d.el === focalHeader);
          if (focalData && scrollContainer) {
            const containerHeight = scrollContainer.clientHeight;
            const targetScroll = focalData.naturalTop - (containerHeight / 2) + (HEADER_HEIGHT / 2);
            scrollContainer.scrollTo({ top: Math.max(0, targetScroll), behavior: 'instant' });
          }
          
          // Update sticky headers after scroll
          setTimeout(updateStickyHeaders, 10);
          setTimeout(updateStickyHeaders, 50);
          setTimeout(updateStickyHeaders, 100);
        });

        // Depth header click to scroll - scroll to show section at top
        headers.forEach((header, index) => {
          header.addEventListener('click', (e) => {
            if (!scrollContainer) return;
            
            // Use pre-calculated natural position
            const data = headerData[index];
            if (!data) return;
            
            // Recalculate natural positions if they are 0 (e.g., after switching from graph view)
            if (data.naturalTop === 0 && index > 0) {
              recalculateNaturalPositions();
            }
            
            // Scroll so this header is at the top, accounting for headers above
            const stickyOffset = index * HEADER_HEIGHT;
            const targetPosition = data.naturalTop - stickyOffset;
            scrollContainer.scrollTo({ top: Math.max(0, targetPosition), behavior: 'smooth' });
          });
        });

        // Group collapse toggle
        document.querySelectorAll('.group-header').forEach(groupHeader => {
          groupHeader.addEventListener('click', (e) => {
            e.stopPropagation();
            const group = groupHeader.closest('.object-group');
            group.classList.toggle('collapsed');
            // Update sticky headers after collapse animation
            setTimeout(updateStickyHeaders, 50);
            setTimeout(updateStickyHeaders, 150);
            setTimeout(updateStickyHeaders, 300);
            // Update collapse/expand all button state
            updateCollapseExpandAllButton();
          });
        });

        // Collapse/Expand all groups toggle
        let allGroupsCollapsed = false;
        const collapseExpandAllBtn = document.getElementById('collapse-expand-all');
        
        function updateCollapseExpandAllButton() {
          const allGroups = document.querySelectorAll('.object-group');
          const collapsedGroups = document.querySelectorAll('.object-group.collapsed');
          allGroupsCollapsed = collapsedGroups.length === allGroups.length;
          
          const img = collapseExpandAllBtn.querySelector('img');
          if (allGroupsCollapsed) {
            img.src = './img/chevrons-expand.svg';
            img.alt = 'Expand all';
            collapseExpandAllBtn.title = 'Expand all groups';
          } else {
            img.src = './img/chevrons-collapse.svg';
            img.alt = 'Collapse all';
            collapseExpandAllBtn.title = 'Collapse all groups';
          }
        }
        
        collapseExpandAllBtn.addEventListener('click', () => {
          const allGroups = document.querySelectorAll('.object-group');
          
          if (allGroupsCollapsed) {
            // Expand all
            allGroups.forEach(group => group.classList.remove('collapsed'));
          } else {
            // Collapse all
            allGroups.forEach(group => group.classList.add('collapsed'));
          }
          
          allGroupsCollapsed = !allGroupsCollapsed;
          updateCollapseExpandAllButton();
          
          // Update sticky headers after collapse animation
          setTimeout(updateStickyHeaders, 50);
          setTimeout(updateStickyHeaders, 150);
          setTimeout(updateStickyHeaders, 300);
          
          // Update connection overflow
          setTimeout(updateConnectionOverflow, 350);
        });

        // Graph view: Collapse/Expand all groups button
        const graphCollapseExpandBtn = document.getElementById('graph-collapse-expand-all');
        
        function updateGraphCollapseExpandButton() {
          if (!graphCollapseExpandBtn) return;
          
          const state = window.getGraphGroupsCollapseState ? window.getGraphGroupsCollapseState() : { allCollapsed: false };
          const img = graphCollapseExpandBtn.querySelector('img');
          
          if (state.allCollapsed) {
            img.src = './img/chevrons-expand.svg';
            img.alt = 'Expand all';
            graphCollapseExpandBtn.title = 'Expand all groups';
          } else {
            img.src = './img/chevrons-collapse.svg';
            img.alt = 'Collapse all';
            graphCollapseExpandBtn.title = 'Collapse all groups';
          }
        }
        
        if (graphCollapseExpandBtn) {
          graphCollapseExpandBtn.addEventListener('click', () => {
            if (window.toggleGraphGroupsCollapse) {
              const result = window.toggleGraphGroupsCollapse();
              updateGraphCollapseExpandButton();
            }
          });
        }
        
        // Expose the update function for React to call when state changes
        window.updateGraphCollapseExpandButton = updateGraphCollapseExpandButton;

        // Hover highlighting for connected objects
        const allItems = document.querySelectorAll('.group-list li');
        
        // Build a map of object names to their elements
        const objectMap = new Map();
        allItems.forEach(item => {
          const nameEl = item.querySelector('.object-name');
          if (nameEl) {
            const name = nameEl.textContent.trim().toLowerCase();
            if (!objectMap.has(name)) {
              objectMap.set(name, []);
            }
            objectMap.get(name).push(item);
          }
        });

        // ===========================================
        // Leaf Node Detection
        // Mark nodes that don't have upstream or downstream lineage
        // ===========================================
        allItems.forEach(item => {
          const hasUpstreamConnections = item.querySelector('.connections--upstream');
          const hasDownstreamConnections = item.querySelector('.connections--downstream');
          
          // If no upstream connections element exists, this is an upstream leaf
          // (no sources feeding into this node)
          if (!hasUpstreamConnections) {
            item.classList.add('leaf-upstream');
          }
          
          // If no downstream connections element exists, this is a downstream leaf
          // (no destinations from this node)
          if (!hasDownstreamConnections) {
            item.classList.add('leaf-downstream');
          }
        });

        // Get depth level of an item
        function getDepthRow(item) {
          const depthContent = item.closest('.depth-content');
          return depthContent ? parseInt(depthContent.dataset.row) : null;
        }

        // Find connected objects with direction
        function getConnectedObjects(item) {
          const upstream = []; // -1 level (connection tags highlight)
          const downstream = []; // +1 level (object name highlights)
          const currentRow = getDepthRow(item);
          const currentName = item.querySelector('.object-name')?.textContent.trim().toLowerCase();
          
          // Get objects referenced in this item's connection tags
          const connectionTags = item.querySelectorAll('.connection-tag');
          connectionTags.forEach(tag => {
            const refName = tag.textContent.trim().toLowerCase();
            const refItems = objectMap.get(refName) || [];
            refItems.forEach(refItem => {
              const refRow = getDepthRow(refItem);
              if (refRow === currentRow - 1) {
                upstream.push(refItem);
              } else if (refRow === currentRow + 1) {
                downstream.push(refItem);
              }
            });
          });
          
          // Find objects that reference this item
          allItems.forEach(otherItem => {
            const otherRow = getDepthRow(otherItem);
            const otherTags = otherItem.querySelectorAll('.connection-tag');
            otherTags.forEach(tag => {
              if (tag.textContent.trim().toLowerCase() === currentName) {
                if (otherRow === currentRow - 1) {
                  upstream.push(otherItem);
                } else if (otherRow === currentRow + 1) {
                  downstream.push(otherItem);
                }
              }
            });
          });
          
          return { upstream, downstream };
        }

        // Add hover listeners
        allItems.forEach(item => {
          item.addEventListener('mouseenter', () => {
            // Highlight current row's connection tags
            item.classList.add('highlight-current');
            
            // Get connected objects
            const { upstream, downstream } = getConnectedObjects(item);
            
            // Highlight upstream (-1) objects - their connection tags
            upstream.forEach(upItem => {
              upItem.classList.add('highlight-upstream');
            });
            
            // Highlight downstream (+1) objects - their object names
            downstream.forEach(downItem => {
              downItem.classList.add('highlight-downstream');
            });
          });
          
          item.addEventListener('mouseleave', () => {
            item.classList.remove('highlight-current');
            document.querySelectorAll('.highlight-upstream').forEach(el => {
              el.classList.remove('highlight-upstream');
            });
            document.querySelectorAll('.highlight-downstream').forEach(el => {
              el.classList.remove('highlight-downstream');
            });
          });
        });

        // Click on connection-tag to scroll to and select corresponding node
        document.querySelectorAll('.connection-tag').forEach(tag => {
          tag.style.cursor = 'pointer';
          tag.addEventListener('click', (e) => {
            e.stopPropagation();
            const refName = tag.textContent.trim().toLowerCase();
            const refItems = objectMap.get(refName) || [];
            
            if (refItems.length > 0) {
              const targetItem = refItems[0];
              
              // Expand parent group if collapsed
              const parentGroup = targetItem.closest('.object-group');
              if (parentGroup && parentGroup.classList.contains('collapsed')) {
                parentGroup.classList.toggle('collapsed');
                setTimeout(() => {
                  scrollToItem(targetItem);
                  selectItem(targetItem);
                }, 100);
              } else {
                scrollToItem(targetItem);
                selectItem(targetItem);
              }
            }
          });
        });

        // ===========================================
        // Connection Overflow Detection & Popover
        // ===========================================
        
        // Create popover element
        const popover = document.createElement('div');
        popover.className = 'connection-popover';
        popover.innerHTML = `
          <div class="connection-popover-section connection-popover-upstream">
            <div class="connection-popover-label connection-popover-label--upstream">Upstream</div>
            <ul class="connection-popover-list"></ul>
          </div>
          <div class="connection-popover-section connection-popover-downstream">
            <div class="connection-popover-label connection-popover-label--downstream">Downstream</div>
            <ul class="connection-popover-list"></ul>
          </div>
        `;
        document.body.appendChild(popover);
        
        let popoverTimeout = null;
        let activePopoverTrigger = null;
        
        // Hide popover function
        function hidePopover() {
          popover.classList.remove('visible');
          activePopoverTrigger = null;
        }
        
        // Show popover with connection data
        function showPopover(trigger, item) {
          if (popoverTimeout) clearTimeout(popoverTimeout);
          
          const { upstream, downstream } = getConnectedObjects(item);
          
          // Populate upstream section
          const upstreamSection = popover.querySelector('.connection-popover-upstream');
          const upstreamList = upstreamSection.querySelector('.connection-popover-list');
          upstreamList.innerHTML = '';
          
          if (upstream.length > 0) {
            upstreamSection.style.display = 'block';
            upstream.forEach(upItem => {
              const name = upItem.querySelector('.object-name')?.textContent || '';
              const iconSrc = upItem.querySelector('.object-icon')?.src || './img/ui/table.svg';
              const li = document.createElement('li');
              li.className = 'connection-popover-item';
              li.innerHTML = `
                <img class="connection-popover-item-icon" src="${iconSrc}" alt="">
                <span class="connection-popover-item-name">${name}</span>
              `;
              li.addEventListener('click', () => {
                hidePopover();
                scrollToItem(upItem);
                selectItem(upItem);
              });
              upstreamList.appendChild(li);
            });
          } else {
            upstreamSection.style.display = 'none';
          }
          
          // Populate downstream section
          const downstreamSection = popover.querySelector('.connection-popover-downstream');
          const downstreamList = downstreamSection.querySelector('.connection-popover-list');
          downstreamList.innerHTML = '';
          
          if (downstream.length > 0) {
            downstreamSection.style.display = 'block';
            downstream.forEach(downItem => {
              const name = downItem.querySelector('.object-name')?.textContent || '';
              const iconSrc = downItem.querySelector('.object-icon')?.src || './img/ui/table.svg';
              const li = document.createElement('li');
              li.className = 'connection-popover-item';
              li.innerHTML = `
                <img class="connection-popover-item-icon" src="${iconSrc}" alt="">
                <span class="connection-popover-item-name">${name}</span>
              `;
              li.addEventListener('click', () => {
                hidePopover();
                scrollToItem(downItem);
                selectItem(downItem);
              });
              downstreamList.appendChild(li);
            });
          } else {
            downstreamSection.style.display = 'none';
          }
          
          // Position popover
          const rect = trigger.getBoundingClientRect();
          const popoverHeight = popover.offsetHeight || 200;
          const popoverWidth = popover.offsetWidth || 240;
          
          let top = rect.bottom + 8;
          let left = rect.left;
          
          // Adjust if would go off screen
          if (top + popoverHeight > window.innerHeight) {
            top = rect.top - popoverHeight - 8;
          }
          if (left + popoverWidth > window.innerWidth) {
            left = window.innerWidth - popoverWidth - 16;
          }
          
          popover.style.top = `${top}px`;
          popover.style.left = `${left}px`;
          popover.classList.add('visible');
          activePopoverTrigger = trigger;
        }
        
        // Popover mouse events
        popover.addEventListener('mouseenter', () => {
          if (popoverTimeout) clearTimeout(popoverTimeout);
        });
        
        popover.addEventListener('mouseleave', () => {
          popoverTimeout = setTimeout(hidePopover, 150);
        });
        
        // Handle overflow detection and compact counters
        function updateConnectionOverflow() {
          const connectionsContainers = document.querySelectorAll('.connections');
          
          connectionsContainers.forEach(container => {
            const tags = Array.from(container.querySelectorAll('.connection-tag'));
            if (tags.length === 0) return;
            
            const item = container.closest('li');
            if (!item) return;
            
            // Remove existing overflow badge and compact counter
            const existingOverflow = container.querySelector('.connection-overflow');
            if (existingOverflow) existingOverflow.remove();
            const existingCompact = container.querySelector('.connection-compact-counter');
            if (existingCompact) existingCompact.remove();
            
            // Reset all tags to visible
            tags.forEach(tag => tag.style.display = '');
            
            const containerWidth = container.clientWidth;
            const arrowWidth = 20; // Arrow pseudo-element width
            const overflowBadgeWidth = 32; // Approximate width for "+N" badge
            const totalConnections = tags.length;
            
            // If only 1 connection, always show it (no overflow logic needed)
            if (totalConnections === 1) {
              // Just add compact counter for narrow screens (CSS will hide/show appropriately)
              addCompactCounter(container, item, totalConnections);
              return;
            }
            
            // First pass: measure all tags to see if they fit without overflow badge
            let totalWidthWithoutBadge = arrowWidth;
            let allFit = true;
            
            tags.forEach(tag => {
              const tagWidth = tag.offsetWidth + 4; // +4 for gap
              totalWidthWithoutBadge += tagWidth;
            });
            
            if (totalWidthWithoutBadge <= containerWidth) {
              // All tags fit, no overflow needed
              addCompactCounter(container, item, totalConnections);
              return;
            }
            
            // Second pass: determine how many fit with space reserved for overflow badge
            let totalWidth = arrowWidth;
            let visibleCount = 0;
            let hiddenCount = 0;
            const availableWidth = containerWidth - overflowBadgeWidth;
            
            tags.forEach((tag, index) => {
              const tagWidth = tag.offsetWidth + 4; // +4 for gap
              if (totalWidth + tagWidth <= availableWidth) {
                totalWidth += tagWidth;
                visibleCount++;
              } else {
                tag.style.display = 'none';
                hiddenCount++;
              }
            });
            
            // Ensure at least 1 tag is always visible (don't hide all in overflow)
            if (visibleCount === 0 && tags.length > 0) {
              tags[0].style.display = '';
              visibleCount = 1;
              hiddenCount = tags.length - 1;
            }
            
            // Add overflow badge if some tags are hidden
            if (hiddenCount > 0) {
              const overflowBadge = document.createElement('span');
              overflowBadge.className = 'connection-overflow';
              overflowBadge.textContent = `+${hiddenCount}`;
              overflowBadge.title = `${hiddenCount} more connection${hiddenCount > 1 ? 's' : ''}`;
              
              // Hover to show popover
              overflowBadge.addEventListener('mouseenter', () => {
                showPopover(overflowBadge, item);
              });
              overflowBadge.addEventListener('mouseleave', () => {
                popoverTimeout = setTimeout(hidePopover, 150);
              });
              overflowBadge.addEventListener('click', (e) => {
                e.stopPropagation();
                showPopover(overflowBadge, item);
              });
              
              container.appendChild(overflowBadge);
            }
            
            // Add compact counter for narrow screens
            addCompactCounter(container, item, totalConnections);
            
            // Add hover listeners to the entire connections container
            addConnectionsHover(container, item);
          });
        }
        
        // Helper function to add hover behavior to connections container
        function addConnectionsHover(container, item) {
          // Remove existing listeners by cloning (to avoid duplicates on resize)
          if (!container.dataset.hoverEnabled) {
            container.dataset.hoverEnabled = 'true';
            
            container.addEventListener('mouseenter', () => {
              showPopover(container, item);
            });
            container.addEventListener('mouseleave', () => {
              popoverTimeout = setTimeout(hidePopover, 150);
            });
          }
        }
        
        // Helper function to add compact counter
        function addCompactCounter(container, item, totalConnections) {
          const isDownstream = container.classList.contains('connections--downstream');
          
          const compactCounter = document.createElement('span');
          compactCounter.className = `connection-compact-counter ${isDownstream ? 'connection-compact-counter--downstream' : 'connection-compact-counter--upstream'}`;
          compactCounter.textContent = totalConnections;
          compactCounter.title = `${totalConnections} ${isDownstream ? 'downstream' : 'upstream'} connection${totalConnections > 1 ? 's' : ''}`;
          
          // Hover to show popover
          compactCounter.addEventListener('mouseenter', () => {
            showPopover(compactCounter, item);
          });
          compactCounter.addEventListener('mouseleave', () => {
            popoverTimeout = setTimeout(hidePopover, 150);
          });
          compactCounter.addEventListener('click', (e) => {
            e.stopPropagation();
            showPopover(compactCounter, item);
          });
          
          container.appendChild(compactCounter);
        }
        
        // Run overflow detection on load and resize
        updateConnectionOverflow();
        window.addEventListener('resize', () => {
          updateConnectionOverflow();
        });
        
        // Also update when groups collapse/expand
        document.querySelectorAll('.group-header').forEach(groupHeader => {
          groupHeader.addEventListener('click', () => {
            setTimeout(updateConnectionOverflow, 350);
          });
        });

        function scrollToItem(targetItem, highlight = true) {
          if (!scrollContainer || !targetItem) return;
          const targetTop = getOffsetInContainer(targetItem);
          const containerHeight = scrollContainer.clientHeight;
          const targetScroll = targetTop - (containerHeight / 2) + 16;
          
          scrollContainer.scrollTo({ top: Math.max(0, targetScroll), behavior: 'smooth' });
          
          // Briefly highlight the target (optional)
          if (highlight) {
            targetItem.style.transition = 'background 0.3s';
            targetItem.style.background = 'hsla(217, 13%, 94%, 1)';
            setTimeout(() => {
              targetItem.style.background = '';
              setTimeout(() => {
                targetItem.style.transition = '';
              }, 300);
            }, 1000);
          }
        }

        // Global function to center list view on focused/selected item
        window.centerListOnSelected = function() {
          // First try to find selected item
          const selectedItem = document.querySelector('.group-list li.selected');
          if (selectedItem) {
            scrollToItem(selectedItem, false);
            return;
          }
          
          // Fall back to focal item (in the focal depth section)
          const focalSection = document.querySelector('.depth-content--focal');
          if (focalSection) {
            const focalItem = focalSection.querySelector('.group-list li');
            if (focalItem) {
              scrollToItem(focalItem, false);
            }
          }
        };

        // Object selection and side panel
        const sidePanel = document.getElementById('sidePanel');
        const panelObjectView = document.getElementById('panelObjectView');
        const panelEdgeView = document.getElementById('panelEdgeView');
        const panelColumnView = document.getElementById('panelColumnView');
        const panelClose = document.getElementById('panelClose');
        const panelEdgeClose = document.getElementById('panelEdgeClose');
        const panelColumnClose = document.getElementById('panelColumnClose');
        const panelIcon = document.getElementById('panelIcon');
        const panelTitle = document.getElementById('panelTitle');
        const panelPath = document.getElementById('panelPath');
        const panelComment = document.getElementById('panelComment');
        const panelOwner = document.getElementById('panelOwner');
        const panelCreated = document.getElementById('panelCreated');
        const panelQuality = document.getElementById('panelQuality');
        const panelColumnCount = document.getElementById('panelColumnCount');
        const panelColumnCountLabel = document.getElementById('panelColumnCountLabel');
        const panelTags = document.getElementById('panelTags');
        const panelDynamicSections = document.getElementById('panelDynamicSections');
        const panelTabs = document.getElementById('panelTabs');
        const panelColumnsTab = document.getElementById('panelColumnsTab');
        const panelDetailsContent = document.getElementById('panelDetailsContent');
        const panelUpstreamTab = document.getElementById('panelUpstreamTab');
        const panelDownstreamTab = document.getElementById('panelDownstreamTab');
        const panelUpstreamContent = document.getElementById('panelUpstreamContent');
        const panelDownstreamContent = document.getElementById('panelDownstreamContent');
        const panelUpstreamList = document.getElementById('panelUpstreamList');
        const panelDownstreamList = document.getElementById('panelDownstreamList');
        // Edge panel elements
        const panelEdgeTitle = document.getElementById('panelEdgeTitle');
        const panelEdgeTabs = document.getElementById('panelEdgeTabs');
        const panelEdgeDetailsContent = document.getElementById('panelEdgeDetailsContent');
        const panelEdgeSqlContent = document.getElementById('panelEdgeSqlContent');
        const panelStoredProcsTab = document.getElementById('panelStoredProcsTab');
        const panelTasksTab = document.getElementById('panelTasksTab');
        const panelQueryType = document.getElementById('panelQueryType');
        const panelRunBy = document.getElementById('panelRunBy');
        const panelRunOn = document.getElementById('panelRunOn');
        const panelDuration = document.getElementById('panelDuration');
        const panelQueryId = document.getElementById('panelQueryId');
        const panelRowCount = document.getElementById('panelRowCount');
        const panelSqlQuery = document.getElementById('panelSqlQuery');
        const panelStoredProcsContent = document.getElementById('panelStoredProcsContent');
        const panelTasksContent = document.getElementById('panelTasksContent');
        // Column panel elements
        const panelColumnTitle = document.getElementById('panelColumnTitle');
        const panelColumnPath = document.getElementById('panelColumnPath');
        const panelColumnTypeIcon = document.getElementById('panelColumnTypeIcon');
        const panelColumnTabs = document.getElementById('panelColumnTabs');
        const panelColumnDetailsContent = document.getElementById('panelColumnDetailsContent');
        const panelColumnUpstreamTab = document.getElementById('panelColumnUpstreamTab');
        const panelColumnDownstreamTab = document.getElementById('panelColumnDownstreamTab');
        const panelColumnUpstreamContent = document.getElementById('panelColumnUpstreamContent');
        const panelColumnDownstreamContent = document.getElementById('panelColumnDownstreamContent');
        const panelColumnDescription = document.getElementById('panelColumnDescription');
        const panelColumnType = document.getElementById('panelColumnType');
        const panelColumnParent = document.getElementById('panelColumnParent');
        const panelColumnKeyRow = document.getElementById('panelColumnKeyRow');
        const panelColumnKeyType = document.getElementById('panelColumnKeyType');
        const panelColumnUpstreamList = document.getElementById('panelColumnUpstreamList');
        const panelColumnDownstreamList = document.getElementById('panelColumnDownstreamList');
        let selectedListItem = null;
        
        // =============================================
        // Sticky Section Headers in Side Panel (Accordion Pattern)
        // Uses fixed positioning for stuck headers to escape parent constraints
        // =============================================
        const PANEL_HEADER_HEIGHT = 49; // Height of sticky header for stack positioning
        const PANEL_HEADER_PLACEHOLDER_HEIGHT = 57; // Height of placeholder when header is fixed
        
        function updatePanelStickyHeaders(panelContent) {
          if (!panelContent) return;
          
          const scrollTop = panelContent.scrollTop;
          const containerHeight = panelContent.clientHeight;
          const contentRect = panelContent.getBoundingClientRect();
          const containerTop = contentRect.top;
          const containerLeft = contentRect.left;
          const containerWidth = contentRect.width;
          
          // Get all section groups within this panel content
          const sectionGroups = Array.from(panelContent.querySelectorAll('.panel-section-group'));
          
          // Filter to only visible sections
          const visibleGroups = sectionGroups.filter(group => {
            const style = window.getComputedStyle(group);
            return style.display !== 'none';
          });
          
          const totalHeaders = visibleGroups.length;
          
          // First pass: reset all headers to get accurate natural positions
          visibleGroups.forEach((group) => {
            const header = group.querySelector('.panel-section-header');
            let placeholder = group.querySelector('.panel-header-placeholder');
            if (placeholder) placeholder.style.height = '0px';
            if (header) {
              header.style.position = 'relative';
              header.style.top = '';
              header.style.bottom = '';
              header.style.left = '';
              header.style.width = '';
              header.style.zIndex = '';
            }
          });
          
          // Second pass: calculate and apply sticky positions
          visibleGroups.forEach((group, index) => {
            const header = group.querySelector('.panel-section-header');
            if (!header) return;
            
            // Ensure placeholder exists for when header becomes fixed
            let placeholder = group.querySelector('.panel-header-placeholder');
            if (!placeholder) {
              placeholder = document.createElement('div');
              placeholder.className = 'panel-header-placeholder';
              placeholder.style.height = '0px';
              placeholder.style.visibility = 'hidden';
              group.insertBefore(placeholder, header);
            }
            
            // Get header's true natural position in scroll content
            const headerRect = header.getBoundingClientRect();
            const headerNaturalY = headerRect.top;
            
            // Stack positions (in viewport coordinates)
            const topStackY = containerTop + (index * PANEL_HEADER_HEIGHT);
            const bottomStackY = containerTop + containerHeight - ((totalHeaders - index) * PANEL_HEADER_HEIGHT);
            
            // Determine state - header sticks when it reaches the stack edge
            const shouldStickTop = headerNaturalY < topStackY;
            const shouldStickBottom = headerNaturalY > bottomStackY;
            
            if (shouldStickTop) {
              // Stick to top
              placeholder.style.height = PANEL_HEADER_PLACEHOLDER_HEIGHT + 'px';
              header.style.position = 'fixed';
              header.style.top = topStackY + 'px';
              header.style.bottom = 'auto';
              header.style.left = containerLeft + 'px';
              header.style.width = containerWidth + 'px';
              header.style.zIndex = 1000 + index;
              header.classList.add('is-sticky-top');
              header.classList.remove('is-sticky-bottom');
            } else if (shouldStickBottom) {
              // Stick to bottom
              placeholder.style.height = PANEL_HEADER_PLACEHOLDER_HEIGHT + 'px';
              header.style.position = 'fixed';
              header.style.top = bottomStackY + 'px';
              header.style.bottom = 'auto';
              header.style.left = containerLeft + 'px';
              header.style.width = containerWidth + 'px';
              header.style.zIndex = 1000 + (totalHeaders - index);
              header.classList.remove('is-sticky-top');
              header.classList.add('is-sticky-bottom');
            } else {
              // Natural position
              header.classList.remove('is-sticky-top');
              header.classList.remove('is-sticky-bottom');
            }
            // If neither, header stays in natural position (already reset above)
          });
        }
        
        // Initialize sticky headers for all panel contents
        function initPanelStickyHeaders() {
          document.querySelectorAll('.panel-content').forEach(panelContent => {
            // Update on scroll
            panelContent.addEventListener('scroll', () => {
              updatePanelStickyHeaders(panelContent);
            }, { passive: true });
          });
          
          // Also update on window resize
          window.addEventListener('resize', () => {
            document.querySelectorAll('.panel-content').forEach(panelContent => {
              updatePanelStickyHeaders(panelContent);
            });
          });
        }
        
        // Initialize scroll listeners
        initPanelStickyHeaders();
        
        // Helper function to scroll a section to top
        function scrollSectionToTop(group) {
          const panelContent = group.closest('.panel-content');
          if (!panelContent) return;
          
          // Get visible groups to calculate target scroll position
          const sectionGroups = Array.from(panelContent.querySelectorAll('.panel-section-group'));
          const visibleGroups = sectionGroups.filter(g => {
            const style = window.getComputedStyle(g);
            return style.display !== 'none';
          });
          
          const index = visibleGroups.indexOf(group);
          if (index === -1) return;
          
          // Reset all placeholders to get accurate group positions
          visibleGroups.forEach(g => {
            const placeholder = g.querySelector('.panel-header-placeholder');
            if (placeholder) placeholder.style.height = '0px';
            const h = g.querySelector('.panel-section-header');
            if (h) {
              h.style.position = 'relative';
              h.style.top = '';
              h.style.left = '';
              h.style.width = '';
              h.classList.remove('is-sticky-top', 'is-sticky-bottom');
            }
          });
          
          // Calculate scroll position: position the placeholder at the edge of scroll area
          // Headers 0 to index will all be sticky, taking (index + 1) * PANEL_HEADER_HEIGHT
          // The placeholder should meet right at that edge
          const targetScrollTop = group.offsetTop - ((index + 1) * PANEL_HEADER_HEIGHT);
          panelContent.scrollTo({ top: Math.max(0, targetScrollTop), behavior: 'smooth' });
          
          // Update sticky headers after scroll
          setTimeout(() => updatePanelStickyHeaders(panelContent), 10);
          setTimeout(() => updatePanelStickyHeaders(panelContent), 100);
          setTimeout(() => updatePanelStickyHeaders(panelContent), 300);
          setTimeout(() => updatePanelStickyHeaders(panelContent), 500);
        }
        
        // Helper function to attach click handlers to section headers within a container
        function attachSectionHeaderHandlers(container) {
          container.querySelectorAll('.panel-section-header').forEach(header => {
            header.addEventListener('click', function(e) {
              // Don't scroll if clicking on the chevron button
              if (e.target.closest('.panel-section-chevron-btn')) return;
              
              const group = this.closest('.panel-section-group');
              if (group) scrollSectionToTop(group);
            });
          });
          
          container.querySelectorAll('.panel-section-chevron-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
              e.stopPropagation(); // Prevent header click from firing
              
              const group = this.closest('.panel-section-group');
              if (group) scrollSectionToTop(group);
            });
          });
        }
        
        // Setup section header click handlers for existing sections
        attachSectionHeaderHandlers(document);
        
        // Generic tab click handler function
        function setupPanelTabs(tabsContainer) {
          if (!tabsContainer) return;
          tabsContainer.addEventListener('click', (e) => {
            const tab = e.target.closest('.panel-tab');
            if (!tab) return;
            
            const tabId = tab.dataset.tab;
            
            // Update active tab
            tabsContainer.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            // Update active content
            const panelContent = tabsContainer.closest('.panel-view')?.querySelector('.panel-content');
            if (panelContent) {
              panelContent.querySelectorAll('.panel-tab-content').forEach(content => {
                content.classList.toggle('active', content.dataset.tabContent === tabId);
              });
            }
          });
        }
        
        // Generic subtab click handler function
        function setupPanelSubtabs(subtabsContainer) {
          if (!subtabsContainer) return;
          subtabsContainer.addEventListener('click', (e) => {
            const tab = e.target.closest('.panel-tab');
            if (!tab) return;
            
            const subtabId = tab.dataset.subtab;
            
            // Update active subtab
            subtabsContainer.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            // Update active subtab content
            const parentContent = subtabsContainer.closest('.panel-tab-content');
            if (parentContent) {
              parentContent.querySelectorAll('.panel-subtab-content').forEach(content => {
                content.classList.toggle('active', content.dataset.subtabContent === subtabId);
              });
            }
          });
        }
        
        // Setup panel tab click handlers for all panels
        setupPanelTabs(panelTabs);
        setupPanelTabs(panelEdgeTabs);
        setupPanelTabs(panelColumnTabs);
        
        // Setup edge panel close button
        if (panelEdgeClose) {
          panelEdgeClose.addEventListener('click', () => {
            window.sharedSelection.clearSelection();
          });
        }
        
        // Setup column panel close button
        if (panelColumnClose) {
          panelColumnClose.addEventListener('click', () => {
            window.sharedSelection.clearSelection();
          });
        }

        // Helper: Get column type icon path (same logic as graph view)
        function getPanelColumnIcon(type) {
          const normalizedType = (type || '').toUpperCase();
          if (['VARCHAR', 'TEXT', 'STRING', 'CHAR'].some(t => normalizedType.includes(t))) return 'img/ui/text.svg';
          if (['INTEGER', 'INT', 'BIGINT', 'NUMBER', 'SMALLINT', 'TINYINT'].some(t => normalizedType.includes(t))) return 'img/ui/number.svg';
          if (['DECIMAL', 'FLOAT', 'DOUBLE', 'NUMERIC', 'REAL'].some(t => normalizedType.includes(t))) return 'img/ui/number.svg';
          if (['BOOLEAN', 'BOOL'].some(t => normalizedType.includes(t))) return 'img/ui/boolean.svg';
          if (['BINARY', 'VARBINARY', 'BLOB', 'BYTES'].some(t => normalizedType.includes(t))) return 'img/ui/binary.svg';
          if (normalizedType.includes('DATE') && !normalizedType.includes('TIME')) return 'img/ui/calendar.svg';
          if (['TIMESTAMP', 'DATETIME', 'TIME'].some(t => normalizedType.includes(t))) return 'img/ui/calendar.svg';
          if (['JSON', 'VARIANT'].some(t => normalizedType.includes(t))) return 'img/ui/format-code.svg';
          if (['OBJECT', 'STRUCT', 'MAP'].some(t => normalizedType.includes(t))) return 'img/ui/object.svg';
          if (normalizedType.includes('ARRAY')) return 'img/ui/array.svg';
          if (normalizedType === 'MEASURE') return 'img/ui/number.svg';
          if (normalizedType === 'DIMENSION') return 'img/ui/object.svg';
          return 'img/ui/column-single.svg';
        }

        // Helper: SQL syntax highlighter
        function highlightSQL(sql) {
          if (!sql) return '';
          
          // Escape HTML first
          const escapeHtml = (str) => str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
          
          // SQL keywords (case-insensitive)
          const keywords = new Set([
            'SELECT', 'FROM', 'WHERE', 'AND', 'OR', 'NOT', 'IN', 'IS', 'NULL',
            'INSERT', 'INTO', 'VALUES', 'UPDATE', 'SET', 'DELETE',
            'CREATE', 'ALTER', 'DROP', 'TABLE', 'VIEW', 'INDEX', 'DATABASE', 'SCHEMA',
            'JOIN', 'LEFT', 'RIGHT', 'INNER', 'OUTER', 'FULL', 'CROSS', 'ON',
            'GROUP', 'BY', 'ORDER', 'ASC', 'DESC', 'HAVING', 'LIMIT', 'OFFSET',
            'AS', 'DISTINCT', 'ALL', 'UNION', 'INTERSECT', 'EXCEPT',
            'CASE', 'WHEN', 'THEN', 'ELSE', 'END',
            'EXISTS', 'BETWEEN', 'LIKE', 'ILIKE',
            'REPLACE', 'GRANTS', 'COPY', 'WITH', 'RECURSIVE',
            'PRIMARY', 'KEY', 'FOREIGN', 'REFERENCES', 'CONSTRAINT',
            'TRUE', 'FALSE', 'DEFAULT', 'UNIQUE', 'CHECK'
          ]);
          
          // SQL functions
          const functions = new Set([
            'COUNT', 'SUM', 'AVG', 'MIN', 'MAX', 'COALESCE', 'NULLIF',
            'CAST', 'CONVERT', 'TRIM', 'UPPER', 'LOWER', 'LENGTH', 'SUBSTRING',
            'CONCAT', 'SPLIT', 'DATE', 'TIMESTAMP', 'DATEADD',
            'DATEDIFF', 'GETDATE', 'NOW', 'CURRENT_DATE', 'CURRENT_TIMESTAMP',
            'ROW_NUMBER', 'RANK', 'DENSE_RANK', 'LAG', 'LEAD', 'FIRST_VALUE',
            'LAST_VALUE', 'NVL', 'IFNULL', 'IFF', 'DECODE'
          ]);
          
          // Tokenize the SQL - split by word boundaries while preserving structure
          const tokens = [];
          const tokenRegex = /(\s+|[.,;()*=<>!]+|'[^']*'|--[^\n]*|\w+)/g;
          let match;
          let lastIndex = 0;
          
          while ((match = tokenRegex.exec(sql)) !== null) {
            // Add any skipped characters
            if (match.index > lastIndex) {
              tokens.push({ type: 'other', value: sql.slice(lastIndex, match.index) });
            }
            
            const value = match[1];
            const upperValue = value.toUpperCase();
            
            if (/^\s+$/.test(value)) {
              tokens.push({ type: 'whitespace', value });
            } else if (/^--/.test(value)) {
              tokens.push({ type: 'comment', value });
            } else if (/^'/.test(value)) {
              tokens.push({ type: 'string', value });
            } else if (/^\d+(\.\d+)?$/.test(value)) {
              tokens.push({ type: 'number', value });
            } else if (keywords.has(upperValue)) {
              tokens.push({ type: 'keyword', value });
            } else if (functions.has(upperValue)) {
              tokens.push({ type: 'function', value });
            } else if (/^[.,;()*=<>!]+$/.test(value)) {
              tokens.push({ type: 'operator', value });
            } else {
              tokens.push({ type: 'identifier', value });
            }
            
            lastIndex = tokenRegex.lastIndex;
          }
          
          // Add remaining text
          if (lastIndex < sql.length) {
            tokens.push({ type: 'other', value: sql.slice(lastIndex) });
          }
          
          // Build highlighted HTML
          return tokens.map(token => {
            const escaped = escapeHtml(token.value);
            switch (token.type) {
              case 'keyword':
                return `<span class="sql-keyword">${escaped}</span>`;
              case 'function':
                return `<span class="sql-function">${escaped}</span>`;
              case 'string':
                return `<span class="sql-string">${escaped}</span>`;
              case 'number':
                return `<span class="sql-number">${escaped}</span>`;
              case 'comment':
                return `<span class="sql-comment">${escaped}</span>`;
              case 'operator':
                return `<span class="sql-operator">${escaped}</span>`;
              default:
                return escaped;
            }
          }).join('');
        }

        // Global shared selection state (accessible by graph view)
        window.sharedSelection = {
          selectedItemId: null,
          selectedItemData: null,
          listeners: [],
          
          // Update selection from any view
          setSelection: function(itemId, itemData) {
            this.selectedItemId = itemId;
            this.selectedItemData = itemData;
            this.notifyListeners();
            this.updateSidePanel(itemData);
          },
          
          // Clear selection
          clearSelection: function() {
            this.selectedItemId = null;
            this.selectedItemData = null;
            this.notifyListeners();
            sidePanel.classList.add('hidden');
          },
          
          // Subscribe to selection changes
          addListener: function(callback) {
            this.listeners.push(callback);
          },
          
          // Notify all listeners of selection change
          notifyListeners: function() {
            this.listeners.forEach(cb => cb(this.selectedItemId, this.selectedItemData));
          },
          
          // Update side panel with item data
          updateSidePanel: function(itemData) {
            if (!itemData) return;
            
            // Show object view, hide other views
            panelObjectView.classList.remove('hidden');
            panelEdgeView.classList.add('hidden');
            panelColumnView.classList.add('hidden');
            
            // Header
            panelTitle.textContent = itemData.name || 'Unknown';
            panelIcon.src = itemData.icon || './img/ui/table.svg';
            
            // Path - show for Snowflake DB/Schema objects and external platform objects
            // Skip for External APIs and Exports
            // Note: schema property may be 'schemaName' or 'schema' depending on data source
            const schemaValue = itemData.schemaName || itemData.schema;
            if (itemData.database && schemaValue) {
              // Snowflake DB/Schema path: [snowflake icon] [db icon] DB_NAME / [schema icon] SCHEMA_NAME
              panelPath.innerHTML = `
                <img class="panel-header-path-icon" src="${itemData.sourceIcon || './img/logo-snowflake.svg'}" alt="Source">
                <img class="panel-header-path-icon" src="./img/ui/database.svg" alt="Database">
                <span class="panel-header-path-text">${itemData.database}</span>
                <span class="panel-header-path-separator">/</span>
                <img class="panel-header-path-icon" src="./img/ui/schema.svg" alt="Schema">
                <span class="panel-header-path-text">${schemaValue}</span>
              `;
              panelPath.classList.remove('hidden');
            } else if (itemData.platform && itemData.platform !== 'External APIs' && itemData.platform !== 'Exports') {
              // External platform path: [source icon] Source name / Object type
              const objTypeLabels = {
                'DASHBOARD': 'Dashboards',
                'MODEL': 'Models',
                'TABLE': 'Tables',
                'VIEW': 'Views',
                'DATASET': 'Datasets',
                'API': 'APIs',
                'EXTERNAL': 'External',
                'STAGE': 'Stages'
              };
              const objTypeLabel = objTypeLabels[itemData.objType] || itemData.objType || 'Objects';
              panelPath.innerHTML = `
                <img class="panel-header-path-icon" src="${itemData.platformIcon || './img/api.svg'}" alt="Platform">
                <span class="panel-header-path-text">${itemData.platform}</span>
                <span class="panel-header-path-separator">/</span>
                <span class="panel-header-path-text">${objTypeLabel}</span>
              `;
              panelPath.classList.remove('hidden');
            } else {
              // Hide path for External APIs and Exports
              panelPath.innerHTML = '';
              panelPath.classList.add('hidden');
            }
            
            // Comment/Description
            panelComment.textContent = itemData.description || itemData.comment || '';
            
            // Owner
            panelOwner.textContent = itemData.owner || '';
            
            // Created date
            panelCreated.textContent = itemData.createdAt || itemData.created || '';
            
            // Data quality
            panelQuality.textContent = itemData.dataQuality || '';
            
            // Count for details section - show primary data type count with dynamic label
            const columns = itemData.columns || [];
            const features = itemData.features || [];
            const outputs = itemData.outputs || [];
            
            // Determine label and count based on object type
            let countLabel = 'Columns';
            let primaryCount = columns.length;
            
            if (features.length > 0) {
              countLabel = 'Features';
              primaryCount = features.length;
            } else if (columns.length === 0 && outputs.length > 0) {
              countLabel = 'Outputs';
              primaryCount = outputs.length;
            }
            
            panelColumnCountLabel.textContent = countLabel;
            panelColumnCount.textContent = primaryCount > 0 ? primaryCount.toString() : '';
            
            // Tags
            if (itemData.tags && itemData.tags.length > 0) {
              panelTags.innerHTML = itemData.tags.map(tag => 
                `<span class="panel-tag">
                  <svg class="panel-tag-icon" viewBox="0 0 16 16" fill="none">
                    <path d="M2.5 3.5C2.5 2.94772 2.94772 2.5 3.5 2.5H7.08579C7.35097 2.5 7.60532 2.60536 7.79289 2.79289L13.2071 8.20711C13.5976 8.59763 13.5976 9.23077 13.2071 9.6213L9.6213 13.2071C9.23077 13.5976 8.59763 13.5976 8.20711 13.2071L2.79289 7.79289C2.60536 7.60532 2.5 7.35097 2.5 7.08579V3.5Z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
                    <circle cx="5.5" cy="5.5" r="1" fill="currentColor"/>
                  </svg>
                  <span class="panel-tag-value">${tag}</span>
                </span>`
              ).join('');
            } else {
              panelTags.textContent = '';
            }
            
            // Dynamic tab content based on object type
            const currentItemId = itemData.id;
            
            // Helper function to generate a list for tab content
            function generateListContent(items, searchPlaceholder, emptyMessage, isClickable = false) {
              if (!items || items.length === 0) {
                return `<div class="panel-column-empty">${emptyMessage}</div>`;
              }
              
              const itemsHtml = items.map(item => {
                const iconSrc = getPanelColumnIcon(item.type);
                const keyIcon = item.isPrimaryKey ? '<img src="img/ui/ownership.svg" class="panel-column-key" title="Primary Key">' :
                               item.isForeignKey ? '<img src="img/ui/format-link.svg" class="panel-column-key" title="Foreign Key">' : '';
                const importanceHtml = item.importance !== undefined ? 
                  `<span class="panel-column-importance" title="Feature importance">${(item.importance * 100).toFixed(0)}%</span>` : '';
                const clickableClass = isClickable ? 'panel-column-item-clickable' : '';
                const dataAttrs = isClickable ? `data-column-name="${item.name}" data-item-id="${currentItemId}"` : '';
                
                return `<div class="panel-column-item ${clickableClass}" ${dataAttrs}>
                  <img src="${iconSrc}" class="panel-column-icon" alt="${item.type || 'item'}">
                  <span class="panel-column-name">${item.name}</span>
                  ${keyIcon}
                  ${importanceHtml}
                </div>`;
              }).join('');
              
              return `
                <div class="panel-search">
                  <input type="text" placeholder="${searchPlaceholder}" class="panel-list-search" data-section="columns">
                </div>
                <div class="panel-column-list" data-section="columns">
                  ${itemsHtml}
                </div>
              `;
            }
            
            // Update tab label and content based on object type
            let tabLabel = 'Columns';
            let tabContent = '';
            
            if (features.length > 0 && outputs.length > 0) {
              // ML Model with both features and outputs - show both in subtabs
              tabLabel = `Features (${features.length})`;
              tabContent = `
                <div class="panel-subtabs" id="panelSubtabs">
                  <button class="panel-tab active" data-subtab="features">Features (${features.length})</button>
                  <button class="panel-tab" data-subtab="outputs">Outputs (${outputs.length})</button>
                </div>
                <div class="panel-subtab-content active" data-subtab-content="features">
                  ${generateListContent(features, 'Search features', 'No features', true)}
                </div>
                <div class="panel-subtab-content" data-subtab-content="outputs">
                  ${generateListContent(outputs, 'Search outputs', 'No outputs', true)}
                </div>
              `;
              panelColumnsTab.textContent = 'Features';
            } else if (features.length > 0) {
              tabLabel = `Features (${features.length})`;
              tabContent = generateListContent(features, 'Search features', 'No features', true);
              panelColumnsTab.textContent = `Features (${features.length})`;
            } else if (outputs.length > 0) {
              tabLabel = `Outputs (${outputs.length})`;
              tabContent = generateListContent(outputs, 'Search outputs', 'No outputs', true);
              panelColumnsTab.textContent = `Outputs (${outputs.length})`;
            } else if (columns.length > 0) {
              tabLabel = `Columns (${columns.length})`;
              tabContent = generateListContent(columns, 'Search columns', 'No columns', true);
              panelColumnsTab.textContent = `Columns (${columns.length})`;
            } else {
              tabContent = '<div class="panel-column-empty">No columns</div>';
              panelColumnsTab.textContent = 'Columns';
            }
            
            // Hide the Columns/Features tab (keeping content for potential future use)
            panelColumnsTab.classList.add('hidden');
            
            panelDynamicSections.innerHTML = tabContent;
            
            // Add click handlers to select column/feature in graph view
            panelDynamicSections.querySelectorAll('.panel-column-item-clickable').forEach(item => {
              item.addEventListener('click', function() {
                const columnName = this.dataset.columnName;
                const itemId = this.dataset.itemId;
                if (columnName && itemId && window.selectColumn) {
                  window.selectColumn(itemId, columnName);
                }
              });
            });
            
            // Setup search filtering for all list sections
            panelDynamicSections.querySelectorAll('.panel-list-search').forEach(searchInput => {
              searchInput.addEventListener('input', function() {
                const query = this.value.toLowerCase();
                // Find the closest list to this search input
                const container = this.closest('.panel-subtab-content') || panelDynamicSections;
                const list = container.querySelector('.panel-column-list');
                if (list) {
                  list.querySelectorAll('.panel-column-item').forEach(item => {
                    const name = item.querySelector('.panel-column-name')?.textContent.toLowerCase() || '';
                    item.style.display = name.includes(query) ? 'flex' : 'none';
                  });
                }
              });
            });
            
            // Setup subtab click handlers (for Features | Outputs)
            const subtabs = panelDynamicSections.querySelector('.panel-subtabs');
            if (subtabs) {
              subtabs.addEventListener('click', (e) => {
                const tab = e.target.closest('.panel-tab');
                if (!tab) return;
                
                const subtabId = tab.dataset.subtab;
                
                // Update active subtab
                subtabs.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update active subtab content
                panelDynamicSections.querySelectorAll('.panel-subtab-content').forEach(content => {
                  content.classList.toggle('active', content.dataset.subtabContent === subtabId);
                });
              });
            }
            
            // Populate upstream/downstream tabs for object lineage
            const itemMap = window.buildItemMap ? window.buildItemMap(window.mockLineageData) : new Map();
            const currentItemName = itemData.name?.toLowerCase().trim();
            // Note: currentItemId is already declared above
            
            // Get object leaf status for visual indicators
            const objectLeafStatus = window.objectLeafStatus || { hasUpstream: new Set(), hasDownstream: new Set() };
            
            // Helper to get leaf classes for an object
            const getObjectLeafClasses = (objId) => {
              const isLeafUpstream = !objectLeafStatus.hasUpstream?.has(objId);
              const isLeafDownstream = !objectLeafStatus.hasDownstream?.has(objId);
              return [
                isLeafUpstream ? 'leaf-upstream' : '',
                isLeafDownstream ? 'leaf-downstream' : ''
              ].filter(Boolean).join(' ');
            };
            
            // Recursive function to find all upstream objects
            function findAllUpstreamObjects(targetItemName, visited = new Set(), depth = 1) {
              const normalizedTarget = targetItemName.toLowerCase().trim();
              if (visited.has(normalizedTarget)) return []; // Prevent cycles
              visited.add(normalizedTarget);
              
              const directUpstream = [];
              itemMap.forEach((item, id) => {
                if (item.downstream && item.downstream.length > 0) {
                  item.downstream.forEach(downName => {
                    if (downName.toLowerCase().trim() === normalizedTarget) {
                      directUpstream.push({ ...item, depth });
                    }
                  });
                }
              });
              
              // Recursively find upstream of each direct upstream
              const allUpstream = [...directUpstream];
              directUpstream.forEach(upItem => {
                const deeperUpstream = findAllUpstreamObjects(upItem.name, visited, depth + 1);
                allUpstream.push(...deeperUpstream);
              });
              
              return allUpstream;
            }
            
            // Recursive function to find all downstream objects
            function findAllDownstreamObjects(sourceItemName, sourceDownstream, visited = new Set(), depth = 1) {
              const normalizedSource = sourceItemName.toLowerCase().trim();
              if (visited.has(normalizedSource)) return []; // Prevent cycles
              visited.add(normalizedSource);
              
              const directDownstream = [];
              if (sourceDownstream && sourceDownstream.length > 0) {
                sourceDownstream.forEach(downName => {
                  const normalizedName = downName.toLowerCase().trim();
                  itemMap.forEach((item, id) => {
                    if (item.name?.toLowerCase().trim() === normalizedName) {
                      directDownstream.push({ ...item, depth });
                    }
                  });
                });
              }
              
              // Recursively find downstream of each direct downstream
              const allDownstream = [...directDownstream];
              directDownstream.forEach(downItem => {
                const deeperDownstream = findAllDownstreamObjects(downItem.name, downItem.downstream, visited, depth + 1);
                allDownstream.push(...deeperDownstream);
              });
              
              return allDownstream;
            }
            
            // Find full upstream and downstream paths
            const upstreamObjects = findAllUpstreamObjects(itemData.name);
            const downstreamObjects = findAllDownstreamObjects(itemData.name, itemData.downstream);
            
            // Group objects by depth for display
            function groupByDepth(objects) {
              const depthMap = new Map();
              objects.forEach(obj => {
                if (!depthMap.has(obj.depth)) {
                  depthMap.set(obj.depth, []);
                }
                depthMap.get(obj.depth).push(obj);
              });
              return depthMap;
            }
            
            const upstreamByDepth = groupByDepth(upstreamObjects);
            const downstreamByDepth = groupByDepth(downstreamObjects);
            
            // Count unique objects
            const uniqueUpstream = new Set(upstreamObjects.map(o => o.id)).size;
            const uniqueDownstream = new Set(downstreamObjects.map(o => o.id)).size;
            
            // Update tab labels with counts
            if (panelUpstreamTab) {
              panelUpstreamTab.textContent = `Upstream (${uniqueUpstream})`;
            }
            if (panelDownstreamTab) {
              panelDownstreamTab.textContent = `Downstream (${uniqueDownstream})`;
            }
            
            // Helper function to render the current object as the root node with group header
            // Group header must be one of two formats:
            // 1. [snowflake icon][db icon] DB_NAME / [schema icon] SCHEMA_NAME
            // 2. [source platform icon] Source platform name
            function renderCurrentObjectNode(objData, isUpstream = false) {
              const objIcon = objData?.icon || './img/ui/table.svg';
              const objName = objData?.name || 'Unknown';
              const leafClasses = getObjectLeafClasses(objData?.id || currentItemId);
              const upstreamClass = isUpstream ? 'upstream-tree-group' : '';
              
              // Generate group header based on db/schema or platform
              // Note: schema may be 'schema' (from buildItemMap) or 'schemaName' (from original data)
              const schemaVal = objData?.schema || objData?.schemaName;
              let groupHeaderHtml = '';
              if (objData?.database && schemaVal) {
                // Format 1: Snowflake DB/Schema
                const sourceIcon = objData.sourceIcon || './img/logo-snowflake.svg';
                groupHeaderHtml = `
                  <div class="group-header panel-tree-current-header">
                    <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                    <img class="group-icon" src="${sourceIcon}" alt="">
                    <img class="group-icon" src="./img/ui/database.svg" alt="">
                    <span class="group-name">${objData.database}</span>
                    <span class="group-name-separator">/</span>
                    <img class="group-icon" src="./img/ui/schema.svg" alt="">
                    <span class="group-name">${schemaVal}</span>
                  </div>
                `;
              } else {
                // Format 2: Source platform
                const platformName = objData?.platform || 'External';
                const platformIcon = objData?.platformIcon || objData?.icon || './img/api.svg';
                groupHeaderHtml = `
                  <div class="group-header panel-tree-current-header">
                    <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                    <img class="group-icon" src="${platformIcon}" alt="">
                    <span class="group-name">${platformName}</span>
                  </div>
                `;
              }
              
              const objId = objData?.id || currentItemId;
              return `
                <div class="panel-tree-depth" data-depth="0">
                  <div class="object-group panel-tree-group panel-tree-current ${upstreamClass}">
                    ${groupHeaderHtml}
                    <ul class="group-list">
                      <li class="panel-tree-item panel-tree-item-current ${leafClasses}" data-item-id="${objId}">
                        <div class="object-info">
                          <img class="object-icon" src="${objIcon}" alt="">
                          <span class="object-name">${objName}</span>
                        </div>
                      </li>
                    </ul>
                  </div>
                </div>
              `;
            }
            
            // Helper function to get group key and header for an object
            // All groups must be one of two formats:
            // 1. [snowflake icon][db icon] DB_NAME / [schema icon] SCHEMA_NAME
            // 2. [source platform icon] Source platform name
            function getObjectGroupInfo(obj) {
              // Note: schema may be 'schema' (from buildItemMap) or 'schemaName' (from original data)
              const schemaVal = obj.schema || obj.schemaName;
              
              // Format 1: Snowflake DB/Schema object
              if (obj.database && schemaVal) {
                const groupKey = `db:${obj.database}/${schemaVal}`;
                const sourceIcon = obj.sourceIcon || './img/logo-snowflake.svg';
                const headerHtml = `
                  <img class="group-icon" src="${sourceIcon}" alt="">
                  <img class="group-icon" src="./img/ui/database.svg" alt="">
                  <span class="group-name">${obj.database}</span>
                  <span class="group-name-separator">/</span>
                  <img class="group-icon" src="./img/ui/schema.svg" alt="">
                  <span class="group-name">${schemaVal}</span>
                `;
                return { groupKey, headerHtml };
              }
              // Format 2: Source platform (external sources, dashboards, models, exports, etc.)
              else {
                // Determine platform name and icon
                const platformName = obj.platform || 'External';
                const platformIcon = obj.platformIcon || obj.icon || './img/api.svg';
                const groupKey = `platform:${platformName}`;
                const headerHtml = `
                  <img class="group-icon" src="${platformIcon}" alt="">
                  <span class="group-name">${platformName}</span>
                `;
                return { groupKey, headerHtml };
              }
            }
            
            // Helper function to render objects at a specific depth grouped by db/schema or platform
            function renderObjectDepthLevel(objects, depth, isUpstream = false) {
              // Group objects by database/schema or platform
              const groupedObjects = new Map();
              const groupHeaders = new Map();
              
              objects.forEach(obj => {
                const { groupKey, headerHtml } = getObjectGroupInfo(obj);
                if (!groupedObjects.has(groupKey)) {
                  groupedObjects.set(groupKey, []);
                  groupHeaders.set(groupKey, headerHtml);
                }
                groupedObjects.get(groupKey).push(obj);
              });
              
              // Render groups - add upstream-tree-group class for upstream groups
              const upstreamClass = isUpstream ? 'upstream-tree-group' : '';
              let groupsHtml = '';
              groupedObjects.forEach((objs, groupKey) => {
                const headerHtml = groupHeaders.get(groupKey);
                
                groupsHtml += `
                  <div class="object-group panel-tree-group ${upstreamClass}">
                    <div class="group-header">
                      <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                      ${headerHtml}
                    </div>
                    <ul class="group-list">
                      ${objs.map(obj => {
                        const objIcon = obj.icon || './img/ui/table.svg';
                        const objName = obj.name || 'Unknown';
                        const leafClasses = getObjectLeafClasses(obj.id);
                        return `
                          <li class="panel-tree-item ${leafClasses}" data-item-id="${obj.id}" title="Select object">
                            <div class="object-info">
                              <img class="object-icon" src="${objIcon}" alt="">
                              <span class="object-name">${objName}</span>
                            </div>
                          </li>
                        `;
                      }).join('')}
                    </ul>
                  </div>
                `;
              });
              
              return `
                <div class="panel-tree-depth" data-depth="${depth}">
                  ${groupsHtml}
                </div>
              `;
            }
            
            // Render full upstream tree by depth
            let upstreamHtml = renderCurrentObjectNode(itemData, true);
            if (upstreamByDepth.size > 0) {
              const sortedDepths = Array.from(upstreamByDepth.keys()).sort((a, b) => a - b);
              sortedDepths.forEach(depth => {
                upstreamHtml += renderObjectDepthLevel(upstreamByDepth.get(depth), depth, true);
              });
            } else {
              upstreamHtml += '<div class="panel-tree-empty">No upstream sources</div>';
            }
            panelUpstreamList.innerHTML = upstreamHtml;
            
            // Render full downstream tree by depth
            let downstreamHtml = renderCurrentObjectNode(itemData);
            if (downstreamByDepth.size > 0) {
              const sortedDepths = Array.from(downstreamByDepth.keys()).sort((a, b) => a - b);
              sortedDepths.forEach(depth => {
                downstreamHtml += renderObjectDepthLevel(downstreamByDepth.get(depth), depth);
              });
            } else {
              downstreamHtml += '<div class="panel-tree-empty">No downstream destinations</div>';
            }
            panelDownstreamList.innerHTML = downstreamHtml;
            
            // Add click handlers for upstream/downstream object items and group headers
            function setupObjectTreeClickHandlers(container) {
              // Setup group header collapse/expand
              container.querySelectorAll('.panel-tree-group .group-header').forEach(header => {
                header.addEventListener('click', function(e) {
                  e.stopPropagation();
                  const group = this.closest('.object-group');
                  if (group) {
                    group.classList.toggle('collapsed');
                  }
                });
              });
              
              // Setup object item click handlers - center on node without selecting
              container.querySelectorAll('.panel-tree-item').forEach(el => {
                el.addEventListener('click', function(e) {
                  e.stopPropagation();
                  const targetId = this.dataset.itemId;
                  const isCurrent = this.classList.contains('panel-tree-item-current');
                  
                  if (targetId) {
                    // Only apply focused style to non-current items
                    if (!isCurrent) {
                      // Remove focused class from any previously focused tree items
                      document.querySelectorAll('.panel-tree-item.focused').forEach(item => {
                        item.classList.remove('focused');
                      });
                      
                      // Add focused class to clicked item
                      this.classList.add('focused');
                      
                      // Auto-remove focused class after 2 seconds
                      const clickedEl = this;
                      setTimeout(() => {
                        clickedEl.classList.remove('focused');
                      }, 2000);
                    }
                    
                    // Center on the node in graph view without selecting
                    if (window.centerOnNode) {
                      window.centerOnNode(targetId);
                    }
                    // Also scroll in list view if visible
                    const listItem = document.querySelector(`.group-list li[data-id="${targetId}"]`);
                    if (listItem) {
                      scrollToItem(listItem, false); // false = don't select
                    }
                  }
                });
              });
            }
            
            setupObjectTreeClickHandlers(panelUpstreamList);
            setupObjectTreeClickHandlers(panelDownstreamList);
            
            // Reset to Details tab when new object is selected
            if (panelTabs) {
              panelTabs.querySelectorAll('.panel-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === 'details'));
              panelDetailsContent?.classList.add('active');
              panelDynamicSections?.classList.remove('active');
              panelUpstreamContent?.classList.remove('active');
              panelDownstreamContent?.classList.remove('active');
            }
            
            sidePanel.classList.remove('hidden');
          },
          
          // Update side panel with edge info (source -> target connection)
          updateEdgeSidePanel: function(sourceItem, targetItem, edgeData) {
            if (!sourceItem || !targetItem) return;
            
            // Show edge view, hide other views
            panelObjectView.classList.add('hidden');
            panelEdgeView.classList.remove('hidden');
            panelColumnView.classList.add('hidden');
            
            // Truncate names for title
            const sourceName = sourceItem.name || 'Source';
            const targetName = targetItem.name || 'Target';
            panelEdgeTitle.innerHTML = `${sourceName} <img src="./img/ui/arrow-right.svg" class="panel-title-arrow" alt="to"> ${targetName}`;
            
            // Edge details - use edgeData if available, otherwise defaults
            const data = edgeData || {};
            panelQueryType.textContent = data.queryType || '';
            panelRunBy.textContent = data.runBy || '';
            panelRunOn.textContent = data.runOn || data.createdAt || '';
            panelDuration.textContent = data.duration || '';
            panelQueryId.textContent = data.queryId || '';
            panelRowCount.textContent = data.rowCount ? data.rowCount.toLocaleString() : '';
            
            // External Tool display
            const externalToolRow = document.getElementById('panelExternalToolRow');
            const externalToolIcon = document.getElementById('panelExternalToolIcon');
            const externalToolName = document.getElementById('panelExternalToolName');
            if (data.externalTool && data.externalTool.name) {
              externalToolRow.style.display = 'flex';
              externalToolIcon.src = data.externalTool.icon || '';
              externalToolIcon.style.display = data.externalTool.icon ? 'inline' : 'none';
              externalToolName.textContent = data.externalTool.name;
            } else {
              externalToolRow.style.display = 'none';
            }
            
            // SQL Query with syntax highlighting
            let sqlCode = data.sqlQuery;
            if (!sqlCode) {
              // Generate a mock SQL query based on source/target
              sqlCode = `CREATE OR REPLACE VIEW
${targetItem.database || 'DATABASE'}.${targetItem.schemaName || 'SCHEMA'}.${targetItem.name || 'TARGET'}
COPY GRANTS AS SELECT * FROM
${sourceItem.database || 'DATABASE'}.${sourceItem.schemaName || 'SCHEMA'}.${sourceItem.name || 'SOURCE'};`;
            }
            panelSqlQuery.innerHTML = highlightSQL(sqlCode);
            
            // Stored Procedures tab content
            const procCount = data.storedProcedures?.length || 0;
            if (panelStoredProcsTab) {
              panelStoredProcsTab.textContent = `Procedures (${procCount})`;
            }
            if (data.storedProcedures && data.storedProcedures.length > 0) {
              panelStoredProcsContent.innerHTML = `
                <div class="panel-procedures-list panel-lineage-list">
                  ${data.storedProcedures.map(proc => `
                    <div class="panel-procedure-item panel-lineage-item">
                      <div class="panel-lineage-column-header">
                        <span class="panel-lineage-column-name">
                          ${proc.name}
                        </span>
                        <a class="panel-lineage-goto" href="#" title="Open in Horizon Catalog">
                          <img src="./img/ui/goto.svg" width="16" height="16" alt="Go to">
                        </a>
                        <span class="panel-lineage-item-name">${proc.schema}</span>
                      </div>
                      <div class="panel-lineage-column-info">
                        ${proc.status ? `<span class="panel-lineage-transform panel-task-status ${proc.status}">${proc.status}</span>` : ''}
                        <span class="panel-lineage-item-meta">Last run: ${proc.lastModified}</span>
                      </div>
                    </div>
                  `).join('')}
                </div>
              `;
            } else {
              panelStoredProcsContent.innerHTML = '<div class="panel-empty-state">No stored procedures</div>';
            }
            
            // Tasks tab content
            const taskCount = data.tasks?.length || 0;
            if (panelTasksTab) {
              panelTasksTab.textContent = `Tasks (${taskCount})`;
            }
            if (data.tasks && data.tasks.length > 0) {
              panelTasksContent.innerHTML = `
                <div class="panel-tasks-list panel-lineage-list">
                  ${data.tasks.map(task => `
                    <div class="panel-task-item panel-lineage-item">
                      <div class="panel-lineage-column-header">
                        <span class="panel-lineage-column-name">
                          ${task.name}
                        </span>
                        <a class="panel-lineage-goto" href="#" title="Open in Horizon Catalog">
                          <img src="./img/ui/goto.svg" width="16" height="16" alt="Go to">
                        </a>
                        <span class="panel-lineage-item-name">${task.type}</span>
                      </div>
                      <div class="panel-lineage-column-info">
                        <span class="panel-lineage-transform panel-task-status ${task.status}">${task.status}</span>
                        <span class="panel-lineage-item-meta">Schedule: ${task.schedule}</span>
                      </div>
                    </div>
                  `).join('')}
                </div>
              `;
            } else {
              panelTasksContent.innerHTML = '<div class="panel-empty-state">No tasks</div>';
            }
            
            // Reset to Details tab
            if (panelEdgeTabs) {
              panelEdgeTabs.querySelectorAll('.panel-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === 'details'));
              const panelContent = panelEdgeView.querySelector('.panel-content');
              panelContent?.querySelectorAll('.panel-tab-content').forEach(content => {
                content.classList.toggle('active', content.dataset.tabContent === 'details');
              });
            }
            
            sidePanel.classList.remove('hidden');
          },
          
          // Update side panel with column details
          updateColumnSidePanel: function(columnData, parentItem) {
            if (!columnData) return;
            
            // Show column view, hide other views
            panelObjectView.classList.add('hidden');
            panelEdgeView.classList.add('hidden');
            panelColumnView.classList.remove('hidden');
            
            // Header
            panelColumnTitle.textContent = columnData.name || 'Unknown Column';
            panelColumnTypeIcon.src = getPanelColumnIcon(columnData.type);
            
            // Path - show parent object
            if (parentItem) {
              panelColumnPath.innerHTML = `
                <img class="panel-header-path-icon" src="${parentItem.icon || './img/ui/table.svg'}" alt="Parent">
                <span class="panel-header-path-text">${parentItem.name || 'Unknown'}</span>
              `;
            } else {
              panelColumnPath.innerHTML = '';
            }
            
            // Description
            panelColumnDescription.textContent = columnData.description || '';
            
            // Data Type
            panelColumnType.textContent = columnData.type || '';
            
            // Parent Object
            panelColumnParent.textContent = parentItem?.name || '';
            
            // Key Type
            if (columnData.isPrimaryKey || columnData.isForeignKey) {
              panelColumnKeyRow.style.display = 'flex';
              if (columnData.isPrimaryKey && columnData.isForeignKey) {
                panelColumnKeyType.textContent = 'Primary Key, Foreign Key';
              } else if (columnData.isPrimaryKey) {
                panelColumnKeyType.textContent = 'Primary Key';
              } else {
                panelColumnKeyType.textContent = 'Foreign Key';
              }
            } else {
              panelColumnKeyRow.style.display = 'none';
            }
            
            // Get upstream and downstream lineage
            const lineage = window.columnLineage || [];
            const itemId = parentItem?.id;
            const columnName = columnData.name;
            
            // Get item map for looking up names
            const itemMap = window.buildItemMap ? window.buildItemMap(window.mockLineageData) : new Map();
            
            // Get column leaf status for visual indicators
            const columnLeafStatus = window.columnLeafStatus || { hasUpstream: new Map(), hasDownstream: new Map() };
            
            // Helper to get leaf classes for a column
            const getLeafClasses = (colItemId, colName) => {
              const isLeafUpstream = !columnLeafStatus.hasUpstream?.has(colItemId) || 
                                     !columnLeafStatus.hasUpstream.get(colItemId).has(colName);
              const isLeafDownstream = !columnLeafStatus.hasDownstream?.has(colItemId) || 
                                       !columnLeafStatus.hasDownstream.get(colItemId).has(colName);
              return [
                isLeafUpstream ? 'leaf-upstream' : '',
                isLeafDownstream ? 'leaf-downstream' : ''
              ].filter(Boolean).join(' ');
            };
            
            // Recursive function to find all upstream columns (full path to leaf nodes)
            function findAllUpstream(targetItemId, targetColumnName, visited = new Set(), depth = 1) {
              const key = `${targetItemId}:${targetColumnName}`;
              if (visited.has(key)) return []; // Prevent cycles
              visited.add(key);
              
              const directUpstream = lineage
                .filter(edge => edge.targetTable === targetItemId && edge.targetColumn === targetColumnName)
                .map(edge => ({
                  itemId: edge.sourceTable,
                  columnName: edge.sourceColumn,
                  transformType: edge.transformType,
                  depth: depth
                }));
              
              // Recursively find upstream of each direct upstream
              const allUpstream = [...directUpstream];
              directUpstream.forEach(col => {
                const deeperUpstream = findAllUpstream(col.itemId, col.columnName, visited, depth + 1);
                allUpstream.push(...deeperUpstream);
              });
              
              return allUpstream;
            }
            
            // Recursive function to find all downstream columns (full path to leaf nodes)
            function findAllDownstream(sourceItemId, sourceColumnName, visited = new Set(), depth = 1) {
              const key = `${sourceItemId}:${sourceColumnName}`;
              if (visited.has(key)) return []; // Prevent cycles
              visited.add(key);
              
              const directDownstream = lineage
                .filter(edge => edge.sourceTable === sourceItemId && edge.sourceColumn === sourceColumnName)
                .map(edge => ({
                  itemId: edge.targetTable,
                  columnName: edge.targetColumn,
                  transformType: edge.transformType,
                  depth: depth
                }));
              
              // Recursively find downstream of each direct downstream
              const allDownstream = [...directDownstream];
              directDownstream.forEach(col => {
                const deeperDownstream = findAllDownstream(col.itemId, col.columnName, visited, depth + 1);
                allDownstream.push(...deeperDownstream);
              });
              
              return allDownstream;
            }
            
            // Find full upstream and downstream paths
            const upstreamColumns = findAllUpstream(itemId, columnName);
            const downstreamColumns = findAllDownstream(itemId, columnName);
            
            // Group columns by depth for display
            function groupByDepth(columns) {
              const depthMap = new Map();
              columns.forEach(col => {
                if (!depthMap.has(col.depth)) {
                  depthMap.set(col.depth, []);
                }
                depthMap.get(col.depth).push(col);
              });
              return depthMap;
            }
            
            const upstreamByDepth = groupByDepth(upstreamColumns);
            const downstreamByDepth = groupByDepth(downstreamColumns);
            
            // Count unique columns
            const uniqueUpstream = new Set(upstreamColumns.map(c => `${c.itemId}:${c.columnName}`)).size;
            const uniqueDownstream = new Set(downstreamColumns.map(c => `${c.itemId}:${c.columnName}`)).size;
            
            // Update tab labels with counts
            if (panelColumnUpstreamTab) {
              panelColumnUpstreamTab.textContent = `Upstream (${uniqueUpstream})`;
            }
            if (panelColumnDownstreamTab) {
              panelColumnDownstreamTab.textContent = `Downstream (${uniqueDownstream})`;
            }
            
            // Helper function to render the current column as the root node
            function renderCurrentColumnNode(colData, parent, isUpstream = false) {
              const colType = colData?.type || 'STRING';
              const typeIcon = window.getColumnTypeIcon ? window.getColumnTypeIcon(colType) : 'img/ui/column-single.svg';
              const parentIcon = parent?.icon || './img/ui/table.svg';
              const parentName = parent?.name || 'Unknown';
              const parentId = parent?.id || itemId;
              const leafClasses = getLeafClasses(parentId, colData?.name || columnName);
              const upstreamClass = isUpstream ? 'upstream-tree-group' : '';
              
              return `
                <div class="panel-tree-depth" data-depth="0">
                  <div class="object-group panel-tree-group panel-tree-current ${upstreamClass}">
                    <div class="group-header panel-tree-current-header">
                      <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                      <img class="group-icon" src="${parentIcon}" alt="">
                      <span class="group-name">${parentName}</span>
                    </div>
                    <ul class="group-list">
                      <li class="panel-tree-item panel-tree-item-current ${leafClasses}" data-item-id="${parentId}">
                        <div class="object-info">
                          <img class="object-icon" src="${typeIcon}" alt="${colType}">
                          <span class="object-name">${colData?.name || columnName}</span>
                        </div>
                      </li>
                    </ul>
                  </div>
                </div>
              `;
            }
            
            // Helper function to render columns at a specific depth grouped by parent object
            function renderDepthLevel(columns, depth, isUpstream = false) {
              // Group columns by parent object (itemId)
              const groupedByItem = new Map();
              columns.forEach(col => {
                if (!groupedByItem.has(col.itemId)) {
                  groupedByItem.set(col.itemId, []);
                }
                groupedByItem.get(col.itemId).push(col);
              });
              
              // Render groups - add upstream-tree-group class for upstream groups
              const upstreamClass = isUpstream ? 'upstream-tree-group' : '';
              let groupsHtml = '';
              groupedByItem.forEach((cols, colItemId) => {
                const item = itemMap.get(colItemId);
                const itemName = item?.name || colItemId;
                const itemIcon = item?.icon || './img/ui/table.svg';
                const columnCount = cols.length;
                
                groupsHtml += `
                  <div class="object-group panel-tree-group ${upstreamClass}">
                    <div class="group-header">
                      <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                      <img class="group-icon" src="${itemIcon}" alt="">
                      <span class="group-name">${itemName}</span>
                    </div>
                    <ul class="group-list">
                      ${cols.map(col => {
                        const columnDef = item?.columns?.find(c => c.name === col.columnName) ||
                                          item?.features?.find(c => c.name === col.columnName) ||
                                          item?.outputs?.find(c => c.name === col.columnName);
                        const columnType = columnDef?.type || 'STRING';
                        const typeIcon = window.getColumnTypeIcon ? window.getColumnTypeIcon(columnType) : 'img/ui/column-single.svg';
                        const leafClasses = getLeafClasses(col.itemId, col.columnName);
                        return `
                          <li class="panel-tree-item ${leafClasses}" data-item-id="${col.itemId}" data-column-name="${col.columnName}" title="Select column">
                            <div class="object-info">
                              <img class="object-icon" src="${typeIcon}" alt="${columnType}">
                              <span class="object-name">${col.columnName}</span>
                            </div>
                          </li>
                        `;
                      }).join('')}
                    </ul>
                  </div>
                `;
              });
              
              return `
                <div class="panel-tree-depth" data-depth="${depth}">
                  ${groupsHtml}
                </div>
              `;
            }
            
            // Render full upstream tree by depth
            let upstreamHtml = renderCurrentColumnNode(columnData, parentItem, true);
            if (upstreamByDepth.size > 0) {
              // Sort depths and render each level
              const sortedDepths = Array.from(upstreamByDepth.keys()).sort((a, b) => a - b);
              sortedDepths.forEach(depth => {
                upstreamHtml += renderDepthLevel(upstreamByDepth.get(depth), depth, true);
              });
            } else {
              upstreamHtml += '<div class="panel-tree-empty">No upstream sources</div>';
            }
            panelColumnUpstreamList.innerHTML = upstreamHtml;
            
            // Render full downstream tree by depth
            let downstreamHtml = renderCurrentColumnNode(columnData, parentItem);
            if (downstreamByDepth.size > 0) {
              // Sort depths and render each level
              const sortedDepths = Array.from(downstreamByDepth.keys()).sort((a, b) => a - b);
              sortedDepths.forEach(depth => {
                downstreamHtml += renderDepthLevel(downstreamByDepth.get(depth), depth);
              });
            } else {
              downstreamHtml += '<div class="panel-tree-empty">No downstream targets</div>';
            }
            panelColumnDownstreamList.innerHTML = downstreamHtml;
            
            // Reset to Details tab
            if (panelColumnTabs) {
              panelColumnTabs.querySelectorAll('.panel-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === 'details'));
              panelColumnDetailsContent?.classList.add('active');
              panelColumnUpstreamContent?.classList.remove('active');
              panelColumnDownstreamContent?.classList.remove('active');
            }
            
            sidePanel.classList.remove('hidden');
            
            // Setup group header click handlers for collapse/expand
            panelColumnView.querySelectorAll('.panel-tree-group .group-header').forEach(header => {
              header.addEventListener('click', function(e) {
                e.stopPropagation();
                const group = this.closest('.object-group');
                group.classList.toggle('collapsed');
              });
            });
            
            // Setup click handlers for tree items - center on node without selecting
            panelColumnView.querySelectorAll('.panel-tree-item').forEach(item => {
              item.addEventListener('click', function(e) {
                e.stopPropagation();
                
                const targetItemId = this.dataset.itemId;
                if (!targetItemId) return;
                
                const isCurrent = this.classList.contains('panel-tree-item-current');
                
                // Only apply focused style to non-current items
                if (!isCurrent) {
                  // Remove focused class from any previously focused tree items
                  document.querySelectorAll('.panel-tree-item.focused').forEach(el => {
                    el.classList.remove('focused');
                  });
                  
                  // Add focused class to clicked item
                  this.classList.add('focused');
                  
                  // Auto-remove focused class after 2 seconds
                  const clickedEl = this;
                  setTimeout(() => {
                    clickedEl.classList.remove('focused');
                  }, 2000);
                }
                
                // Center on the parent node in graph view without selecting
                if (window.centerOnNode) {
                  window.centerOnNode(targetItemId);
                }
              });
            });
          }
        };

        // Helper: Find full item data from mockLineageData by name
        function findItemDataByName(name) {
          if (!window.mockLineageData) return null;
          const normalizedName = name.toLowerCase().trim();
          
          for (const depth of window.mockLineageData.depths) {
            for (const group of depth.groups) {
              // Some groups have items directly (platform groups)
              if (group.items) {
                for (const item of group.items) {
                  if (item.name.toLowerCase().trim() === normalizedName) {
                    // Enrich with platform info
                    return {
                      ...item,
                      platform: group.name,
                      platformIcon: group.icon
                    };
                  }
                }
              }
              // Database groups have schemas which contain items
              if (group.schemas) {
                for (const schema of group.schemas) {
                  if (schema.items) {
                    for (const item of schema.items) {
                      if (item.name.toLowerCase().trim() === normalizedName) {
                        // Enrich with database and schema info
                        return {
                          ...item,
                          database: group.database,
                          schemaName: schema.name,
                          sourceIcon: group.icon
                        };
                      }
                    }
                  }
                }
              }
            }
          }
          return null;
        }

        // Function to select an item in list view and sync globally
        function selectItem(item) {
          // Deselect previous in list
          if (selectedListItem) {
            selectedListItem.classList.remove('selected');
          }
          
          // Select new
          selectedListItem = item;
          item.classList.add('selected');
          
          // Get object info from DOM
          const objectName = item.querySelector('.object-name')?.textContent || 'Unknown';
          const objectIcon = item.querySelector('.object-icon')?.src || './img/ui/table.svg';
          const groupName = item.closest('.object-group')?.querySelector('.group-name')?.textContent || '-';
          
          // Try to find full item data from mockLineageData
          const fullItemData = findItemDataByName(objectName);
          
          if (fullItemData) {
            // Use full item data (same as graph view)
            window.sharedSelection.setSelection(fullItemData.id, {
              id: fullItemData.id,
              name: fullItemData.name,
              icon: fullItemData.icon || objectIcon,
              database: fullItemData.database,
              schemaName: fullItemData.schemaName,
              schema: fullItemData.schema || groupName,
              platform: fullItemData.platform,
              sourceIcon: fullItemData.sourceIcon,
              platformIcon: fullItemData.platformIcon,
              objType: fullItemData.objType,
              columns: fullItemData.columns,
              features: fullItemData.features,
              outputs: fullItemData.outputs,
              description: fullItemData.description,
              comment: fullItemData.comment,
              owner: fullItemData.owner,
              createdAt: fullItemData.createdAt,
              created: fullItemData.created,
              dataQuality: fullItemData.dataQuality,
              rowCount: fullItemData.rowCount,
              tags: fullItemData.tags
            });
          } else {
            // Fallback to minimal data from DOM
            const itemId = objectName.toLowerCase().replace(/\s+/g, '_');
            window.sharedSelection.setSelection(itemId, {
              id: itemId,
              name: objectName,
              icon: objectIcon,
              schema: groupName
            });
          }
        }

        // Listen for selection changes from graph view
        window.sharedSelection.addListener((itemId, itemData) => {
          // Update list view selection
          if (selectedListItem) {
            selectedListItem.classList.remove('selected');
            selectedListItem = null;
          }
          
          if (itemId && itemData) {
            // Find and highlight matching item in list view
            const matchName = itemData.name?.toUpperCase();
            allItems.forEach(item => {
              const nameEl = item.querySelector('.object-name');
              if (nameEl && nameEl.textContent.trim().toUpperCase() === matchName) {
                item.classList.add('selected');
                selectedListItem = item;
              }
            });
          }
        });

        // Click to select object in list view
        allItems.forEach(item => {
          item.style.cursor = 'pointer';
          item.addEventListener('click', (e) => {
            // Don't select if clicking on connection tag
            if (e.target.classList.contains('connection-tag')) return;
            
            selectItem(item);
          });
        });

        // Listen for selection changes from graph view to update list view
        window.sharedSelection.addListener((itemId, itemData) => {
          if (!itemId) {
            // Clear selection in list view
            if (selectedListItem) {
              selectedListItem.classList.remove('selected');
              selectedListItem = null;
            }
            return;
          }
          
          // Find and select the item in the list view
          const listItems = document.querySelectorAll('.group-list li');
          listItems.forEach(li => {
            const nameSpan = li.querySelector('.object-name');
            if (nameSpan && itemData && nameSpan.textContent.toLowerCase() === itemData.name?.toLowerCase()) {
              // Deselect previous
              if (selectedListItem) {
                selectedListItem.classList.remove('selected');
              }
              // Select new
              li.classList.add('selected');
              selectedListItem = li;
              
              // Scroll to the selected item if list view is visible
              const lineageScroll = document.querySelector('.lineage-scroll');
              if (lineageScroll && lineageScroll.style.display !== 'none') {
                scrollToItem(li, false);
              }
            }
          });
        });

        // Close panel
        panelClose.addEventListener('click', () => {
          window.sharedSelection.clearSelection();
          if (selectedListItem) {
            selectedListItem.classList.remove('selected');
            selectedListItem = null;
          }
          updateStickyHeaders();
        });

        // Segmented button toggle (Graph/List)
        const toggleBtns = document.querySelectorAll('.view-toggle .toggle-btn');
        const viewPanel = document.querySelector('.view-panel');
        const lineageScroll = document.querySelector('.lineage-scroll');
        const lineageGraph = document.querySelector('.lineage-graph');
        const toolBar = document.querySelector('.tool-bar');
        
        toggleBtns.forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Remove active from all
            toggleBtns.forEach(b => b.classList.remove('active'));
            // Add active to clicked
            btn.classList.add('active');
            
            // Toggle views based on button text
            const isGraphView = btn.textContent.trim() === 'Graph';
            
            // Get view-specific buttons
            const collapseExpandBtn = document.getElementById('collapse-expand-all');
            const maximizeBtn = document.getElementById('maximize-btn');
            
            if (isGraphView) {
              viewPanel.classList.add('graph-mode');
              lineageScroll.style.display = 'none';
              lineageGraph.style.display = 'block';
              
              // Show graph-view buttons, hide list-view buttons
              if (collapseExpandBtn) collapseExpandBtn.style.display = 'none';
              if (maximizeBtn) maximizeBtn.style.display = '';
              
              // Center on selected node when switching to graph view
              setTimeout(() => {
                if (window.centerOnSelectedNode) {
                  window.centerOnSelectedNode();
                }
              }, 100);
            } else {
              viewPanel.classList.remove('graph-mode');
              lineageScroll.style.display = 'block';
              lineageGraph.style.display = 'none';
              
              // Show list-view buttons, hide graph-view buttons
              if (collapseExpandBtn) collapseExpandBtn.style.display = '';
              if (maximizeBtn) maximizeBtn.style.display = 'none';
              
              // Recalculate natural positions after list view is visible
              // This is needed because positions are 0 when list is hidden
              setTimeout(() => {
                recalculateNaturalPositions();
                updateStickyHeaders();
                
                // Center on selected/focal item when switching to list view
                if (window.centerListOnSelected) {
                  window.centerListOnSelected();
                }
              }, 50);
            }
          });
        });
      });
    </script>

    <div class="main-layout">

      <div class="view-panel graph-mode">

        <div class="tool-bar">
          <div class="toolbar-left">
            <div class="view-toggle">
              <button class="toggle-btn active">Graph</button>
              <button class="toggle-btn">List</button>
            </div>
            <button class="toolbar-btn">
              <img src="./img/ui/filter.svg" alt="" width="16" height="16">
              Filter
            </button>
          </div>
          <div class="toolbar-right">
            <button class="toolbar-btn icon-only list-view-only" id="collapse-expand-all" title="Collapse all groups" style="display: none;">
              <img src="./img/chevrons-collapse.svg" alt="Collapse all" width="16" height="16">
            </button>
            <button class="toolbar-btn icon-only graph-view-only" id="graph-collapse-expand-all" title="Collapse all groups">
              <img src="./img/chevrons-collapse.svg" alt="Collapse all" width="16" height="16">
            </button>
            <button class="toolbar-btn icon-only graph-view-only" id="maximize-btn" title="Maximize">
              <img src="./img/maximize.svg" alt="Maximize" width="16" height="16">
            </button>
            <button class="toolbar-btn dropdown">
              <img src="./img/circle.svg" alt="" width="8" height="8">
              ORGADMIN
              <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 5l3 3 3-3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
          </div>
        </div>

        <div class="lineage-scroll" style="display: none;">
          <section class="lineage-table" aria-label="Lineage list">
            <!-- Upstream Level 3 (furthest) - Row 1 -->
            <div class="depth-header" data-row="1" data-order="0">
              <span class="depth-badge depth-badge--upstream">Upstream 3</span>
              
            </div>
            <div class="depth-content" data-row="1">
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/ui/api.svg" alt="API">
                  <span class="group-name">External APIs</span>
                  <span class="group-count">6</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="API">
                      <span class="object-name">Shopify Orders API</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">orders</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="API">
                      <span class="object-name">Stripe Payments API</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">payments</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="API">
                      <span class="object-name">Salesforce CRM</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">customers</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="API">
                      <span class="object-name">Google Analytics 4</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">ga_sessions</span>
                      <span class="connection-tag">ga_events</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="API">
                      <span class="object-name">Facebook Ads API</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">ad_spend</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="API">
                      <span class="object-name">Mixpanel Events</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">product_events</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
      
            <!-- Upstream Level 2 - Row 2 -->
            <div class="depth-header" data-row="2" data-order="1">
              <span class="depth-badge depth-badge--upstream">Upstream 2</span>
              
            </div>
            <div class="depth-content" data-row="2">
              <!-- Snowflake: RAW_ECOMMERCE -->
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-snowflake.svg" alt="Snowflake">
                  <span class="group-name"><!--ACME_PROD /--> RAW_DB / RAW_ECOMMERCE</span>
                  <span class="group-count">3</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">orders</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_orders</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">payments</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_payments</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">customers</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_customers</span>
                      <span class="connection-tag">stg_orders</span>
                    </div>
                  </li>
                </ul>
              </div>
      
              <!-- Snowflake: RAW_MARKETING -->
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-snowflake.svg" alt="Snowflake">
                  <span class="group-name"><!--ACME_PROD /--> RAW_DB / RAW_MARKETING</span>
                  <span class="group-count">4</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">ga_sessions</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_sessions</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">ga_events</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_web_events</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">ad_spend</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_ad_spend</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">product_events</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_web_events</span>
                      <span class="connection-tag">stg_sessions</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
      
            <!-- Upstream Level 1 - Row 3 -->
            <div class="depth-header" data-row="3" data-order="2">
              <span class="depth-badge depth-badge--upstream">Upstream 1</span>
              
            </div>
            <div class="depth-content" data-row="3">
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-snowflake.svg" alt="Snowflake">
                  <span class="group-name"><!--ACME_PROD /--> TRANSFORM_DB / STAGING</span>
                  <span class="group-count">6</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/view.svg" alt="View">
                      <span class="object-name">stg_orders</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--blue">orders</span>
                      <span class="connection-tag tag--blue">customers</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/view.svg" alt="View">
                      <span class="object-name">stg_payments</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--blue">payments</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/view.svg" alt="View">
                      <span class="object-name">stg_customers</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--blue">customers</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/view.svg" alt="View">
                      <span class="object-name">stg_sessions</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--green">ga_sessions</span>
                      <span class="connection-tag tag--green">product_events</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/view.svg" alt="View">
                      <span class="object-name">stg_web_events</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--green">ga_events</span>
                      <span class="connection-tag tag--green">product_events</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/view.svg" alt="View">
                      <span class="object-name">stg_ad_spend</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--green">ad_spend</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
      
            <!-- Focal object - Row 4 -->
            <div class="depth-header depth-header--focal" data-row="4" data-order="3">
              <span class="depth-badge depth-badge--focal">Currently viewing</span>
              
            </div>
            <div class="depth-content depth-content--focal" data-row="4">
              <div class="object-group">
                <div class="group-header group-header--focal">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-snowflake.svg" alt="Snowflake">
                  <span class="group-name"><!--ACME_ANALYTICS /--> ANALYTICS_DB / ANALYTICS</span>
                  <span class="group-count">1</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/dataset.svg" alt="Dataset">
                      <span class="object-name">fct_customer_orders</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--gray">stg_orders</span>
                      <span class="connection-tag tag--gray">stg_payments</span>
                      <span class="connection-tag tag--gray">stg_customers</span>
                      <span class="connection-tag tag--gray">stg_sessions</span>
                      <span class="connection-tag tag--gray">stg_web_events</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
      
            <!-- Downstream Level 1 - Row 5 -->
            <div class="depth-header" data-row="5" data-order="4">
              <span class="depth-badge depth-badge--downstream">Downstream +1</span>
              
            </div>
            <div class="depth-content" data-row="5">
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-snowflake.svg" alt="Snowflake">
                  <span class="group-name"><!--ACME_ANALYTICS /--> ANALYTICS_DB / MARTS</span>
                  <span class="group-count">4</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">dim_customers</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">Customer 360</span>
                      <span class="connection-tag">churn_model</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">fct_daily_revenue</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">Exec Dashboard</span>
                      <span class="connection-tag">Finance Report</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">fct_attribution</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">Marketing ROI</span>
                      <span class="connection-tag">attribution_model</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">user_journey_agg</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">Product Analytics</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
      
            <!-- Downstream Level 2 - Row 6 -->
            <div class="depth-header" data-row="6" data-order="5">
              <span class="depth-badge depth-badge--downstream">Downstream +2</span>
              
            </div>
            <div class="depth-content" data-row="6">
              <!-- Tableau -->
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-tableau.svg" alt="Tableau">
                  <span class="group-name">Tableau</span>
                  <span class="group-count">1</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/dashboards.svg" alt="Dashboard">
                      <span class="object-name">Exec Revenue Dashboard</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--purple">fct_daily_revenue</span>
                    </div>
                  </li>
                </ul>
              </div>
      
              <!-- Looker -->
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-looker.svg" alt="Looker">
                  <span class="group-name">Looker</span>
                  <span class="group-count">2</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/dashboards.svg" alt="Dashboard">
                      <span class="object-name">Customer 360 Dashboard</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--purple">dim_customers</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/dashboards.svg" alt="Dashboard">
                      <span class="object-name">Marketing ROI Dashboard</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--purple">fct_attribution</span>
                    </div>
                  </li>
                </ul>
              </div>
      
              <!-- ML Models -->
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/ui/machine-learning-model.svg" alt="Model">
                  <span class="group-name">ML Models</span>
                  <span class="group-count">2</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/machine-learning-model.svg" alt="Model">
                      <span class="object-name">churn_prediction_model</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--purple">dim_customers</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/machine-learning-model.svg" alt="Model">
                      <span class="object-name">attribution_model</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--purple">fct_attribution</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
      
            <!-- Downstream Level 3 - Row 7 -->
            <div class="depth-header" data-row="7" data-order="6">
              <span class="depth-badge depth-badge--downstream">Downstream +3</span>
              
            </div>
            <div class="depth-content" data-row="7">
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/ui/api.svg" alt="Export">
                  <span class="group-name">Exports</span>
                  <span class="group-count">2</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="Email">
                      <span class="object-name">Finance Weekly Report</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag">Exec Dashboard</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="Export">
                      <span class="object-name">Investor Data Room</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag">Exec Dashboard</span>
                      <span class="connection-tag">Customer 360</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
          </section>    
        </div>

        <div class="lineage-graph" id="lineage-graph-container" style="display: block;">
        </div>
      
      </div>

    <!-- Side Panel -->
    <aside class="side-panel hidden" id="sidePanel">
      <!-- Object Panel View -->
      <div class="panel-view panel-object-view" id="panelObjectView">
        <div class="panel-header">
          <div class="panel-header-main">
            <div class="panel-header-path hidden" id="panelPath">
              <!-- Path will be populated dynamically -->
            </div>
            <div class="panel-header-title-row">
              <img class="panel-header-icon" id="panelIcon" src="./img/ui/table.svg" alt="">
              <span class="panel-header-title" id="panelTitle">Object Name</span>
            </div>
          </div>
          <div class="panel-header-actions">
            <button class="panel-close" id="panelClose" aria-label="Close panel">
              <img src="./img/ui/clear.svg" width="16" height="16" alt="Close">
            </button>
          </div>
        </div>
        <!-- Tab Bar -->
        <div class="panel-tabs" id="panelTabs">
          <button class="panel-tab active" data-tab="details">Details</button>
          <button class="panel-tab" data-tab="columns" id="panelColumnsTab">Columns</button>
          <button class="panel-tab" data-tab="upstream" id="panelUpstreamTab">Upstream (0)</button>
          <button class="panel-tab" data-tab="downstream" id="panelDownstreamTab">Downstream (0)</button>
        </div>
        
        <div class="panel-content">
          <!-- Details Tab Content -->
          <div class="panel-tab-content active" data-tab-content="details" id="panelDetailsContent">
            <div class="panel-details-grid">
              <div class="panel-detail-row">
                <span class="panel-detail-label">Comment</span>
                <span class="panel-detail-value" id="panelComment"></span>
              </div>
              <div class="panel-detail-row">
                <span class="panel-detail-label">Owner</span>
                <span class="panel-detail-value" id="panelOwner"></span>
              </div>
              <div class="panel-detail-row">
                <span class="panel-detail-label">Created</span>
                <span class="panel-detail-value" id="panelCreated"></span>
              </div>
              <div class="panel-detail-row">
                <span class="panel-detail-label">Data Quality</span>
                <span class="panel-detail-value" id="panelQuality"></span>
              </div>
              <div class="panel-detail-row" id="panelColumnCountRow">
                <span class="panel-detail-label" id="panelColumnCountLabel">Columns</span>
                <span class="panel-detail-value" id="panelColumnCount"></span>
              </div>
              <div class="panel-detail-row">
                <span class="panel-detail-label">Tags</span>
                <span class="panel-detail-value panel-detail-tags" id="panelTags"></span>
              </div>
            </div>
          </div>
          
          <!-- Dynamic Tab Content (Columns, Features, Outputs, etc.) -->
          <div class="panel-tab-content" data-tab-content="columns" id="panelDynamicSections">
            <!-- Content will be populated dynamically based on object type -->
          </div>
          
          <!-- Upstream Tab Content -->
          <div class="panel-tab-content" data-tab-content="upstream" id="panelUpstreamContent">
            <div class="panel-lineage-list" id="panelUpstreamList">
              <div class="panel-empty-state">No upstream objects</div>
            </div>
          </div>
          
          <!-- Downstream Tab Content -->
          <div class="panel-tab-content" data-tab-content="downstream" id="panelDownstreamContent">
            <div class="panel-lineage-list" id="panelDownstreamList">
              <div class="panel-empty-state">No downstream objects</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Edge Panel View -->
      <div class="panel-view panel-edge-view hidden" id="panelEdgeView">
        <div class="panel-header">
          <span class="panel-header-title panel-edge-title" id="panelEdgeTitle">Source to Target</span>
          <div class="panel-header-actions">
            <button class="panel-close" id="panelEdgeClose" aria-label="Close panel">
              <img src="./img/ui/clear.svg" width="16" height="16" alt="Close">
            </button>
          </div>
        </div>
        <!-- Tab Bar -->
        <div class="panel-tabs" id="panelEdgeTabs">
          <button class="panel-tab active" data-tab="details">Details</button>
          <button class="panel-tab" data-tab="sql">SQL</button>
          <button class="panel-tab" data-tab="storedprocs" id="panelStoredProcsTab">Procedures (0)</button>
          <button class="panel-tab" data-tab="tasks" id="panelTasksTab">Tasks (0)</button>
        </div>
        
        <div class="panel-content">
          <!-- Details Tab Content -->
          <div class="panel-tab-content active" data-tab-content="details" id="panelEdgeDetailsContent">
            <div class="panel-details-grid">
              <div class="panel-detail-row">
                <span class="panel-detail-label">Query Type</span>
                <span class="panel-detail-value" id="panelQueryType"></span>
              </div>
              <div class="panel-detail-row" id="panelExternalToolRow" style="display: none;">
                <span class="panel-detail-label">External Tool</span>
                <span class="panel-detail-value panel-external-tool" id="panelExternalTool">
                  <img class="panel-external-tool-icon" id="panelExternalToolIcon" src="" width="16" height="16" alt="">
                  <span id="panelExternalToolName"></span>
                </span>
              </div>
              <div class="panel-detail-row">
                <span class="panel-detail-label">Run By</span>
                <span class="panel-detail-value" id="panelRunBy"></span>
              </div>
              <div class="panel-detail-row">
                <span class="panel-detail-label">Run On</span>
                <span class="panel-detail-value" id="panelRunOn"></span>
              </div>
              <div class="panel-detail-row">
                <span class="panel-detail-label">Duration</span>
                <span class="panel-detail-value" id="panelDuration"></span>
              </div>
              <div class="panel-detail-row">
                <span class="panel-detail-label">Query ID</span>
                <span class="panel-detail-value" id="panelQueryId"></span>
              </div>
              <div class="panel-detail-row">
                <span class="panel-detail-label">Row Count</span>
                <span class="panel-detail-value" id="panelRowCount"></span>
              </div>
            </div>
          </div>
          
          <!-- SQL Tab Content -->
          <div class="panel-tab-content" data-tab-content="sql" id="panelEdgeSqlContent">
            <pre class="panel-sql-code" id="panelSqlQuery">SELECT * FROM table;</pre>
          </div>
          
          <!-- Stored Procedures Tab Content -->
          <div class="panel-tab-content" data-tab-content="storedprocs" id="panelStoredProcsContent">
            <div class="panel-empty-state">No stored procedures</div>
          </div>
          
          <!-- Tasks Tab Content -->
          <div class="panel-tab-content" data-tab-content="tasks" id="panelTasksContent">
            <div class="panel-empty-state">No tasks</div>
          </div>
        </div>
      </div>
      
      <!-- Column Panel View -->
      <div class="panel-view panel-column-view hidden" id="panelColumnView">
        <div class="panel-header">
          <div class="panel-header-main">
            <div class="panel-header-path" id="panelColumnPath">
              <!-- Path will be populated dynamically -->
            </div>
            <div class="panel-header-title-row">
              <div class="panel-header-icon-wrapper">
                <img class="panel-header-icon" id="panelColumnTypeIcon" src="./img/ui/text.svg" alt="">
              </div>
              <span class="panel-header-title" id="panelColumnTitle">Column Name</span>
            </div>
          </div>
          <div class="panel-header-actions">
            <button class="panel-close" id="panelColumnClose" aria-label="Close panel">
              <img src="./img/ui/clear.svg" width="16" height="16" alt="Close">
            </button>
          </div>
        </div>
        <!-- Tab Bar -->
        <div class="panel-tabs" id="panelColumnTabs">
          <button class="panel-tab active" data-tab="details">Details</button>
          <button class="panel-tab" data-tab="upstream" id="panelColumnUpstreamTab">Upstream (0)</button>
          <button class="panel-tab" data-tab="downstream" id="panelColumnDownstreamTab">Downstream (0)</button>
        </div>
        
        <div class="panel-content">
          <!-- Details Tab Content -->
          <div class="panel-tab-content active" data-tab-content="details" id="panelColumnDetailsContent">
            <div class="panel-details-grid">
              <div class="panel-detail-row">
                <span class="panel-detail-label">Description</span>
                <span class="panel-detail-value panel-detail-description" id="panelColumnDescription"></span>
              </div>
              <div class="panel-detail-row">
                <span class="panel-detail-label">Data Type</span>
                <span class="panel-detail-value" id="panelColumnType"></span>
              </div>
              <div class="panel-detail-row">
                <span class="panel-detail-label">Parent Object</span>
                <span class="panel-detail-value" id="panelColumnParent"></span>
              </div>
              <div class="panel-detail-row" id="panelColumnKeyRow" style="display: none;">
                <span class="panel-detail-label">Key Type</span>
                <span class="panel-detail-value" id="panelColumnKeyType"></span>
              </div>
            </div>
          </div>
          
          <!-- Upstream Tab Content -->
          <div class="panel-tab-content" data-tab-content="upstream" id="panelColumnUpstreamContent">
            <div class="panel-lineage-list" id="panelColumnUpstreamList">
              <div class="panel-empty-state">No upstream columns</div>
            </div>
          </div>
          
          <!-- Downstream Tab Content -->
          <div class="panel-tab-content" data-tab-content="downstream" id="panelColumnDownstreamContent">
            <div class="panel-lineage-list" id="panelColumnDownstreamList">
              <div class="panel-empty-state">No downstream columns</div>
            </div>
          </div>
        </div>
      </div>
    </aside>
    </div>

    <!-- React Flow Graph View - UMD builds (dev for debugging) -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/reactflow@11.11.4/dist/umd/index.js"></script>
    <script src="https://unpkg.com/elkjs@0.9.3/lib/elk.bundled.js"></script>
    
    <!-- Mock Data with Column Lineage -->
    <script src="./mockData.js"></script>

    <script>
      // Wait for DOM and libraries to load
      document.addEventListener('DOMContentLoaded', function() {
        // Extract from globals
        const { useState, useCallback, useEffect, useMemo, createElement } = React;
        const { createRoot } = ReactDOM;
        
        // Extract ReactFlow components - use named exports, not default
        const ReactFlowComponent = window.ReactFlow.ReactFlow;
        const Controls = window.ReactFlow.Controls;
        const Background = window.ReactFlow.Background;
        const MiniMap = window.ReactFlow.MiniMap;
        const useNodesState = window.ReactFlow.useNodesState;
        const useEdgesState = window.ReactFlow.useEdgesState;
        const Position = window.ReactFlow.Position;
        const Handle = window.ReactFlow.Handle;
        const ReactFlowProvider = window.ReactFlow.ReactFlowProvider;
        const useReactFlow = window.ReactFlow.useReactFlow;
        const useUpdateNodeInternals = window.ReactFlow.useUpdateNodeInternals;
        const BackgroundVariant = window.ReactFlow.BackgroundVariant;
        const MarkerType = window.ReactFlow.MarkerType;
        
        // Check if ReactFlow loaded
        if (!ReactFlowComponent) {
          console.error('ReactFlow not loaded. Available:', Object.keys(window.ReactFlow || {}));
          return;
        }
        
        const ELK = window.ELK;

      // =============================================
      // Mock Data - loaded from mockData.js
      // Contains columns/features and column lineage
      // =============================================
      // Use the global mockLineageData from mockData.js
      // Also available: window.columnLineage, window.findRelatedColumns, etc.

      // =============================================
      // Debug Helper: Check Column Lineage Edges in DOM
      // =============================================
      function debugColumnLineageEdges(context = '') {
        console.log(`\n=== DEBUG: Column Lineage Edges ${context} ===`);
        
        // 1. Check React Flow's edge elements container
        const reactFlowEdges = document.querySelector('.react-flow__edges');
        if (!reactFlowEdges) {
          console.log(' React Flow edges container not found!');
          return;
        }
        console.log(' React Flow edges container found');
        
        // 2. Find all edge groups (each edge is typically in a <g> element)
        const allEdgeGroups = reactFlowEdges.querySelectorAll('g.react-flow__edge');
        console.log(`Total edges in DOM: ${allEdgeGroups.length}`);
        
        // 3. Find column lineage edges specifically
        const columnEdges = reactFlowEdges.querySelectorAll('.column-lineage');
        console.log(`Column lineage edges (.column-lineage): ${columnEdges.length}`);
        
        // 4. Inspect each column lineage edge
        columnEdges.forEach((edge, i) => {
          const edgeId = edge.getAttribute('data-testid') || edge.id || `edge-${i}`;
          const pathElement = edge.querySelector('path');
          const animatedPath = edge.querySelector('path.react-flow__edge-path');
          
          console.log(`  Edge ${i + 1} (${edgeId}):`);
          console.log(`    - Has path element: ${!!pathElement}`);
          
          if (pathElement) {
            const d = pathElement.getAttribute('d');
            console.log(`    - Path 'd' attribute: ${d ? d.substring(0, 80) + '...' : 'EMPTY'}`);
            console.log(`    - Path has valid coords: ${d && d.length > 10 && !d.includes('NaN')}`);
            
            // Check bounding box
            try {
              const bbox = pathElement.getBBox();
              console.log(`    - Bounding box: ${bbox.width}x${bbox.height} at (${bbox.x}, ${bbox.y})`);
              console.log(`    - Is visible (non-zero size): ${bbox.width > 0 || bbox.height > 0}`);
            } catch (e) {
              console.log(`    - getBBox error: ${e.message}`);
            }
          }
          
          // Check if animated
          const isAnimated = edge.classList.contains('animated');
          console.log(`    - Has 'animated' class: ${isAnimated}`);
          
          // Check computed style visibility
          const style = window.getComputedStyle(edge);
          console.log(`    - Computed visibility: ${style.visibility}, opacity: ${style.opacity}, display: ${style.display}`);
        });
        
        // 5. Also check for any edges with column handle IDs
        const edgesWithColumnHandles = reactFlowEdges.querySelectorAll('[class*="column-edge"]');
        console.log(`Edges with 'column-edge' in class: ${edgesWithColumnHandles.length}`);
        
        // 6. Check if there are any SVG path elements with the blue stroke
        const blueStrokePaths = reactFlowEdges.querySelectorAll('path[stroke="#1A6CE7"]');
        console.log(`Paths with blue stroke (#1A6CE7): ${blueStrokePaths.length}`);
        
        console.log('=== END DEBUG ===\n');
      }
      
      // Expose debug function globally for manual testing
      window.debugColumnLineageEdges = debugColumnLineageEdges;

      // =============================================
      // Column Leaf Status Helper
      // Precompute which columns are leaf nodes (no upstream/downstream)
      // =============================================
      function buildColumnLeafStatus(lineage) {
        // Track which columns have upstream/downstream connections
        const hasUpstream = new Map(); // Map<itemId, Set<columnName>>
        const hasDownstream = new Map(); // Map<itemId, Set<columnName>>
        
        lineage.forEach(edge => {
          // Target columns have upstream connections (they receive data from source)
          if (!hasUpstream.has(edge.targetTable)) {
            hasUpstream.set(edge.targetTable, new Set());
          }
          hasUpstream.get(edge.targetTable).add(edge.targetColumn);
          
          // Source columns have downstream connections (they send data to target)
          if (!hasDownstream.has(edge.sourceTable)) {
            hasDownstream.set(edge.sourceTable, new Set());
          }
          hasDownstream.get(edge.sourceTable).add(edge.sourceColumn);
        });
        
        return { hasUpstream, hasDownstream };
      }
      
      // Build column leaf status from column lineage data
      const columnLeafStatus = buildColumnLeafStatus(window.columnLineage || []);
      // Expose to window for side panel access
      window.columnLeafStatus = columnLeafStatus;

      // Build object leaf status from mockLineageData
      function buildObjectLeafStatus(data) {
        const hasUpstream = new Set(); // Objects that have upstream connections
        const hasDownstream = new Set(); // Objects that have downstream connections
        
        if (!data || !data.depths) return { hasUpstream, hasDownstream };
        
        // First pass: collect all items
        const allItems = [];
        data.depths.forEach(depth => {
          depth.groups.forEach(group => {
            if (group.items) {
              allItems.push(...group.items);
            }
            if (group.schemas) {
              group.schemas.forEach(schema => {
                if (schema.items) {
                  allItems.push(...schema.items);
                }
              });
            }
          });
        });
        
        // Second pass: determine leaf status
        allItems.forEach(item => {
          // If item has downstream connections, it's not a downstream leaf
          if (item.downstream && item.downstream.length > 0) {
            hasDownstream.add(item.id);
            
            // Mark targets as having upstream
            item.downstream.forEach(downName => {
              const normalizedName = downName.toLowerCase().trim();
              allItems.forEach(targetItem => {
                if (targetItem.name?.toLowerCase().trim() === normalizedName) {
                  hasUpstream.add(targetItem.id);
                }
              });
            });
          }
        });
        
        return { hasUpstream, hasDownstream };
      }
      
      // Build object leaf status and expose to window
      const objectLeafStatus = buildObjectLeafStatus(window.mockLineageData);
      window.objectLeafStatus = objectLeafStatus;

      // =============================================
      // Data source color definitions
      // =============================================
      const NODE_COLORS = {
        // Data Warehouses
        snowflake: { primary: "#29B5E8", secondary: "#E7F6FD" },
        databricks: { primary: "#475467", secondary: "#F2F5F9" },
        bigquery: { primary: "#5086EC", secondary: "#F6F7FB" },
        redshift: { primary: "#205B99", secondary: "#F6F7FB" },
        
        // Databases
        postgres: { primary: "#336791", secondary: "#EFF2F3" },
        mysql: { primary: "#00546B", secondary: "#E6EFF2" },
        mssql: { primary: "#EA1B22", secondary: "#FCE9EA" },
        oracle: { primary: "#EA1B22", secondary: "#FCE9EA" },
        maria: { primary: "#32818E", secondary: "#EAF4F6" },
        mongo: { primary: "#26BC6A", secondary: "#E9F9F0" },
        cockroachdb: { primary: "#6431F9", secondary: "#F0EBFE" },
        
        // BI Tools
        tableau: { primary: "#2A5875", secondary: "#F5F5F5" },
        looker: { primary: "#33059F", secondary: "#F9F8FB" },
        metabase: { primary: "#227DE1", secondary: "#EEF6FC" },
        power_bi: { primary: "#F79009", secondary: "#FEF0C7" },
        sigma: { primary: "#101828", secondary: "#F1FFFD" },
        thoughtspot: { primary: "#4E55FD", secondary: "#E8EFFD" },
        mode: { primary: "#1D5243", secondary: "#EEF2E3" },
        hex: { primary: "#473982", secondary: "#F2F1F6" },
        omni: { primary: "#0176D3", secondary: "#E6F0FA" },
        periscope: { primary: "#F79009", secondary: "#FEF0C7" },
        quicksight: { primary: "#00B7F4", secondary: "#EEF6FC" },
        
        // ETL/Orchestration
        airflow: { primary: "#087B88", secondary: "#E6F4F5" },
        dbt: { primary: "#FB6514", secondary: "#FFF6ED" },
        fivetran: { primary: "#242527", secondary: "#F2F2F3" },
        glue: { primary: "#FB6514", secondary: "#FFF6ED" },
        
        // CRM/Marketing
        salesforce: { primary: "#00A1E0", secondary: "#E6F5FF" },
        hubspot: { primary: "#FF7A59", secondary: "#FFF2EE" },
        marketo: { primary: "#473866", secondary: "#F2F0F5" },
        braze: { primary: "#801ED7", secondary: "#F5EBFC" },
        
        // Cloud/Azure
        azure: { primary: "#2687CF", secondary: "#E8F4FC" },
        azure_sql_data_warehouse: { primary: "#2687CF", secondary: "#E8F4FC" },
        azure_sql_database: { primary: "#2687CF", secondary: "#E8F4FC" },
        
        // Google
        google_sheets: { primary: "#0F9D58", secondary: "#E7F6EE" },
        data_studio: { primary: "#1A73E8", secondary: "#EEF6FC" },
        
        // Other
        splunk: { primary: "#242527", secondary: "#F2F2F3" },
        workday: { primary: "#1565C0", secondary: "#E9F1FA" },
        
        // Default/fallback - neutral gray (equal R, G, B)
        default: { 
          primary: "#808080", 
          secondary: "#F5F5F5",
          bgColor: "rgba(128, 128, 128, 0.06)",
          borderColor: "rgba(128, 128, 128, 0.12)"
        },
        ml_models: { 
          primary: "#808080", 
          secondary: "#F5F5F5",
          bgColor: "rgba(128, 128, 128, 0.06)",
          borderColor: "rgba(128, 128, 128, 0.12)"
        },
        exports: { 
          primary: "#808080", 
          secondary: "#F5F5F5",
          bgColor: "rgba(128, 128, 128, 0.06)",
          borderColor: "rgba(128, 128, 128, 0.12)"
        },
        external_apis: { 
          primary: "#808080", 
          secondary: "#F5F5F5",
          bgColor: "rgba(128, 128, 128, 0.06)",
          borderColor: "rgba(128, 128, 128, 0.12)"
        },
      };

      // Helper: Convert hex to RGB
      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (!result) return null;
        return {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        };
      }

      // Helper: Get source colors with fallback
      function getSourceColors(sourceId) {
        const normalizedId = (sourceId || '').toLowerCase().replace(/[^a-z0-9_]/g, '_');
        return NODE_COLORS[normalizedId] || NODE_COLORS.default;
      }

      // Helper: Extract source type from icon path
      function getSourceFromIcon(iconPath) {
        if (!iconPath) return 'default';
        // Extract filename from path like './img/logo-snowflake.svg' -> 'snowflake'
        const match = iconPath.match(/logo[_-]?([a-z0-9_]+)\.svg$/i) || 
                      iconPath.match(/([a-z0-9_]+)\.svg$/i);
        if (match) {
          return match[1].toLowerCase();
        }
        return 'default';
      }

      // Helper: Create background color with opacity
      function getSourceBgColor(sourceId, opacity = 0.04) {
        const colors = getSourceColors(sourceId);
        // Use primary color to create background with specified opacity
        const rgb = hexToRgb(colors.primary);
        if (!rgb) return `rgba(128, 128, 128, ${opacity})`; // fallback to gray
        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
      }

      // Helper: Create border color with opacity
      function getSourceBorderColor(sourceId, opacity = 0.20) {
        const colors = getSourceColors(sourceId);
        // Use primary color to create border with specified opacity
        const rgb = hexToRgb(colors.primary);
        if (!rgb) return `rgba(128, 128, 128, ${opacity})`; // fallback to gray
        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
      }

      // =============================================
      // Helper: Get column type icon image path
      // =============================================
      function getColumnTypeIcon(type) {
        const normalizedType = (type || '').toUpperCase();
        
        // String types
        if (['VARCHAR', 'TEXT', 'STRING', 'CHAR'].some(t => normalizedType.includes(t))) {
          return 'img/ui/text.svg';
        }
        // Integer/Number types
        if (['INTEGER', 'INT', 'BIGINT', 'NUMBER', 'SMALLINT', 'TINYINT'].some(t => normalizedType.includes(t))) {
          return 'img/ui/number.svg';
        }
        // Decimal/Float types
        if (['DECIMAL', 'FLOAT', 'DOUBLE', 'NUMERIC', 'REAL'].some(t => normalizedType.includes(t))) {
          return 'img/ui/number.svg';
        }
        // Boolean types
        if (['BOOLEAN', 'BOOL'].some(t => normalizedType.includes(t))) {
          return 'img/ui/boolean.svg';
        }
        // Binary types
        if (['BINARY', 'VARBINARY', 'BLOB', 'BYTES'].some(t => normalizedType.includes(t))) {
          return 'img/ui/binary.svg';
        }
        // Date types
        if (normalizedType.includes('DATE') && !normalizedType.includes('TIME')) {
          return 'img/ui/calendar.svg';
        }
        // Timestamp types
        if (['TIMESTAMP', 'DATETIME', 'TIME'].some(t => normalizedType.includes(t))) {
          return 'img/ui/calendar.svg';
        }
        // JSON/Code types
        if (['JSON', 'VARIANT'].some(t => normalizedType.includes(t))) {
          return 'img/ui/format-code.svg';
        }
        // Object types
        if (['OBJECT', 'STRUCT', 'MAP'].some(t => normalizedType.includes(t))) {
          return 'img/ui/object.svg';
        }
        // Array types
        if (normalizedType.includes('ARRAY')) {
          return 'img/ui/array.svg';
        }
        // Measure (BI) - numeric
        if (normalizedType === 'MEASURE') {
          return 'img/ui/number.svg';
        }
        // Dimension (BI) - object-like
        if (normalizedType === 'DIMENSION') {
          return 'img/ui/object.svg';
        }
        // ML Feature types
        if (normalizedType === 'CATEGORICAL' || normalizedType === 'SEQUENCE') {
          return 'img/ui/object.svg';
        }
        // Default
        return 'img/ui/column-single.svg';
      }
      // Expose globally for side panel access
      window.getColumnTypeIcon = getColumnTypeIcon;

      // =============================================
      // Component: Column/Feature Type Icon
      // =============================================
      function ColumnTypeIcon({ type }) {
        const iconSrc = getColumnTypeIcon(type);
        return React.createElement('img', { 
          className: 'graph-child-type-icon',
          src: iconSrc,
          alt: type || 'column',
          title: type,
          width: 16,
          height: 16
        });
      }

      // =============================================
      // Component: Key Icon (Primary/Foreign)
      // =============================================
      function KeyIcon({ isPrimaryKey, isForeignKey }) {
        if (isPrimaryKey) {
          return React.createElement('img', { 
            className: 'graph-child-key-icon primary-key',
            src: 'img/ui/ownership.svg',
            alt: 'Primary Key',
            title: 'Primary Key',
            width: 16,
            height: 16
          });
        }
        if (isForeignKey) {
          return React.createElement('img', { 
            className: 'graph-child-key-icon foreign-key',
            src: 'img/ui/format-link.svg',
            alt: 'Foreign Key',
            title: 'Foreign Key',
            width: 16,
            height: 16
          });
        }
        return null;
      }

      // =============================================
      // Component: Node Hover Actions (lineage arrows) - rendered via portal
      // =============================================
      function NodeHoverActions({ position, itemId, isColumn, columnName, hasUpstream, hasDownstream }) {
        const [isVisible, setIsVisible] = React.useState(false);
        const [buttonPosition, setButtonPosition] = React.useState({ top: 0, left: 0 });
        const [hitAreaSize, setHitAreaSize] = React.useState({ width: 24, height: 24 });
        const [actionState, setActionState] = React.useState({ canExpand: false, canCollapse: false });
        const markerRef = React.useRef(null);
        const isOverHitAreaRef = React.useRef(false);
        const showTimeoutRef = React.useRef(null);
        
        // Check if this item has lineage in the button's direction
        const hasLineageInDirection = position === 'left' ? hasUpstream : hasDownstream;
        
        // Determine action state based on per-node lineage expansion (OBJECT level only)
        React.useEffect(() => {
          // Skip for columns - they have different logic
          if (isColumn) {
            setActionState({ canExpand: false, canCollapse: false });
            return;
          }
          
          const updateActionState = () => {
            const expansion = window.lineageExpansion;
            if (!expansion) {
              setActionState({ canExpand: false, canCollapse: false });
              return;
            }
            
            if (position === 'left') {
              // Left = upstream - check this specific item
              setActionState({
                canExpand: expansion.canExpandUpstream(itemId),
                canCollapse: expansion.canCollapseUpstream(itemId)
              });
            } else {
              // Right = downstream - check this specific item
              setActionState({
                canExpand: expansion.canExpandDownstream(itemId),
                canCollapse: expansion.canCollapseDownstream(itemId)
              });
            }
          };
          
          updateActionState();
          // Poll for changes since expansion state is global
          const interval = setInterval(updateActionState, 100);
          return () => clearInterval(interval);
        }, [position, itemId, isColumn]);
        
        // Determine icon and title based on current state
        // For columns: always show expand direction (triggers column lineage mode)
        // For objects: show expand/collapse based on current expansion state
        const getIconAndTitle = () => {
          // For columns: always show outward arrow (to indicate "view lineage")
          if (isColumn) {
            if (position === 'left') {
              return { icon: './img/ui/chevron-left.svg', title: 'View upstream column lineage' };
            } else {
              return { icon: './img/ui/chevron-right.svg', title: 'View downstream column lineage' };
            }
          }
          
          // For objects: show expand/collapse based on state
          if (position === 'left') {
            // Upstream button
            if (actionState.canExpand) {
              // More depth available - show expand (outward arrow)
              return { icon: './img/ui/chevron-left.svg', title: 'Expand upstream (+1 depth)' };
            } else if (actionState.canCollapse) {
              // At max expansion - show collapse (inward arrow)
              return { icon: './img/ui/chevron-right.svg', title: 'Collapse upstream (-1 depth)' };
            }
          } else {
            // Downstream button
            if (actionState.canExpand) {
              // More depth available - show expand (outward arrow)
              return { icon: './img/ui/chevron-right.svg', title: 'Expand downstream (+1 depth)' };
            } else if (actionState.canCollapse) {
              // At max expansion - show collapse (inward arrow)
              return { icon: './img/ui/chevron-left.svg', title: 'Collapse downstream (-1 depth)' };
            }
          }
          return { icon: null, title: '' };
        };
        
        const { icon, title } = getIconAndTitle();
        
        // Determine if button should show:
        // - For columns: show if there's lineage in that direction
        // - For objects: show if there's an action AND lineage in that direction
        const hasAction = isColumn 
          ? !!hasLineageInDirection 
          : (actionState.canExpand || actionState.canCollapse) && !!hasLineageInDirection;
        
        // Listen for hover on parent node
        React.useEffect(() => {
          if (!markerRef.current) return;
          
          const parentNode = markerRef.current.closest('.graph-group-item, .graph-platform-item, .graph-expanded-card, .graph-child-item');
          if (!parentNode) return;
          
          const isExpandedCard = parentNode.classList.contains('graph-expanded-card');
          
          const isColumnItem = parentNode.classList.contains('graph-child-item');
          
          const updateButtonPosition = () => {
            const rect = parentNode.getBoundingClientRect();
            // For expanded cards, align with center of header/name (header has 12px padding + ~10px to center of 20px line)
            // For other items, center vertically
            const topOffset = isExpandedCard ? 22 : rect.height / 2;
            
            // Hit area dimensions: extends toward node to cover the gap
            // Button is 24x24, gap varies: 12px for columns, 8px for object cards
            const buttonSize = 24;
            const gap = isColumnItem ? 12 : 8;
            const overlap = 8;
            const hitAreaWidth = buttonSize + gap + overlap;
            const hitAreaHeight = buttonSize + 16; // 40px (8px above and below)
            
            setHitAreaSize({ width: hitAreaWidth, height: hitAreaHeight });
            
            // Calculate vertical position: center button with the target line
            const hitAreaTop = rect.top + topOffset - buttonSize / 2 - 8; // 8px padding above button
            
            if (position === 'left') {
              // Left button: gap + buttonSize away from left edge
              // Hit area starts at button left edge
              setButtonPosition({
                top: hitAreaTop,
                left: rect.left - gap - buttonSize
              });
            } else {
              // Right button: gap away from right edge
              // Hit area extends left from button position into the node
              setButtonPosition({
                top: hitAreaTop,
                left: rect.right - overlap // start 8px inside node, button at right edge
              });
            }
          };
          
          const showButtons = (e) => {
            // For expanded cards, don't show if hovering on a child item inside
            if (isExpandedCard && e.target.closest('.graph-child-item')) {
              return;
            }
            // Clear any pending show timeout
            if (showTimeoutRef.current) {
              clearTimeout(showTimeoutRef.current);
            }
            // Delay showing by 400ms
            showTimeoutRef.current = setTimeout(() => {
              updateButtonPosition();
              setIsVisible(true);
            }, 400);
          };
          
          const hideButtons = (e) => {
            // Clear any pending show timeout
            if (showTimeoutRef.current) {
              clearTimeout(showTimeoutRef.current);
              showTimeoutRef.current = null;
            }
            // Check if moving to the hover hit area
            const relatedTarget = e.relatedTarget;
            if (relatedTarget && relatedTarget.closest && relatedTarget.closest('.node-hover-actions-portal')) {
              return;
            }
            // Hide both buttons instantly
            window.dispatchEvent(new CustomEvent(`hideHoverButtons-${itemId}`));
          };
          
          // For expanded cards, track mouse movement to show/hide based on child hover
          const handleMouseMove = (e) => {
            if (!isExpandedCard) return;
            
            const isOverChild = e.target.closest('.graph-child-item');
            if (isOverChild) {
              // Clear any pending show timeout and hide instantly
              if (showTimeoutRef.current) {
                clearTimeout(showTimeoutRef.current);
                showTimeoutRef.current = null;
              }
              if (!isOverHitAreaRef.current) {
                setIsVisible(false);
              }
            } else {
              // Only schedule show if not already pending
              if (!showTimeoutRef.current && !isVisible) {
                showTimeoutRef.current = setTimeout(() => {
                  updateButtonPosition();
                  setIsVisible(true);
                }, 400);
              } else if (isVisible) {
                updateButtonPosition();
              }
            }
          };
          
          parentNode.addEventListener('mouseenter', showButtons);
          parentNode.addEventListener('mouseleave', hideButtons);
          
          if (isExpandedCard) {
            parentNode.addEventListener('mousemove', handleMouseMove);
          }
          
          return () => {
            parentNode.removeEventListener('mouseenter', showButtons);
            parentNode.removeEventListener('mouseleave', hideButtons);
            if (isExpandedCard) {
              parentNode.removeEventListener('mousemove', handleMouseMove);
            }
            if (showTimeoutRef.current) {
              clearTimeout(showTimeoutRef.current);
            }
          };
        }, [position]);
        
        // Handle hit area hover
        const handleHitAreaMouseEnter = () => {
          isOverHitAreaRef.current = true;
        };
        
        const handleHitAreaMouseLeave = () => {
          isOverHitAreaRef.current = false;
          // Hide both buttons together
          window.dispatchEvent(new CustomEvent(`hideHoverButtons-${itemId}`));
        };
        
        // Listen for hide event from paired button
        React.useEffect(() => {
          const handleHideEvent = () => {
            isOverHitAreaRef.current = false;
            setIsVisible(false);
          };
          
          window.addEventListener(`hideHoverButtons-${itemId}`, handleHideEvent);
          return () => {
            window.removeEventListener(`hideHoverButtons-${itemId}`, handleHideEvent);
          };
        }, [itemId]);
        
        // Handle button click
        // - For columns: trigger column lineage mode
        // - For objects: expand or collapse (expand takes priority when more depth available)
        const handleButtonClick = (e) => {
          e.stopPropagation();
          e.preventDefault();
          // Dispatch event to hide paired button
          window.dispatchEvent(new CustomEvent(`hideHoverButtons-${itemId}`));
          
          // For columns: trigger column lineage mode by calling handleChildClick
          if (isColumn && columnName) {
            // Use a custom event to trigger column lineage mode
            window.dispatchEvent(new CustomEvent('triggerColumnLineage', {
              detail: { itemId, columnName }
            }));
            return;
          }
          
          // For objects: use expansion system
          const expansion = window.lineageExpansion;
          if (!expansion) return;
          
          if (position === 'left') {
            // Upstream - expand takes priority when not already expanded
            if (actionState.canExpand) {
              expansion.expandUpstream(itemId);
            } else if (actionState.canCollapse) {
              expansion.collapseUpstream(itemId);
            }
          } else {
            // Downstream - expand takes priority when not already expanded
            if (actionState.canExpand) {
              expansion.expandDownstream(itemId);
            } else if (actionState.canCollapse) {
              expansion.collapseDownstream(itemId);
            }
          }
        };
        
        // Invisible marker to find parent node
        const marker = React.createElement('span', {
          ref: markerRef,
          style: { display: 'none' }
        });
        
        // The actual button rendered via portal with extended invisible hit area
        // Only show button if there's an action available
        const button = isVisible && hasAction && icon && ReactDOM.createPortal(
          React.createElement('div', {
            className: 'node-hover-actions-portal',
            style: {
              position: 'fixed',
              top: buttonPosition.top,
              left: buttonPosition.left,
              width: hitAreaSize.width,
              height: hitAreaSize.height,
              zIndex: 100,
              // Uncomment to debug hit area: background: 'rgba(255,0,0,0.1)'
            },
            onMouseEnter: handleHitAreaMouseEnter,
            onMouseLeave: handleHitAreaMouseLeave,
            onClick: (e) => { e.stopPropagation(); e.preventDefault(); },
            onMouseDown: (e) => { e.stopPropagation(); e.preventDefault(); }
          },
            React.createElement('button', {
              className: 'hover-action-btn',
              title: title,
              style: { 
                position: 'absolute',
                top: 8, // 8px from top of hit area (centered in 40px height)
                // Left button: at left edge of hit area
                // Right button: at right edge of hit area (hit area extends left into node)
                left: position === 'left' ? 0 : 'auto',
                right: position === 'right' ? 0 : 'auto'
              },
              onClick: handleButtonClick
            },
              React.createElement('img', { 
                src: icon, 
                alt: position === 'left' ? '<' : '>'
              })
            )
          ),
          document.body
        );
        
        return React.createElement(React.Fragment, null, marker, button);
      }

      // Global registry to close all open menus
      const nodeMenuRegistry = new Set();
      
      function closeAllNodeMenus() {
        nodeMenuRegistry.forEach(closeFunc => closeFunc());
      }
      
      // =============================================
      // Component: Node Inline Actions (stats + more menu)
      // =============================================
      function NodeInlineActions({ itemId, isColumn, columnName }) {
        const [menuOpen, setMenuOpen] = React.useState(false);
        const [menuPosition, setMenuPosition] = React.useState({ top: 0, left: 0 });
        const buttonRef = React.useRef(null);
        const menuRef = React.useRef(null);
        
        // Register close function for this menu
        const closeMenu = React.useCallback(() => setMenuOpen(false), []);
        
        React.useEffect(() => {
          nodeMenuRegistry.add(closeMenu);
          return () => nodeMenuRegistry.delete(closeMenu);
        }, [closeMenu]);
        
        // Calculate menu position when opening
        const openMenu = (e) => {
          e.stopPropagation();
          // Close all other menus first
          closeAllNodeMenus();
          
          if (buttonRef.current) {
            const rect = buttonRef.current.getBoundingClientRect();
            setMenuPosition({
              top: rect.bottom + 4,
              left: rect.left // align left edge of menu with left edge of button
            });
          }
          setMenuOpen(true);
        };
        
        // Add focused style to parent node when menu is open
        React.useEffect(() => {
          if (!buttonRef.current) return;
          
          const parentNode = buttonRef.current.closest('.graph-group-item, .graph-platform-item, .graph-expanded-card, .graph-child-item');
          if (!parentNode) return;
          
          // Don't add focused if already selected
          if (parentNode.classList.contains('selected')) return;
          
          if (menuOpen) {
            parentNode.classList.add('focused');
          } else {
            parentNode.classList.remove('focused');
          }
          
          return () => {
            parentNode.classList.remove('focused');
          };
        }, [menuOpen]);
        
        // Close menu when clicking outside
        React.useEffect(() => {
          if (!menuOpen) return;
          
          const handleClickOutside = (e) => {
            // Check if click is inside the menu portal
            const menuEl = menuRef.current;
            const buttonEl = buttonRef.current;
            
            // If clicking on the menu or button, don't close
            if (menuEl && menuEl.contains(e.target)) return;
            if (buttonEl && buttonEl.contains(e.target)) return;
            
            // Close the menu
            setMenuOpen(false);
          };
          
          // Close on scroll, zoom, or canvas drag
          const handleScroll = () => setMenuOpen(false);
          
          // Close on mousedown (drag start) on canvas
          const handleMouseDown = (e) => {
            const menuEl = menuRef.current;
            const buttonEl = buttonRef.current;
            
            // If mousedown on the menu or button, don't close
            if (menuEl && menuEl.contains(e.target)) return;
            if (buttonEl && buttonEl.contains(e.target)) return;
            
            // Close the menu on any mousedown outside
            setMenuOpen(false);
          };
          
          // Use setTimeout to avoid catching the opening click
          const timeoutId = setTimeout(() => {
            document.addEventListener('click', handleClickOutside, true);
            document.addEventListener('mousedown', handleMouseDown, true);
          }, 0);
          
          document.addEventListener('wheel', handleScroll);
          
          return () => {
            clearTimeout(timeoutId);
            document.removeEventListener('click', handleClickOutside, true);
            document.removeEventListener('mousedown', handleMouseDown, true);
            document.removeEventListener('wheel', handleScroll);
          };
        }, [menuOpen]);
        
        // Menu content
        const menuContent = React.createElement('div', {
          ref: menuRef,
          className: 'node-action-menu-portal',
          style: {
            position: 'fixed',
            top: menuPosition.top,
            left: menuPosition.left,
            zIndex: 99999
          },
          onClick: (e) => e.stopPropagation()
        },
          React.createElement('div', {
            className: 'node-action-menu-item',
            onClick: () => { console.log('Show SQL'); setMenuOpen(false); }
          },
            React.createElement('img', { src: './img/ui/format-code.svg', alt: '' }),
            'Show SQL'
          ),
          React.createElement('div', { className: 'node-action-menu-divider' }),
          React.createElement('div', {
            className: 'node-action-menu-item',
            onClick: () => { console.log('Open All Upstream'); setMenuOpen(false); }
          },
            React.createElement('img', { src: './img/ui/arrow-left.svg', alt: '' }),
            'Open All Upstream'
          ),
          React.createElement('div', {
            className: 'node-action-menu-item',
            onClick: () => { console.log('Close All Upstream'); setMenuOpen(false); }
          },
            React.createElement('img', { src: './img/ui/clear.svg', alt: '' }),
            'Close All Upstream'
          ),
          React.createElement('div', { className: 'node-action-menu-divider' }),
          React.createElement('div', {
            className: 'node-action-menu-item',
            onClick: () => { console.log('Open All Downstream'); setMenuOpen(false); }
          },
            React.createElement('img', { src: './img/ui/arrow-right.svg', alt: '' }),
            'Open All Downstream'
          ),
          React.createElement('div', {
            className: 'node-action-menu-item',
            onClick: () => { console.log('Close All Downstream'); setMenuOpen(false); }
          },
            React.createElement('img', { src: './img/ui/clear.svg', alt: '' }),
            'Close All Downstream'
          )
        );
        
        return React.createElement('div', {
          className: 'node-inline-actions',
          onClick: (e) => e.stopPropagation()
        },
          // Stats button
          React.createElement('button', {
            className: 'inline-action-btn stats-btn',
            title: 'View stats',
            onClick: (e) => {
              e.stopPropagation();
              console.log(`Stats for ${itemId}${columnName ? ':' + columnName : ''}`);
            }
          },
            React.createElement('img', { 
              src: './img/ui/popularity.svg', 
              alt: 'Stats'
            })
          ),
          // More menu button
          React.createElement('button', {
            ref: buttonRef,
            className: 'inline-action-btn more-btn',
            title: 'More actions',
            onClick: openMenu
          },
            React.createElement('img', { 
              src: './img/ui/ellipsis-horizontal.svg', 
              alt: '...'
            })
          ),
          // Render menu via portal to body (outside React Flow zoom transform)
          menuOpen && ReactDOM.createPortal(menuContent, document.body)
        );
      }

      // =============================================
      // Component: Children List (Columns/Features)
      // =============================================
      function ChildrenList({ 
        children, 
        searchQuery, 
        onSearchChange,
        selectedChildren,
        onChildClick,
        onChildHover,
        listHeight,
        isFeatureList,
        nodeId,
        itemId,
        columnLineageMode,
        sourceColumn,
        relatedColumns,
        columnLeafStatus,
        showAllColumns,
        onShowAllClick
      }) {
        // Determine if a child is the source column or a related column
        const getColumnLineageClass = (childName) => {
          if (!columnLineageMode) return '';
          if (sourceColumn?.itemId === itemId && sourceColumn?.columnName === childName) {
            return 'column-lineage-source';
          }
          if (relatedColumns?.has?.(itemId) && relatedColumns.get(itemId).has(childName)) {
            return 'column-lineage-related';
          }
          return '';
        };
        
        // Separate pinned (lineage-related) columns from regular columns
        const pinnedColumns = [];
        const regularColumns = [];
        
        // Check if this is the source item (where the column was clicked)
        const isSourceItem = sourceColumn?.itemId === itemId;
        
        // Count columns that would be hidden in lineage mode (for non-source items)
        // This is calculated regardless of showAllColumns so we know the count for the toggle button
        let hiddenableCount = 0;
        
        (children || []).forEach(child => {
          const lineageClass = getColumnLineageClass(child.name);
          if (lineageClass) {
            pinnedColumns.push({ ...child, lineageClass });
          } else {
            // Track count of columns that would be hidden in lineage mode for non-source items
            if (columnLineageMode && !isSourceItem) {
              hiddenableCount++;
            }
            // In column lineage mode, only show regular columns for the source item
            // Upstream/downstream items only show pinned (related) columns unless showAllColumns
            if (!columnLineageMode || isSourceItem || showAllColumns) {
              regularColumns.push(child);
            }
          }
        });
        
        // Filter regular children by search query (pinned columns are always shown)
        const filteredRegularChildren = regularColumns.filter(child => {
          if (!searchQuery) return true;
          const query = searchQuery.toLowerCase();
          return child.name.toLowerCase().includes(query) || 
                 (child.type && child.type.toLowerCase().includes(query));
        });
        
        // Count of hidden columns for "Show N more" button (only when not showing all)
        const hiddenCount = showAllColumns ? 0 : hiddenableCount;
        
        // Render a single column item
        const renderColumnItem = (child, index, isPinned, lineageClass) => {
          const isSelected = selectedChildren?.has?.(child.name);
          const showHandles = isPinned; // Only render handles when in column lineage mode
          
          // Determine column leaf status
          const isLeafUpstream = !columnLeafStatus?.hasUpstream?.has(itemId) || 
                                 !columnLeafStatus.hasUpstream.get(itemId).has(child.name);
          const isLeafDownstream = !columnLeafStatus?.hasDownstream?.has(itemId) || 
                                   !columnLeafStatus.hasDownstream.get(itemId).has(child.name);
          const leafClasses = [
            isLeafUpstream ? 'leaf-upstream' : '',
            isLeafDownstream ? 'leaf-downstream' : ''
          ].filter(Boolean).join(' ');
          
          // For hover actions: hasUpstream/hasDownstream is the opposite of isLeaf
          const hasColumnUpstream = !isLeafUpstream;
          const hasColumnDownstream = !isLeafDownstream;
          
          return React.createElement('div', {
            key: child.name + '-' + index + (isPinned ? '-pinned' : ''),
            className: `graph-child-item ${isSelected ? 'selected' : ''} ${lineageClass || ''} ${isPinned ? 'pinned' : ''} ${leafClasses}`,
            onClick: (e) => {
              e.stopPropagation();
              onChildClick?.(child.name);
            },
            onMouseEnter: () => onChildHover?.(child.name),
            onMouseLeave: () => onChildHover?.(null)
          },
            // Left hover action (upstream arrow)
            React.createElement(NodeHoverActions, { 
              position: 'left', 
              itemId: itemId, 
              isColumn: true, 
              columnName: child.name,
              hasUpstream: hasColumnUpstream,
              hasDownstream: hasColumnDownstream
            }),
            // Left handle for column input (target)
            showHandles && React.createElement(Handle, {
              type: 'target',
              position: Position.Left,
              id: `column-in-${itemId}-${child.name}`,
              className: 'column-handle-left',
              style: { 
                left: -4,
                top: '50%',
                transform: 'translateY(-50%)',
                width: 8,
                height: 8,
                background: '#1A6CE7',
                border: '2px solid #FFF'
              }
            }),
            // Type icon
            React.createElement(ColumnTypeIcon, { type: child.type }),
            // Name
            React.createElement('span', { className: 'graph-child-name' }, child.name),
            // Key indicator
            React.createElement(KeyIcon, { 
              isPrimaryKey: child.isPrimaryKey, 
              isForeignKey: child.isForeignKey 
            }),
            // Feature importance bar (for ML models)
            child.importance !== undefined && React.createElement('div', { 
              className: 'graph-child-importance',
              title: `Importance: ${(child.importance * 100).toFixed(0)}%`
            },
              React.createElement('div', { 
                className: 'graph-child-importance-bar',
                style: { width: `${child.importance * 100}%` }
              })
            ),
            // Type label (optional, hide for pinned/lineage mode)
            !child.importance && !isPinned && React.createElement('span', { 
              className: 'graph-child-type' 
            }, child.type),
            // Inline actions (stats + menu)
            React.createElement(NodeInlineActions, { 
              itemId: itemId, 
              isColumn: true, 
              columnName: child.name 
            }),
            // Right hover action (downstream arrow)
            React.createElement(NodeHoverActions, { 
              position: 'right', 
              itemId: itemId, 
              isColumn: true, 
              columnName: child.name,
              hasUpstream: hasColumnUpstream,
              hasDownstream: hasColumnDownstream
            }),
            // Right handle for column output (source)
            showHandles && React.createElement(Handle, {
              type: 'source',
              position: Position.Right,
              id: `column-out-${itemId}-${child.name}`,
              className: 'column-handle-right',
              style: { 
                right: -4,
                top: '50%',
                transform: 'translateY(-50%)',
                width: 8,
                height: 8,
                background: '#1A6CE7',
                border: '2px solid #FFF'
              }
            })
          );
        };

        return React.createElement('div', { className: 'graph-children-section' },
          // Pinned columns (outside scrollable area)
          pinnedColumns.length > 0 && React.createElement('div', { className: 'graph-children-pinned' },
            pinnedColumns.map((child, index) => 
              renderColumnItem(child, index, true, child.lineageClass)
            )
          ),
          // Search input (hide in lineage mode)
          !columnLineageMode && React.createElement('div', { className: 'graph-children-search' },
            React.createElement('input', {
              type: 'text',
              className: 'graph-children-search-input',
              placeholder: isFeatureList ? 'Features' : 'Columns.',
              value: searchQuery || '',
              onChange: (e) => {
                e.stopPropagation();
                onSearchChange?.(e.target.value);
              },
              onClick: (e) => e.stopPropagation(),
              onMouseDown: (e) => e.stopPropagation()
            })
          ),
          // Regular children list (scrollable) - hide in column lineage mode when only pinned columns exist (non-source items)
          !(columnLineageMode && pinnedColumns.length > 0 && filteredRegularChildren.length === 0 && !showAllColumns) && React.createElement('div', { 
            className: 'graph-children-list nowheel',
            style: { maxHeight: listHeight || 240 },
            onWheelCapture: (e) => {
              e.stopPropagation();
              e.nativeEvent.stopImmediatePropagation();
            }
          },
            filteredRegularChildren.length === 0 
              ? React.createElement('div', { className: 'graph-children-empty' }, 
                  searchQuery ? 'No matches found' : 'No columns'
                )
              : filteredRegularChildren.map((child, index) => 
                  renderColumnItem(child, index, false, '')
                )
          ),
          // "Show N more" button - only show when there are hidden columns in lineage mode
          hiddenCount > 0 && !showAllColumns && React.createElement('button', {
            className: 'graph-show-more-btn',
            onClick: (e) => {
              e.stopPropagation();
              onShowAllClick?.();
            }
          },
            `Show ${hiddenCount} more`,
            React.createElement('svg', { 
              viewBox: '0 0 12 12', 
              fill: 'none',
              xmlns: 'http://www.w3.org/2000/svg'
            },
              React.createElement('path', {
                d: 'M3 5l3 3 3-3',
                stroke: 'currentColor',
                strokeWidth: '1.5',
                strokeLinecap: 'round',
                strokeLinejoin: 'round'
              })
            )
          ),
          // "Hide columns" button - only show when showAllColumns is true (to collapse back)
          showAllColumns && hiddenableCount > 0 && React.createElement('button', {
            className: 'graph-show-more-btn expanded',
            onClick: (e) => {
              e.stopPropagation();
              onShowAllClick?.();
            }
          },
            `Hide ${hiddenableCount} columns`,
            React.createElement('svg', { 
              viewBox: '0 0 12 12', 
              fill: 'none',
              xmlns: 'http://www.w3.org/2000/svg'
            },
              React.createElement('path', {
                d: 'M3 5l3 3 3-3',
                stroke: 'currentColor',
                strokeWidth: '1.5',
                strokeLinecap: 'round',
                strokeLinejoin: 'round'
              })
            )
          )
        );
      }

      // =============================================
      // Component: Expanded Item Card with Children
      // =============================================
      function ExpandedItemCard({
        item,
        isSelected,
        isFocal,
        childrenExpanded,
        onToggleChildren,
        searchQuery,
        onSearchChange,
        selectedChildren,
        onChildClick,
        onChildHover,
        nodeId,
        columnLineageMode,
        sourceColumn,
        relatedColumns,
        onItemClick,
        isLeafUpstream,
        isLeafDownstream,
        columnLeafStatus,
        showAllColumns,
        onShowAllClick,
        activeTab,
        onTabChange
      }) {
        const hasChildren = item.columns?.length > 0 || item.features?.length > 0;
        const children = item.features || item.columns || [];
        const isFeatureList = item.features?.length > 0;
        const childLabel = isFeatureList ? 'features' : 'columns';
        
        // Check if this is a model with both features and outputs
        const hasFeatures = item.features?.length > 0;
        const hasOutputs = item.outputs?.length > 0;
        const isModelWithTabs = hasFeatures && hasOutputs;
        const currentTab = activeTab || 'features';
        
        // Check if this card is active in column lineage mode
        const isLineageActive = columnLineageMode && (
          sourceColumn?.itemId === item.id || 
          relatedColumns?.has?.(item.id)
        );
        
        // Build leaf classes
        const leafClasses = [
          isLeafUpstream ? 'leaf-upstream' : '',
          isLeafDownstream ? 'leaf-downstream' : ''
        ].filter(Boolean).join(' ');

        return React.createElement('div', { 
          'data-item-id': item.id,
          className: `graph-expanded-card ${isSelected ? 'selected' : ''} ${isFocal ? 'focal' : ''} ${isLineageActive ? 'column-lineage-active' : ''} ${leafClasses}`
        },
          // Left hover action (upstream arrow)
          React.createElement(NodeHoverActions, { 
            position: 'left', 
            itemId: item.id,
            hasUpstream: item.upstream?.length > 0,
            hasDownstream: item.downstream?.length > 0
          }),
          // Header (clickable to select item)
          React.createElement('div', { 
            className: 'graph-expanded-header',
            onClick: (e) => {
              e.stopPropagation();
              onItemClick?.();
            },
            style: { cursor: 'pointer' }
          },
            isFocal && React.createElement('div', { className: 'graph-expanded-badge' }, 'Currently viewing'),
            React.createElement('div', { className: 'graph-expanded-info' },
              React.createElement('img', { className: 'graph-expanded-icon', src: item.icon, alt: '' }),
              React.createElement('span', { className: 'graph-expanded-name' }, item.name)
            ),
            // Inline actions (stats + menu)
            React.createElement(NodeInlineActions, { itemId: item.id })
          ),
          // Right hover action (downstream arrow)
          React.createElement(NodeHoverActions, { 
            position: 'right', 
            itemId: item.id,
            hasUpstream: item.upstream?.length > 0,
            hasDownstream: item.downstream?.length > 0
          }),
          // Tab bar for models with features and outputs
          childrenExpanded && isModelWithTabs && React.createElement('div', { 
            className: 'graph-expanded-tabs'
          },
            React.createElement('button', {
              className: `graph-expanded-tab ${currentTab === 'features' ? 'active' : ''}`,
              onClick: (e) => {
                e.stopPropagation();
                onTabChange?.(item.id, 'features');
              }
            }, `Features (${item.features.length})`),
            React.createElement('button', {
              className: `graph-expanded-tab ${currentTab === 'outputs' ? 'active' : ''}`,
              onClick: (e) => {
                e.stopPropagation();
                onTabChange?.(item.id, 'outputs');
              }
            }, `Outputs (${item.outputs.length})`)
          ),
          // Children section (when expanded) - show features or columns
          childrenExpanded && hasChildren && (!isModelWithTabs || currentTab === 'features') && React.createElement(ChildrenList, {
            children: children,
            searchQuery: searchQuery,
            onSearchChange: onSearchChange,
            selectedChildren: selectedChildren,
            onChildClick: onChildClick,
            onChildHover: onChildHover,
            isFeatureList: isFeatureList,
            nodeId: nodeId,
            itemId: item.id,
            columnLineageMode: columnLineageMode,
            sourceColumn: sourceColumn,
            relatedColumns: relatedColumns,
            columnLeafStatus: columnLeafStatus,
            showAllColumns: showAllColumns,
            onShowAllClick: onShowAllClick
          }),
          // Model outputs section (for ML models) - show when outputs tab is active
          childrenExpanded && isModelWithTabs && currentTab === 'outputs' && React.createElement(ChildrenList, {
            children: item.outputs,
            searchQuery: '',
            isFeatureList: false,
            nodeId: nodeId,
            itemId: item.id,
            columnLineageMode: columnLineageMode,
            sourceColumn: sourceColumn,
            relatedColumns: relatedColumns,
            columnLeafStatus: columnLeafStatus,
            showAllColumns: showAllColumns,
            onShowAllClick: onShowAllClick
          }),
          // For non-model items with outputs, still show outputs below (legacy behavior)
          childrenExpanded && !isModelWithTabs && item.outputs?.length > 0 && React.createElement('div', { className: 'graph-outputs-section' },
            React.createElement('div', { className: 'graph-outputs-header' }, 'Outputs'),
            React.createElement(ChildrenList, {
              children: item.outputs,
              searchQuery: '',
              isFeatureList: false,
              nodeId: nodeId,
              itemId: item.id,
              columnLineageMode: columnLineageMode,
              sourceColumn: sourceColumn,
              relatedColumns: relatedColumns,
              columnLeafStatus: columnLeafStatus,
              showAllColumns: showAllColumns,
              onShowAllClick: onShowAllClick
            })
          )
        );
      }

      // =============================================
      // Custom Node: Object Card (single table/view)
      // =============================================
      function ObjectCardNode({ data, selected, id }) {
        const { item, onItemClick, selectedItemId, isFocal } = data;
        const isSelected = selected || selectedItemId === item.id;

        return React.createElement('div', { 
          className: `graph-object-card ${isSelected ? 'selected' : ''} ${isFocal ? 'focal' : ''}`,
          onClick: () => onItemClick?.(item, id)
        },
          React.createElement(Handle, {
            type: 'target',
            position: Position.Left,
            id: 'left'
          }),
          // Focal badge
          isFocal && React.createElement('div', { className: 'graph-object-focal-badge' }, 'Currently viewing'),
          // Object info
          React.createElement('div', { className: 'graph-object-info' },
            React.createElement('img', { className: 'graph-object-icon', src: item.icon, alt: '' }),
            React.createElement('span', { className: 'graph-object-name' }, item.name)
          ),
          React.createElement(Handle, {
            type: 'source',
            position: Position.Right,
            id: 'right'
          })
        );
      }

      // =============================================
      // Custom Node: Group Node (database > schema > items)
      // =============================================
      function GroupNode({ data, id }) {
        const { 
          database, schema, icon, sourceId, items, onItemClick, selectedItemId, 
          dbCollapsed, schemaCollapsed, onToggleDbCollapse, onToggleSchemaCollapse,
          expandedItems, onToggleItemExpand, itemSearchQueries, onItemSearchChange,
          selectedChildren, onChildClick, onChildHover,
          columnLineageMode, sourceColumn, relatedColumns,
          adjacentItemIds, columnLeafStatus,
          showAllColumnsItems, onShowAllColumns,
          itemActiveTabs, onTabChange
        } = data;
        
        // Get colors for this source
        const bgColor = getSourceBgColor(sourceId, 0.04);
        const borderColor = getSourceBorderColor(sourceId, 0.20);
        const collapsedBorderColor = getSourceBorderColor(sourceId, 0.30);
        const isSingleItem = items.length === 1;
        const isCollapsed = dbCollapsed || schemaCollapsed;

        // Calculate handle position based on collapse state
        const getCollapsedHandleTop = () => {
          if (dbCollapsed) {
            return '24px';
          }
          if (schemaCollapsed) {
            return '62px';
          }
          return '50%';
        };

        const handleDbHeaderClick = (e) => {
          e.stopPropagation();
          onToggleDbCollapse?.(id);
        };

        const handleSchemaHeaderClick = (e) => {
          e.stopPropagation();
          onToggleSchemaCollapse?.(id);
        };

        const collapsedHandleTop = getCollapsedHandleTop();

        // Render an item - either expanded or compact
        const renderItem = (item, index) => {
          const isSelected = selectedItemId === item.id;
          const isExpanded = expandedItems?.[item.id] || false;
          const hasChildren = item.columns?.length > 0 || item.features?.length > 0;
          const searchQuery = itemSearchQueries?.[item.id] || '';
          
          // Check if this item is involved in column lineage
          const isInColumnLineage = columnLineageMode && (
            sourceColumn?.itemId === item.id || 
            relatedColumns?.has?.(item.id)
          );

          // In column lineage mode, show expanded card for items with related columns
          if (isInColumnLineage && hasChildren && isExpanded) {
            return React.createElement('div', {
              key: item.id,
              style: { position: 'relative' }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '28px' }
              }),
              React.createElement(ExpandedItemCard, {
                item: item,
                isSelected: false,
                isFocal: item.isFocal,
                childrenExpanded: true,
                onToggleChildren: () => onToggleItemExpand?.(item.id),
                searchQuery: searchQuery,
                onSearchChange: (query) => onItemSearchChange?.(item.id, query),
                selectedChildren: selectedChildren?.[item.id],
                onChildClick: (childName) => onChildClick?.(item.id, childName),
                onChildHover: (childName) => onChildHover?.(item.id, childName),
                nodeId: id,
                columnLineageMode: columnLineageMode,
                sourceColumn: sourceColumn,
                relatedColumns: relatedColumns,
                onItemClick: () => onItemClick?.(item, id),
                isLeafUpstream: item.isLeafUpstream,
                isLeafDownstream: item.isLeafDownstream,
                columnLeafStatus: columnLeafStatus,
                showAllColumns: showAllColumnsItems?.[item.id],
                onShowAllClick: () => onShowAllColumns?.(item.id),
                activeTab: itemActiveTabs?.[item.id],
                onTabChange: onTabChange
              }),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '28px' }
              })
            );
          }

          // If selected AND has children AND expanded, show expanded card
          if (isSelected && hasChildren && isExpanded) {
            return React.createElement('div', {
              key: item.id,
              style: { position: 'relative' }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '28px' }
              }),
              React.createElement(ExpandedItemCard, {
                item: item,
                isSelected: true,
                isFocal: item.isFocal,
                childrenExpanded: true,
                onToggleChildren: () => onToggleItemExpand?.(item.id),
                searchQuery: searchQuery,
                onSearchChange: (query) => onItemSearchChange?.(item.id, query),
                selectedChildren: selectedChildren?.[item.id],
                onChildClick: (childName) => onChildClick?.(item.id, childName),
                onChildHover: (childName) => onChildHover?.(item.id, childName),
                nodeId: id,
                columnLineageMode: columnLineageMode,
                sourceColumn: sourceColumn,
                relatedColumns: relatedColumns,
                onItemClick: () => onItemClick?.(item, id),
                isLeafUpstream: item.isLeafUpstream,
                isLeafDownstream: item.isLeafDownstream,
                columnLeafStatus: columnLeafStatus,
                showAllColumns: showAllColumnsItems?.[item.id],
                onShowAllClick: () => onShowAllColumns?.(item.id),
                activeTab: itemActiveTabs?.[item.id],
                onTabChange: onTabChange
              }),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '28px' }
              })
            );
          }

          // If selected with children but NOT expanded, show card with toggle button
          if (isSelected && hasChildren) {
            const children = item.features || item.columns || [];
            const childLabel = item.features?.length > 0 ? 'features' : 'columns';
            
            const leafClassesExpanded = [
              item.isLeafUpstream ? 'leaf-upstream' : '',
              item.isLeafDownstream ? 'leaf-downstream' : ''
            ].filter(Boolean).join(' ');
            
            return React.createElement('div', {
              key: item.id,
              'data-item-id': item.id,
              className: `graph-expanded-card selected ${item.isFocal ? 'focal' : ''} ${leafClassesExpanded}`,
              onClick: (e) => {
                e.stopPropagation();
                onItemClick?.(item, id);
              },
              style: { position: 'relative' }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '28px' }
              }),
              React.createElement('div', { className: 'graph-expanded-header' },
                item.isFocal && React.createElement('div', { className: 'graph-expanded-badge' }, 'Currently viewing'),
                React.createElement('div', { className: 'graph-expanded-info' },
                  React.createElement('img', { className: 'graph-expanded-icon', src: item.icon, alt: '' }),
                  React.createElement('span', { className: 'graph-expanded-name' }, item.name)
                )
              ),
              React.createElement('button', {
                className: 'graph-toggle-children-btn',
                onClick: (e) => {
                  e.stopPropagation();
                  onToggleItemExpand?.(item.id);
                }
              },
                `${children.length} ${childLabel}`,
                React.createElement('svg', { 
                  viewBox: '0 0 12 12', 
                  fill: 'none',
                  xmlns: 'http://www.w3.org/2000/svg'
                },
                  React.createElement('path', {
                    d: 'M3 5l3 3 3-3',
                    stroke: 'currentColor',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round'
                  })
                )
              ),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '28px' }
              })
            );
          }

          // Default: Single item card or compact item
          if (isSingleItem) {
            const isAdjacent = adjacentItemIds?.has?.(item.id);
            const leafClasses = [
              item.isLeafUpstream ? 'leaf-upstream' : '',
              item.isLeafDownstream ? 'leaf-downstream' : ''
            ].filter(Boolean).join(' ');
            
            return React.createElement('div', {
              key: item.id,
              className: `graph-group-card ${isSelected ? 'selected' : ''} ${item.isFocal ? 'focal' : ''} ${isAdjacent ? 'edge-adjacent' : ''} ${leafClasses}`,
              onClick: (e) => {
                e.stopPropagation();
                onItemClick?.(item, id);
              }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '50%', transform: 'translateY(-50%)' }
              }),
              item.isFocal && React.createElement('div', { className: 'graph-group-card-badge' }, 'Currently viewing'),
              React.createElement('div', { className: 'graph-group-card-content' },
                React.createElement('img', { className: 'graph-group-card-icon', src: item.icon, alt: '' }),
                React.createElement('span', { className: 'graph-group-card-name' }, item.name)
              ),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '50%', transform: 'translateY(-50%)' }
              })
            );
          }

          // Multiple items - compact list item
          const isAdjacent = adjacentItemIds?.has?.(item.id);
          const leafClassesCompact = [
            item.isLeafUpstream ? 'leaf-upstream' : '',
            item.isLeafDownstream ? 'leaf-downstream' : ''
          ].filter(Boolean).join(' ');
          
          return React.createElement('div', {
            key: item.id,
            'data-item-id': item.id,
            className: `graph-group-item ${isSelected ? 'selected' : ''} ${item.isFocal ? 'focal' : ''} ${isAdjacent ? 'edge-adjacent' : ''} ${leafClassesCompact}`,
            onClick: (e) => {
              e.stopPropagation();
              onItemClick?.(item, id);
            }
          },
            // Left hover action (upstream arrow)
            React.createElement(NodeHoverActions, { 
              position: 'left', 
              itemId: item.id,
              hasUpstream: item.upstream?.length > 0,
              hasDownstream: item.downstream?.length > 0
            }),
            React.createElement(Handle, {
              type: 'target',
              position: Position.Left,
              id: `left-${item.id}`,
              style: { top: 'auto', bottom: 'auto' }
            }),
            React.createElement('img', { className: 'graph-group-item-icon', src: item.icon, alt: '' }),
            React.createElement('span', { className: 'graph-group-item-name' }, item.name),
            // Inline actions (stats + menu)
            React.createElement(NodeInlineActions, { itemId: item.id }),
            // Right hover action (downstream arrow)
            React.createElement(NodeHoverActions, { 
              position: 'right', 
              itemId: item.id,
              hasUpstream: item.upstream?.length > 0,
              hasDownstream: item.downstream?.length > 0
            }),
            React.createElement(Handle, {
              type: 'source',
              position: Position.Right,
              id: `right-${item.id}`,
              style: { top: 'auto', bottom: 'auto' }
            })
          );
        };

        return React.createElement('div', { 
          className: 'graph-group-container',
          style: {
            padding: '0'
          }
        },
          // Collapsed handles
          isCollapsed && items.map(item => 
            React.createElement(React.Fragment, { key: `collapsed-handles-${item.id}` },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: collapsedHandleTop, transform: 'translateY(-50%)' }
              }),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: collapsedHandleTop, transform: 'translateY(-50%)' }
              })
            )
          ),
          // Database header
          React.createElement('div', { 
            className: `graph-group-db-header ${dbCollapsed ? 'collapsed' : ''}`,
            onClick: handleDbHeaderClick,
            style: dbCollapsed ? {
              border: `1px solid ${collapsedBorderColor}`,
              borderRadius: '12px',
              padding: '8px 12px'
            } : undefined
          },
            React.createElement('img', { className: 'graph-group-db-icon', src: icon, alt: '' }),
            React.createElement('img', { className: 'graph-group-db-icon', src: './img/ui/database.svg', alt: '' }),
            React.createElement('span', { className: 'graph-group-db-name' }, database)
          ),
          // Schema section
          !dbCollapsed && React.createElement('div', { 
            className: 'graph-group-schema-section',
            style: {
              background: bgColor,
              border: `1px solid ${borderColor}`,
              borderRadius: '12px',
              padding: '8px'
            }
          },
            React.createElement('div', { 
              className: `graph-group-schema-header ${schemaCollapsed ? 'collapsed' : ''}`,
              onClick: handleSchemaHeaderClick
            },
              React.createElement('img', { className: 'graph-group-schema-icon', src: './img/ui/schema.svg', alt: '' }),
              React.createElement('span', { className: 'graph-group-schema-name' }, schema)
            ),
            !schemaCollapsed && React.createElement('div', { className: 'graph-group-items' },
              items.map(renderItem)
            )
          )
        );
      }

      // =============================================
      // Custom Node: Platform Group (Tableau, Looker, etc)
      // =============================================
      function PlatformGroupNode({ data, id }) {
        const { 
          name, icon, items, platformId, onItemClick, selectedItemId, collapsed, onToggleCollapse,
          schemaCollapsed, onToggleSchemaCollapse,
          expandedItems, onToggleItemExpand, itemSearchQueries, onItemSearchChange,
          selectedChildren, onChildClick, onChildHover,
          columnLineageMode, sourceColumn, relatedColumns,
          adjacentItemIds, columnLeafStatus,
          showAllColumnsItems, onShowAllColumns,
          itemActiveTabs, onTabChange
        } = data;

        const handleHeaderClick = (e) => {
          e.stopPropagation();
          onToggleCollapse?.(id);
        };

        const handleSchemaHeaderClick = (e) => {
          e.stopPropagation();
          onToggleSchemaCollapse?.(id);
        };

        const collapsedHandleTop = collapsed ? '24px' : (schemaCollapsed ? '62px' : '24px');

        // Render an item - either expanded or compact
        const renderItem = (item, index) => {
          const isSelected = selectedItemId === item.id;
          const isExpanded = expandedItems?.[item.id] || false;
          const hasChildren = item.columns?.length > 0 || item.features?.length > 0;
          const searchQuery = itemSearchQueries?.[item.id] || '';
          
          // Check if this item is involved in column lineage
          const isInColumnLineage = columnLineageMode && (
            sourceColumn?.itemId === item.id || 
            relatedColumns?.has?.(item.id)
          );

          // In column lineage mode, show expanded card for items with related columns
          if (isInColumnLineage && hasChildren && isExpanded) {
            return React.createElement('div', {
              key: item.id,
              style: { position: 'relative' }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '28px' }
              }),
              React.createElement(ExpandedItemCard, {
                item: item,
                isSelected: false,
                isFocal: false,
                childrenExpanded: true,
                onToggleChildren: () => onToggleItemExpand?.(item.id),
                searchQuery: searchQuery,
                onSearchChange: (query) => onItemSearchChange?.(item.id, query),
                selectedChildren: selectedChildren?.[item.id],
                onChildClick: (childName) => onChildClick?.(item.id, childName),
                onChildHover: (childName) => onChildHover?.(item.id, childName),
                nodeId: id,
                columnLineageMode: columnLineageMode,
                sourceColumn: sourceColumn,
                relatedColumns: relatedColumns,
                onItemClick: () => onItemClick?.(item, id),
                isLeafUpstream: item.isLeafUpstream,
                isLeafDownstream: item.isLeafDownstream,
                columnLeafStatus: columnLeafStatus,
                showAllColumns: showAllColumnsItems?.[item.id],
                onShowAllClick: () => onShowAllColumns?.(item.id),
                activeTab: itemActiveTabs?.[item.id],
                onTabChange: onTabChange
              }),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '28px' }
              })
            );
          }

          // If selected AND has children AND expanded, show expanded card
          if (isSelected && hasChildren && isExpanded) {
            return React.createElement('div', {
              key: item.id,
              style: { position: 'relative' }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '28px' }
              }),
              React.createElement(ExpandedItemCard, {
                item: item,
                isSelected: true,
                isFocal: false,
                childrenExpanded: true,
                onToggleChildren: () => onToggleItemExpand?.(item.id),
                searchQuery: searchQuery,
                onSearchChange: (query) => onItemSearchChange?.(item.id, query),
                selectedChildren: selectedChildren?.[item.id],
                onChildClick: (childName) => onChildClick?.(item.id, childName),
                onChildHover: (childName) => onChildHover?.(item.id, childName),
                nodeId: id,
                columnLineageMode: columnLineageMode,
                sourceColumn: sourceColumn,
                relatedColumns: relatedColumns,
                onItemClick: () => onItemClick?.(item, id),
                isLeafUpstream: item.isLeafUpstream,
                isLeafDownstream: item.isLeafDownstream,
                columnLeafStatus: columnLeafStatus,
                showAllColumns: showAllColumnsItems?.[item.id],
                onShowAllClick: () => onShowAllColumns?.(item.id),
                activeTab: itemActiveTabs?.[item.id],
                onTabChange: onTabChange
              }),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '28px' }
              })
            );
          }

          // If selected with children but NOT expanded, show card with toggle button
          if (isSelected && hasChildren) {
            const children = item.features || item.columns || [];
            const childLabel = item.features?.length > 0 ? 'features' : 'columns';
            
            const leafClassesPlatformExpanded = [
              item.isLeafUpstream ? 'leaf-upstream' : '',
              item.isLeafDownstream ? 'leaf-downstream' : ''
            ].filter(Boolean).join(' ');
            
            return React.createElement('div', {
              key: item.id,
              'data-item-id': item.id,
              className: `graph-expanded-card selected ${leafClassesPlatformExpanded}`,
              onClick: (e) => {
                e.stopPropagation();
                onItemClick?.(item, id);
              },
              style: { position: 'relative' }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '28px' }
              }),
              React.createElement('div', { className: 'graph-expanded-header' },
                React.createElement('div', { className: 'graph-expanded-info' },
                  React.createElement('img', { className: 'graph-expanded-icon', src: item.icon, alt: '' }),
                  React.createElement('span', { className: 'graph-expanded-name' }, item.name)
                )
              ),
              React.createElement('button', {
                className: 'graph-toggle-children-btn',
                onClick: (e) => {
                  e.stopPropagation();
                  onToggleItemExpand?.(item.id);
                }
              },
                `${children.length} ${childLabel}`,
                React.createElement('svg', { 
                  viewBox: '0 0 12 12', 
                  fill: 'none',
                  xmlns: 'http://www.w3.org/2000/svg'
                },
                  React.createElement('path', {
                    d: 'M3 5l3 3 3-3',
                    stroke: 'currentColor',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round'
                  })
                )
              ),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '28px' }
              })
            );
          }

          // Default compact platform item
          const isAdjacent = adjacentItemIds?.has?.(item.id);
          const leafClassesPlatform = [
            item.isLeafUpstream ? 'leaf-upstream' : '',
            item.isLeafDownstream ? 'leaf-downstream' : ''
          ].filter(Boolean).join(' ');
          
          return React.createElement('div', {
            key: item.id,
            'data-item-id': item.id,
            className: `graph-platform-item ${isSelected ? 'selected' : ''} ${isAdjacent ? 'edge-adjacent' : ''} ${leafClassesPlatform}`,
            onClick: (e) => {
              e.stopPropagation();
              onItemClick?.(item, id);
            }
          },
            // Left hover action (upstream arrow)
            React.createElement(NodeHoverActions, { 
              position: 'left', 
              itemId: item.id,
              hasUpstream: item.upstream?.length > 0,
              hasDownstream: item.downstream?.length > 0
            }),
            React.createElement(Handle, {
              type: 'target',
              position: Position.Left,
              id: `left-${item.id}`,
              style: { top: 'auto', bottom: 'auto' }
            }),
            React.createElement('img', { className: 'graph-platform-item-icon', src: item.icon, alt: '' }),
            React.createElement('span', { className: 'graph-platform-item-name' }, item.name),
            // Inline actions (stats + menu)
            React.createElement(NodeInlineActions, { itemId: item.id }),
            // Right hover action (downstream arrow)
            React.createElement(NodeHoverActions, { 
              position: 'right', 
              itemId: item.id,
              hasUpstream: item.upstream?.length > 0,
              hasDownstream: item.downstream?.length > 0
            }),
            React.createElement(Handle, {
              type: 'source',
              position: Position.Right,
              id: `right-${item.id}`,
              style: { top: 'auto', bottom: 'auto' }
            })
          );
        };

        // Get colors for this platform
        const bgColor = getSourceBgColor(platformId, 0);
        const borderColor = getSourceBorderColor(platformId, 0.20);
        const collapsedBorderColor = getSourceBorderColor(platformId, 0.30);

        // Determine group label based on item types
        const getGroupLabel = () => {
          if (!items || items.length === 0) return 'Items';
          const firstItem = items[0];
          if (firstItem.type === 'dashboard' || firstItem.icon?.includes('dashboard')) return 'Dashboards';
          if (firstItem.type === 'semantic_model' || firstItem.type === 'semanticModel') return 'Semantic models';
          if (firstItem.type === 'report') return 'Reports';
          if (firstItem.type === 'look') return 'Looks';
          if (firstItem.type === 'explore') return 'Explores';
          if (firstItem.type === 'worksheet') return 'Worksheets';
          if (firstItem.type === 'workbook') return 'Workbooks';
          return data.groupLabel || 'Items';
        };

        const groupLabel = getGroupLabel();

        // Get icon for group label
        const getGroupIcon = () => {
          if (groupLabel === 'Dashboards') return './img/ui/dashboards.svg';
          if (groupLabel === 'Semantic models') return './img/ui/data-semantic.svg';
          if (groupLabel === 'Reports') return './img/ui/dashboards.svg';
          if (groupLabel === 'Looks') return './img/ui/dashboards.svg';
          if (groupLabel === 'Explores') return './img/ui/table.svg';
          if (groupLabel === 'Worksheets') return './img/ui/table.svg';
          if (groupLabel === 'Workbooks') return './img/ui/dashboards.svg';
          return './img/ui/table.svg';
        };

        const groupIcon = getGroupIcon();

        return React.createElement('div', { 
          className: `graph-platform-container platform-${platformId}`,
          style: {
            background: 'transparent',
            border: 'none',
            borderRadius: '12px',
            padding: '8px'
          }
        },
          // Collapsed handles
          (collapsed || schemaCollapsed) && items.map(item => 
            React.createElement(React.Fragment, { key: `collapsed-handles-${item.id}` },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: collapsedHandleTop, transform: 'translateY(-50%)' }
              }),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: collapsedHandleTop, transform: 'translateY(-50%)' }
              })
            )
          ),
          // Platform header (outside colored section - like db header)
          React.createElement('div', { 
            className: `graph-group-db-header ${collapsed ? 'collapsed' : ''}`,
            onClick: handleHeaderClick,
            style: collapsed ? {
              border: `1px solid ${collapsedBorderColor}`,
              borderRadius: '12px',
              padding: '8px 12px'
            } : undefined
          },
            React.createElement('img', { className: 'graph-group-db-icon', src: icon, alt: '' }),
            React.createElement('span', { className: 'graph-group-db-name' }, name)
          ),
          // Inner group section (colored container - like schema section)
          !collapsed && React.createElement('div', { 
            className: 'graph-group-schema-section',
            style: {
              background: bgColor,
              border: `1px solid ${borderColor}`,
              borderRadius: '12px',
              padding: '8px'
            }
          },
            // Group type header (like schema header)
            React.createElement('div', { 
              className: `graph-group-schema-header ${schemaCollapsed ? 'collapsed' : ''}`,
              onClick: handleSchemaHeaderClick
            },
              React.createElement('img', { className: 'graph-group-schema-icon', src: groupIcon, alt: '' }),
              React.createElement('span', { className: 'graph-group-schema-name' }, groupLabel),
              React.createElement('span', { className: 'graph-group-schema-count' }, items.length)
            ),
            // Items list
            !schemaCollapsed && React.createElement('div', { className: 'graph-platform-items' },
              items.map(renderItem)
            )
          )
        );
      }

      // =============================================
      // Node Types Registry
      // =============================================
      const nodeTypes = {
        objectCard: ObjectCardNode,
        groupNode: GroupNode,
        platformGroup: PlatformGroupNode,
      };

      // =============================================
      // ELK Layout Configuration
      // =============================================
      const elk = new ELK();

      const elkLayoutOptions = {
        'elk.algorithm': 'layered',
        'elk.direction': 'RIGHT',
        'elk.spacing.nodeNode': '72',
        'elk.layered.spacing.nodeNodeBetweenLayers': '120',
        'elk.layered.spacing.edgeNodeBetweenLayers': '40',
        'elk.edgeRouting': 'SPLINES',
        'elk.layered.nodePlacement.strategy': 'BRANDES_KOEPF',
        'elk.layered.nodePlacement.bk.fixedAlignment': 'BALANCED',
        'elk.layered.crossingMinimization.strategy': 'LAYER_SWEEP',
        'elk.contentAlignment': 'V_CENTER',
        'elk.nodeLabels.placement': 'INSIDE V_CENTER H_CENTER',
      };

      // =============================================
      // Measure Actual DOM Node Heights
      // =============================================
      function measureNodeHeight(nodeId) {
        // Find the React Flow node DOM element
        const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
        if (!nodeElement) {
          return null;
        }
        
        // Get the actual rendered height of the node content
        // React Flow nodes have the content as a child element
        const contentElement = nodeElement.querySelector('.graph-group-container, .graph-platform-container, .graph-object-card');
        if (contentElement) {
          const rect = contentElement.getBoundingClientRect();
          return rect.height;
        }
        
        // Fallback to node element itself
        const rect = nodeElement.getBoundingClientRect();
        return rect.height;
      }

      // =============================================
      // Center Columns Based on Measured Heights
      // =============================================
      function centerColumnsByMeasuredHeights(nodes, gap = 72) {
        // Group nodes by layer
        const nodesByLayer = {};
        nodes.forEach(node => {
          const layer = node.data.layer;
          if (layer !== undefined) {
            if (!nodesByLayer[layer]) {
              nodesByLayer[layer] = [];
            }
            nodesByLayer[layer].push(node);
          }
        });

        // Sort nodes within each layer by their current Y position to maintain order
        Object.keys(nodesByLayer).forEach(layer => {
          nodesByLayer[layer].sort((a, b) => a.position.y - b.position.y);
        });

        // Center each layer independently
        Object.keys(nodesByLayer).forEach(layer => {
          const layerNodes = nodesByLayer[layer];
          
          // Measure actual heights from DOM, fallback to data.height
          const heights = layerNodes.map(node => {
            const measuredHeight = measureNodeHeight(node.id);
            return measuredHeight || node.data.height || 100;
          });
          
          // Calculate total height for this layer
          let totalHeight = 0;
          heights.forEach((height, idx) => {
            totalHeight += height;
            if (idx < heights.length - 1) totalHeight += gap;
          });
          
          // Position nodes centered around Y=0
          let currentY = -totalHeight / 2;
          layerNodes.forEach((node, idx) => {
            node.position = {
              ...node.position,
              y: currentY
            };
            // Update the data.height to match measured height for future reference
            node.data.height = heights[idx];
            currentY += heights[idx] + gap;
          });
        });

        return nodes;
      }

      async function calculateLayout(nodes, edges) {
        const elkGraph = {
          id: 'root',
          layoutOptions: elkLayoutOptions,
          children: nodes.map(node => ({
            id: node.id,
            width: node.data.width || 240,
            height: node.data.height || 100,
            // Assign layer based on depth
            layoutOptions: {
              'elk.layered.layerConstraint': node.data.layer !== undefined ? node.data.layer.toString() : undefined,
            }
          })),
          edges: edges.map(edge => ({
            id: edge.id,
            sources: [edge.source],
            targets: [edge.target],
          })),
        };

        const layoutedGraph = await elk.layout(elkGraph);

        // First pass: get positions from ELK
        const layoutedNodes = nodes.map(node => {
          const layoutedNode = layoutedGraph.children.find(n => n.id === node.id);
          return {
            ...node,
            position: {
              x: layoutedNode?.x || 0,
              y: layoutedNode?.y || 0,
            },
          };
        });

        // Second pass: center each column vertically around Y=0
        // Use the centralized centering function
        return centerColumnsByMeasuredHeights(layoutedNodes, 72);
      }

      // =============================================
      // Compute Upstream Map (invert downstream relationships)
      // Returns a Map: itemId -> array of upstream item IDs
      // =============================================
      function computeUpstreamMap(data) {
        const upstreamMap = new Map();
        
        // Initialize all items with empty upstream arrays
        data.depths.forEach(depth => {
          depth.groups.forEach(group => {
            if (group.schemas) {
              group.schemas.forEach(schema => {
                schema.items.forEach(item => {
                  if (!upstreamMap.has(item.id)) {
                    upstreamMap.set(item.id, []);
                  }
                });
              });
            } else if (group.items) {
              group.items.forEach(item => {
                if (!upstreamMap.has(item.id)) {
                  upstreamMap.set(item.id, []);
                }
              });
            }
          });
        });
        
        // Build upstream relationships by inverting downstream
        data.depths.forEach(depth => {
          depth.groups.forEach(group => {
            if (group.schemas) {
              group.schemas.forEach(schema => {
                schema.items.forEach(item => {
                  if (item.downstream) {
                    item.downstream.forEach(downstreamId => {
                      if (upstreamMap.has(downstreamId)) {
                        upstreamMap.get(downstreamId).push(item.id);
                      }
                    });
                  }
                });
              });
            } else if (group.items) {
              group.items.forEach(item => {
                if (item.downstream) {
                  item.downstream.forEach(downstreamId => {
                    if (upstreamMap.has(downstreamId)) {
                      upstreamMap.get(downstreamId).push(item.id);
                    }
                  });
                }
              });
            }
          });
        });
        
        return upstreamMap;
      }
      
      // =============================================
      // Compute Visible Nodes Based on Per-Node Expansion
      // Returns set of visible item IDs
      // =============================================
      function computeVisibleNodes(data, expandedUpstream, expandedDownstream, focalId) {
        const visibleIds = new Set();
        const allItems = new Map(); // id -> item
        
        // Build item map
        data.depths.forEach(depth => {
          depth.groups.forEach(group => {
            if (group.schemas) {
              group.schemas.forEach(schema => {
                schema.items.forEach(item => {
                  allItems.set(item.id, item);
                });
              });
            } else if (group.items) {
              group.items.forEach(item => {
                allItems.set(item.id, item);
              });
            }
          });
        });
        
        // Compute upstream map since items don't have upstream arrays in mockData
        const upstreamMap = computeUpstreamMap(data);
        
        // Find focal item
        let focalItem = null;
        if (focalId) {
          focalItem = allItems.get(focalId);
        }
        if (!focalItem) {
          // Find by isFocal flag
          for (const [id, item] of allItems) {
            if (item.isFocal) {
              focalItem = item;
              focalId = id;
              break;
            }
          }
        }
        
        if (!focalItem) {
          // No focal, return all items
          return { visibleIds: new Set(allItems.keys()), allItems };
        }
        
        // Add focal
        visibleIds.add(focalId);
        
        // Get focal's upstream from computed map
        const focalUpstream = upstreamMap.get(focalId) || [];
        
        // BFS to find visible nodes
        // Traverse upstream from nodes that have expandedUpstream
        const upstreamQueue = expandedUpstream.has(focalId) ? [...focalUpstream] : [];
        while (upstreamQueue.length > 0) {
          const itemId = upstreamQueue.shift();
          if (visibleIds.has(itemId)) continue;
          
          const item = allItems.get(itemId);
          if (!item) continue;
          
          visibleIds.add(itemId);
          
          // If this node also has its upstream expanded, add its upstream to queue
          if (expandedUpstream.has(itemId)) {
            const itemUpstream = upstreamMap.get(itemId) || [];
            upstreamQueue.push(...itemUpstream);
          }
        }
        
        // Traverse downstream from nodes that have expandedDownstream
        const downstreamQueue = expandedDownstream.has(focalId) ? [...(focalItem.downstream || [])] : [];
        while (downstreamQueue.length > 0) {
          const itemId = downstreamQueue.shift();
          if (visibleIds.has(itemId)) continue;
          
          const item = allItems.get(itemId);
          if (!item) continue;
          
          visibleIds.add(itemId);
          
          // If this node also has its downstream expanded, add its downstream to queue
          if (expandedDownstream.has(itemId) && item.downstream) {
            downstreamQueue.push(...item.downstream);
          }
        }
        
        return { visibleIds, allItems };
      }
      
      // =============================================
      // Filter Data by Visible Nodes
      // Returns filtered data containing only visible items
      // =============================================
      function filterDataByVisibility(data, visibleIds) {
        const filteredDepths = data.depths.map(depth => {
          const filteredGroups = depth.groups.map(group => {
            if (group.schemas) {
              const filteredSchemas = group.schemas.map(schema => ({
                ...schema,
                items: schema.items.filter(item => visibleIds.has(item.id))
              })).filter(schema => schema.items.length > 0);
              
              if (filteredSchemas.length === 0) return null;
              return { ...group, schemas: filteredSchemas };
            } else if (group.items) {
              const filteredItems = group.items.filter(item => visibleIds.has(item.id));
              if (filteredItems.length === 0) return null;
              return { ...group, items: filteredItems };
            }
            return null;
          }).filter(g => g !== null);
          
          if (filteredGroups.length === 0) return null;
          return { ...depth, groups: filteredGroups };
        }).filter(d => d !== null);
        
        return { ...data, depths: filteredDepths };
      }
      
      // =============================================
      // Transform Mock Data to Nodes & Edges
      // Groups with compact cards, focal as single card
      // =============================================
      function transformDataToNodesAndEdges(data, onItemClick, selectedItemId, collapseHandlers = {}) {
        const { onToggleDbCollapse, onToggleSchemaCollapse, onTogglePlatformCollapse } = collapseHandlers;
        const nodes = [];
        const edges = [];
        const allItems = [];
        const itemToHandleMap = new Map(); // Map item id to node id and handle id
        
        // Compute upstream relationships from FULL data (not filtered)
        // This ensures items always know their true upstream connections
        const upstreamMap = computeUpstreamMap(window.mockLineageData || data);

        data.depths.forEach((depth, depthIndex) => {
          depth.groups.forEach((group, groupIndex) => {
            
            if (group.type === 'database' && group.schemas) {
              // Database group with schemas - create group nodes
              group.schemas.forEach((schema, schemaIndex) => {
                const groupNodeId = `group-${group.id}-${schema.id}`;
                const itemHeight = 40;
                // Match calculateNodeHeight: dbHeaderHeight(32) + schemaHeaderHeight(40) + schemaPadding(16) + containerPadding(16)
                const baseHeight = 32 + 40 + 16 + 16; // = 104
                const nodeHeight = baseHeight + (schema.items.length * itemHeight);
                
                // Check if this group contains the focal item
                const hasFocal = schema.items.some(item => item.isFocal);
                
                // Always use groupNode for database/schema structures
                // Enrich items with database and schema info, including computed upstream
                const enrichedItems = schema.items.map(item => ({
                  ...item,
                  database: group.database,
                  schemaName: schema.name,
                  sourceIcon: group.icon,
                  upstream: upstreamMap.get(item.id) || []
                }));
                
                nodes.push({
                  id: groupNodeId,
                  type: 'groupNode',
                  position: { x: 0, y: 0 },
                  data: {
                    database: group.database,
                    schema: schema.name,
                    icon: group.icon,
                    sourceId: getSourceFromIcon(group.icon), // e.g., 'snowflake', 'databricks'
                    items: enrichedItems,
                    onItemClick,
                    selectedItemId,
                    hasFocal,
                    layer: depthIndex,
                    width: 340,
                    height: nodeHeight,
                    dbCollapsed: false,
                    schemaCollapsed: false,
                    onToggleDbCollapse,
                    onToggleSchemaCollapse,
                  },
                });
                  
                // Map each item to handles on this group node
                enrichedItems.forEach(item => {
                  itemToHandleMap.set(item.id, { 
                    nodeId: groupNodeId, 
                    sourceHandle: `right-${item.id}`,
                    targetHandle: `left-${item.id}`
                  });
                  allItems.push({ ...item, nodeId: groupNodeId, isFocal: item.isFocal });
                });
              });
              
            } else if (group.type === 'platform' && group.items) {
              // Platform group (Tableau, Looker, etc)
              const platformNodeId = `platform-${group.id}`;
              const itemHeight = 40;
              // Platform nodes use same structure as group nodes, so use same height formula
              // Match calculateNodeHeight: dbHeaderHeight(32) + schemaHeaderHeight(40) + schemaPadding(16) + containerPadding(16) + 24
              const baseHeight = 32 + 40 + 16 + 16 + 24; // = 128
              const nodeHeight = baseHeight + (group.items.length * itemHeight);
              
              // Enrich items with platform info, including computed upstream
              const enrichedPlatformItems = group.items.map(item => ({
                ...item,
                platform: group.name,
                platformIcon: group.icon,
                upstream: upstreamMap.get(item.id) || []
              }));
              
              nodes.push({
                id: platformNodeId,
                type: 'platformGroup',
                position: { x: 0, y: 0 },
                data: {
                  name: group.name,
                  icon: group.icon,
                  items: enrichedPlatformItems,
                  platformId: group.id,
                  onItemClick,
                  selectedItemId,
                  layer: depthIndex,
                  width: 340,
                  height: nodeHeight,
                  collapsed: false,
                  schemaCollapsed: false,
                  onToggleCollapse: onTogglePlatformCollapse,
                  onToggleSchemaCollapse,
                },
              });
              
              // Map each item to handles on this platform node
              enrichedPlatformItems.forEach(item => {
                itemToHandleMap.set(item.id, { 
                  nodeId: platformNodeId, 
                  sourceHandle: `right-${item.id}`,
                  targetHandle: `left-${item.id}`
                });
                allItems.push({ ...item, nodeId: platformNodeId });
              });
            }
          });
        });

        // Create edges between items using handle mapping
        // Build itemsWithUpstream from FULL mockLineageData (not filtered data)
        // This ensures leaf status reflects actual connections, not just visible ones
        const itemsWithUpstream = new Set();
        if (window.mockLineageData) {
          window.mockLineageData.depths.forEach(depth => {
            depth.groups.forEach(group => {
              const processItems = (items) => {
                items.forEach(item => {
                  if (item.downstream) {
                    item.downstream.forEach(targetId => {
                      itemsWithUpstream.add(targetId);
                    });
                  }
                });
              };
              if (group.schemas) {
                group.schemas.forEach(schema => processItems(schema.items));
              } else if (group.items) {
                processItems(group.items);
              }
            });
          });
        }
        
        allItems.forEach(item => {
          if (item.downstream && item.downstream.length > 0) {
            item.downstream.forEach(targetItemId => {
              
              const sourceMapping = itemToHandleMap.get(item.id);
              const targetMapping = itemToHandleMap.get(targetItemId);
              
              if (sourceMapping && targetMapping) {
                // Find target item data for edge info
                const targetItem = allItems.find(i => i.id === targetItemId);
                
                // Look up edge metadata from objectEdges if available
                const edgeMeta = window.getEdgeMetadata ? window.getEdgeMetadata(item.id, targetItemId) : null;
                
                edges.push({
                  id: `edge-${item.id}-${targetItemId}`,
                  source: sourceMapping.nodeId,
                  sourceHandle: sourceMapping.sourceHandle,
                  target: targetMapping.nodeId,
                  targetHandle: targetMapping.targetHandle,
                  type: 'default',
                  animated: false,
                  markerEnd: {
                    type: MarkerType.ArrowClosed,
                    width: 12,
                    height: 12,
                    color: '#BDC4D5',
                  },
                  data: {
                    sourceItemId: item.id,
                    targetItemId: targetItemId,
                    sourceItem: item,
                    targetItem: targetItem,
                    // Include edge metadata
                    queryType: edgeMeta?.queryType || null,
                    runBy: edgeMeta?.runBy || null,
                    runOn: edgeMeta?.runOn || null,
                    duration: edgeMeta?.duration || null,
                    queryId: edgeMeta?.queryId || null,
                    rowCount: edgeMeta?.rowCount || null,
                    sqlQuery: edgeMeta?.sqlQuery || null,
                    externalTool: edgeMeta?.externalTool || null,
                    storedProcedures: edgeMeta?.storedProcedures || null,
                    tasks: edgeMeta?.tasks || null,
                  },
                });
              }
            });
          }
        });

        // Compute leaf status for each item and update nodes
        // An item is a leaf-upstream if it has NO upstream connections (not in anyone's downstream)
        // An item is a leaf-downstream if it has NO downstream connections
        const leafStatus = new Map();
        allItems.forEach(item => {
          leafStatus.set(item.id, {
            isLeafUpstream: !itemsWithUpstream.has(item.id),
            isLeafDownstream: !item.downstream || item.downstream.length === 0
          });
        });

        // Update nodes' items with leaf status
        nodes.forEach(node => {
          if (node.data.items) {
            node.data.items = node.data.items.map(item => ({
              ...item,
              isLeafUpstream: leafStatus.get(item.id)?.isLeafUpstream || false,
              isLeafDownstream: leafStatus.get(item.id)?.isLeafDownstream || false
            }));
          }
        });

        return { nodes, edges, allItems };
      }

      // =============================================
      // Main Graph Component
      // =============================================
      function LineageGraph() {
        const [nodes, setNodes, onNodesChange] = useNodesState([]);
        const [edges, setEdges, onEdgesChange] = useEdgesState([]);
        const [selectedItem, setSelectedItem] = useState(null);
        const [isLoading, setIsLoading] = useState(true);
        const [collapseState, setCollapseState] = useState({}); // { nodeId: { dbCollapsed, schemaCollapsed, collapsed } }
        
        // New state for column/feature expansion
        const [expandedItems, setExpandedItems] = useState({}); // { itemId: boolean }
        const [itemSearchQueries, setItemSearchQueries] = useState({}); // { itemId: string }
        const [selectedChildren, setSelectedChildren] = useState({}); // { itemId: Set<string> }
        const [hoveredChild, setHoveredChild] = useState(null); // { itemId, childName }
        const [showAllColumnsItems, setShowAllColumnsItems] = useState({}); // { itemId: boolean } - show all columns in lineage mode
        const [itemActiveTabs, setItemActiveTabs] = useState({}); // { itemId: 'features' | 'outputs' } - active tab for model items
        
        // Edge selection state
        const [selectedEdge, setSelectedEdge] = useState(null); // { id, sourceItemId, targetItemId, sourceItem, targetItem }
        const [adjacentItemIds, setAdjacentItemIds] = useState(new Set()); // Set of item IDs adjacent to selected edge
        
        // Column lineage mode state
        const [columnLineageMode, setColumnLineageMode] = useState(false);
        const [selectedColumnLineage, setSelectedColumnLineage] = useState(null); // { itemId, columnName }
        const [relatedColumns, setRelatedColumns] = useState(new Map()); // Map<itemId, Set<columnName>>
        const [columnLineageEdges, setColumnLineageEdges] = useState([]); // Additional edges for column lineage
        const [hoverPreviewEdges, setHoverPreviewEdges] = useState([]); // Preview edges on column hover
        const lineageVersionRef = React.useRef(0); // Track lineage version to avoid stale updates
        const relatedColumnsRef = React.useRef(new Map()); // Ref for relatedColumns to avoid stale closures
        const selectedColumnLineageRef = React.useRef(null); // Ref for selectedColumnLineage to avoid stale closures
        
        // Per-node expansion state for hover button actions
        // expandedUpstream: Set of node IDs whose upstream connections are visible
        // expandedDownstream: Set of node IDs whose downstream connections are visible
        const [expandedUpstream, setExpandedUpstream] = useState(new Set());
        const [expandedDownstream, setExpandedDownstream] = useState(new Set());
        
        const reactFlowInstance = useReactFlow();
        const updateNodeInternals = useUpdateNodeInternals ? useUpdateNodeInternals() : null;

        // Calculate node height based on collapse state and expanded items
        const calculateNodeHeight = useCallback((nodeType, items, collapseInfo, expandedItemsState, selectedItemId, columnLineageModeState, sourceColumnState, relatedColumnsState) => {
          const itemHeight = 40;
          const expandedItemHeight = 420; // Height when item is expanded with columns list (header + search + list + button + margins)
          const columnLineageExpandedHeight = 340; // Height in column lineage mode (no search input, no margins)
          const selectedItemHeight = 100; // Height when item is selected but not expanded (card + margins)
          const dbHeaderHeight = 32;
          const schemaHeaderHeight = 40;
          const schemaPadding = 16;
          const containerPadding = 16;
          
          // Calculate total items height accounting for expanded/selected items
          const calculateItemsHeight = (itemsList) => {
            let height = 0;
            itemsList.forEach(item => {
              const isSelected = selectedItemId === item.id;
              const isExpanded = expandedItemsState?.[item.id] || false;
              const hasChildren = item.columns?.length > 0 || item.features?.length > 0;
              
              // Check if this item is involved in column lineage
              const isInColumnLineage = columnLineageModeState && (
                sourceColumnState?.itemId === item.id || 
                relatedColumnsState?.has?.(item.id)
              );
              
              // Item is expanded if: (selected AND expanded) OR (in column lineage AND expanded)
              if ((isSelected || isInColumnLineage) && hasChildren && isExpanded) {
                // Use smaller height for column lineage mode (no search input, no margins)
                height += isInColumnLineage ? columnLineageExpandedHeight : expandedItemHeight;
              } else if (isSelected && hasChildren) {
                height += selectedItemHeight;
              } else {
                height += itemHeight;
              }
            });
            return height;
          };
          
          if (nodeType === 'groupNode') {
            if (collapseInfo?.dbCollapsed) {
              return dbHeaderHeight + containerPadding;
            }
            if (collapseInfo?.schemaCollapsed) {
              return dbHeaderHeight + schemaHeaderHeight + schemaPadding + containerPadding;
            }
            const itemsHeight = calculateItemsHeight(items || []);
            return dbHeaderHeight + schemaHeaderHeight + itemsHeight + schemaPadding + containerPadding + 24;
          }
          
          if (nodeType === 'platformGroup') {
            // Platform nodes use same structure as group nodes:
            // container > db-header > schema-section > schema-header > items
            if (collapseInfo?.collapsed) {
              return dbHeaderHeight + containerPadding;
            }
            if (collapseInfo?.schemaCollapsed) {
              return dbHeaderHeight + schemaHeaderHeight + schemaPadding + containerPadding;
            }
            const itemsHeight = calculateItemsHeight(items || []);
            // Same formula as groupNode since they share the same DOM structure
            return dbHeaderHeight + schemaHeaderHeight + itemsHeight + schemaPadding + containerPadding + 24;
          }
          
          return 100;
        }, []);

        // Handle toggle collapse for database header
        const handleToggleDbCollapse = useCallback((nodeId) => {
          setCollapseState(prev => ({
            ...prev,
            [nodeId]: {
              ...prev[nodeId],
              dbCollapsed: !prev[nodeId]?.dbCollapsed
            }
          }));
        }, []);

        // Handle toggle collapse for schema header
        const handleToggleSchemaCollapse = useCallback((nodeId) => {
          setCollapseState(prev => ({
            ...prev,
            [nodeId]: {
              ...prev[nodeId],
              schemaCollapsed: !prev[nodeId]?.schemaCollapsed
            }
          }));
        }, []);

        // Handle toggle collapse for platform header
        const handleTogglePlatformCollapse = useCallback((nodeId) => {
          setCollapseState(prev => ({
            ...prev,
            [nodeId]: {
              ...prev[nodeId],
              collapsed: !prev[nodeId]?.collapsed
            }
          }));
        }, []);

        // Track which node to center on after expansion/collapse
        const [centerOnAfterLayout, setCenterOnAfterLayout] = useState(null);
        
        // Handle expand/collapse per-node lineage
        const handleExpandUpstream = useCallback((itemId) => {
          // Get the upstream connections of this item to find what will be newly visible
          const upstreamMap = computeUpstreamMap(window.mockLineageData);
          const upstreamItems = upstreamMap.get(itemId) || [];
          // Center on the first upstream item that will be added
          if (upstreamItems.length > 0) {
            setCenterOnAfterLayout({ itemId: upstreamItems[0], direction: 'upstream' });
          }
          setExpandedUpstream(prev => {
            const next = new Set(prev);
            next.add(itemId);
            return next;
          });
        }, []);
        
        const handleCollapseUpstream = useCallback((itemId) => {
          // Center on the item that was clicked (the one whose upstream is being collapsed)
          setCenterOnAfterLayout({ itemId: itemId, direction: 'collapse' });
          setExpandedUpstream(prev => {
            const next = new Set(prev);
            next.delete(itemId);
            return next;
          });
        }, []);
        
        const handleExpandDownstream = useCallback((itemId) => {
          // Find the item's downstream connections
          let downstreamItems = [];
          window.mockLineageData.depths.forEach(depth => {
            depth.groups.forEach(group => {
              const processItems = (items) => {
                items.forEach(item => {
                  if (item.id === itemId && item.downstream) {
                    downstreamItems = item.downstream;
                  }
                });
              };
              if (group.schemas) {
                group.schemas.forEach(schema => processItems(schema.items));
              } else if (group.items) {
                processItems(group.items);
              }
            });
          });
          // Center on the first downstream item that will be added
          if (downstreamItems.length > 0) {
            setCenterOnAfterLayout({ itemId: downstreamItems[0], direction: 'downstream' });
          }
          setExpandedDownstream(prev => {
            const next = new Set(prev);
            next.add(itemId);
            return next;
          });
        }, []);
        
        const handleCollapseDownstream = useCallback((itemId) => {
          // Center on the item that was clicked (the one whose downstream is being collapsed)
          setCenterOnAfterLayout({ itemId: itemId, direction: 'collapse' });
          setExpandedDownstream(prev => {
            const next = new Set(prev);
            next.delete(itemId);
            return next;
          });
        }, []);

        // Handle toggle item children expansion (columns/features)
        const handleToggleItemExpand = useCallback((itemId) => {
          setExpandedItems(prev => ({
            ...prev,
            [itemId]: !prev[itemId]
          }));
        }, []);

        // Handle toggle show all columns (in column lineage mode)
        const handleShowAllColumns = useCallback((itemId) => {
          setShowAllColumnsItems(prev => ({
            ...prev,
            [itemId]: !prev[itemId]
          }));
        }, []);

        // Handle tab change for model items (features/outputs)
        const handleTabChange = useCallback((itemId, tab) => {
          setItemActiveTabs(prev => ({
            ...prev,
            [itemId]: tab
          }));
        }, []);

        // Handle item search query change
        const handleItemSearchChange = useCallback((itemId, query) => {
          setItemSearchQueries(prev => ({
            ...prev,
            [itemId]: query
          }));
        }, []);

        // Handle child (column/feature) click - enters column lineage mode
        const handleChildClick = useCallback((itemId, childName) => {
          // Check if clicking the same column again - exit lineage mode
          if (columnLineageMode && selectedColumnLineage?.itemId === itemId && selectedColumnLineage?.columnName === childName) {
            exitColumnLineageMode();
            return;
          }
          
          // Find all related columns using the columnLineage data
          const lineage = window.columnLineage || [];
          
          // Recursively find all upstream and downstream columns
          const findAllRelatedColumns = (sourceItemId, sourceColumnName) => {
            const related = new Map();
            const visited = new Set();
            const queue = [{ itemId: sourceItemId, columnName: sourceColumnName, direction: 'both' }];
            
            while (queue.length > 0) {
              const current = queue.shift();
              const key = `${current.itemId}:${current.columnName}`;
              
              if (visited.has(key)) continue;
              visited.add(key);
              
              // Find upstream (sources)
              if (current.direction === 'both' || current.direction === 'upstream') {
                lineage.forEach(edge => {
                  if (edge.targetTable === current.itemId && edge.targetColumn === current.columnName) {
                    const upstreamKey = `${edge.sourceTable}:${edge.sourceColumn}`;
                    if (!visited.has(upstreamKey)) {
                      if (!related.has(edge.sourceTable)) {
                        related.set(edge.sourceTable, new Set());
                      }
                      related.get(edge.sourceTable).add(edge.sourceColumn);
                      queue.push({ itemId: edge.sourceTable, columnName: edge.sourceColumn, direction: 'upstream' });
                    }
                  }
                });
              }
              
              // Find downstream (targets)
              if (current.direction === 'both' || current.direction === 'downstream') {
                lineage.forEach(edge => {
                  if (edge.sourceTable === current.itemId && edge.sourceColumn === current.columnName) {
                    const downstreamKey = `${edge.targetTable}:${edge.targetColumn}`;
                    if (!visited.has(downstreamKey)) {
                      if (!related.has(edge.targetTable)) {
                        related.set(edge.targetTable, new Set());
                      }
                      related.get(edge.targetTable).add(edge.targetColumn);
                      queue.push({ itemId: edge.targetTable, columnName: edge.targetColumn, direction: 'downstream' });
                    }
                  }
                });
              }
            }
            
            return related;
          };
          
          const related = findAllRelatedColumns(itemId, childName);
          
          // Find the parent item and column data for side panel
          const itemMap = window.buildItemMap ? window.buildItemMap(window.mockLineageData) : new Map();
          const parentItem = itemMap.get(itemId);
          const columnData = parentItem?.columns?.find(c => c.name === childName) || 
                             parentItem?.features?.find(f => f.name === childName) ||
                             { name: childName };
          
          // Update side panel with column details
          if (window.sharedSelection) {
            window.sharedSelection.updateColumnSidePanel(columnData, parentItem);
          }
          
          // If no related columns found, exit lineage mode and clear all selections
          if (related.size === 0) {
            // Exit column lineage mode if active
            if (columnLineageMode) {
              exitColumnLineageMode();
            } else {
              // Just clear existing selections and select this column only
              setExpandedItems({ [itemId]: true });
              setSelectedChildren({ [itemId]: new Set([childName]) });
            }
            
            // Always clear edge selection state and reset edge styles
            setSelectedEdge(null);
            setAdjacentItemIds(new Set());
            setEdges(eds => eds.map(e => ({
              ...e,
              selected: false,
              zIndex: 0,
              markerEnd: {
                ...e.markerEnd,
                color: '#BDC4D5',
              },
            })));
            
            // Center view on the parent node containing the column
            if (reactFlowInstance) {
              const allNodes = reactFlowInstance.getNodes();
              const targetNode = allNodes.find(node => {
                if (node.data?.items) {
                  return node.data.items.some(item => item.id === itemId);
                }
                return false;
              });
              
              if (targetNode) {
                // Use responsive zoom level for consistency with initial load
                const zoomLevel = window.innerWidth < 1112 ? 0.75 : 1;
                const x = targetNode.position.x + (targetNode.width || 304) / 2;
                const y = targetNode.position.y + (targetNode.height || 100) / 2;
                reactFlowInstance.setCenter(x, y, { zoom: zoomLevel, duration: 300 });
              }
            }
            return;
          }
          
          // Increment version to invalidate any pending edge updates
          lineageVersionRef.current += 1;
          
          // DON'T clear edges immediately - keep old edges visible until new ones are ready
          // This avoids the "flash of no edges" problem
          
          // Enter column lineage mode
          setColumnLineageMode(true);
          const newSelectedColumnLineage = { itemId, columnName: childName };
          setSelectedColumnLineage(newSelectedColumnLineage);
          setRelatedColumns(related);
          
          // Update refs immediately for use in setTimeout callbacks
          selectedColumnLineageRef.current = newSelectedColumnLineage;
          relatedColumnsRef.current = related;
          
          // Clear item selection
          setSelectedItem(null);
          if (window.sharedSelection) {
            window.sharedSelection.setSelection(null, null);
          }
          
          // Always clear edge selection state and reset edge styles
          setSelectedEdge(null);
          setAdjacentItemIds(new Set());
          setEdges(eds => eds.map(e => ({
            ...e,
            selected: false,
            zIndex: 0,
            markerEnd: {
              ...e.markerEnd,
              color: '#BDC4D5',
            },
          })));
          
          // Set up expanded items and selected children for lineage view
          const newExpandedItems = { [itemId]: true };
          const newSelectedChildren = { [itemId]: new Set([childName]) };
          
          related.forEach((columns, relatedItemId) => {
            newExpandedItems[relatedItemId] = true;
            newSelectedChildren[relatedItemId] = columns;
          });
          
          setExpandedItems(newExpandedItems);
          setSelectedChildren(newSelectedChildren);
          
          // Center view on the parent node containing the selected column
          if (reactFlowInstance) {
            const allNodes = reactFlowInstance.getNodes();
            const targetNode = allNodes.find(node => {
              if (node.data?.items) {
                return node.data.items.some(item => item.id === itemId);
              }
              return false;
            });
            
            if (targetNode) {
              // Use responsive zoom level for consistency with initial load
              const zoomLevel = window.innerWidth < 1112 ? 0.75 : 1;
              const x = targetNode.position.x + (targetNode.width || 304) / 2;
              const y = targetNode.position.y + (targetNode.height || 100) / 2;
              reactFlowInstance.setCenter(x, y, { zoom: zoomLevel, duration: 300 });
            }
          }
          
          // Edge creation is handled by useEffect below after render
          
        }, [columnLineageMode, selectedColumnLineage, reactFlowInstance, setEdges]);
        
        // Listen for column lineage trigger from hover action buttons
        useEffect(() => {
          const handleTriggerColumnLineage = (e) => {
            const { itemId, columnName } = e.detail;
            if (itemId && columnName) {
              handleChildClick(itemId, columnName);
            }
          };
          
          window.addEventListener('triggerColumnLineage', handleTriggerColumnLineage);
          return () => {
            window.removeEventListener('triggerColumnLineage', handleTriggerColumnLineage);
          };
        }, [handleChildClick]);
        
        // Create column lineage edges AFTER items are expanded (handles must exist first)
        // Uses polling approach to handle rapid column switches
        useEffect(() => {
          if (!columnLineageMode || !selectedColumnLineage || !reactFlowInstance) {
            return;
          }
          
          const currentVersion = lineageVersionRef.current;
          let cancelled = false;
          let retryCount = 0;
          const maxRetries = 20; // Increased to handle node data + handle readiness
          const retryDelays = [20, 40, 60, 80, 100, 120, 150, 180, 220, 260, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750]; // Progressive delays
          
          console.log('Column lineage edge effect triggered. Version:', currentVersion, 
            'Column:', selectedColumnLineage?.itemId + '.' + selectedColumnLineage?.columnName);
          
          // AGGRESSIVE FIX: Force React Flow to rebuild its internal handle/edge registry
          // by temporarily removing ALL edges AND forcing a node refresh
          // This fixes the issue where React Flow's handle cache doesn't update for dynamic handles
          const currentEdges = reactFlowInstance.getEdges();
          const baseEdges = currentEdges.filter(e => !e.data?.isColumnLineage);
          
          // Step 1: Clear ALL edges to reset React Flow's internal state
          console.log('Clearing all edges to reset React Flow internal state. Base edges to restore:', baseEdges.length);
          setEdges([]);
          setColumnLineageEdges([]);
          
          // Step 2: Force React Flow to refresh its node/handle registry
          // Use updateNodeInternals API if available (proper way to update handles)
          // Also do a position nudge as fallback
          const currentNodes = reactFlowInstance.getNodes();
          const nodeIds = currentNodes.map(n => n.id);
          
          if (updateNodeInternals) {
            console.log('Using updateNodeInternals to refresh handle registry for', nodeIds.length, 'nodes');
            // Update internals for all nodes to refresh handle positions
            nodeIds.forEach(nodeId => {
              updateNodeInternals(nodeId);
            });
          }
          
          // Also do position nudge as additional measure
          const refreshedNodes = currentNodes.map(n => ({
            ...n,
            position: { x: n.position.x + 0.001, y: n.position.y + 0.001 }
          }));
          setNodes(refreshedNodes);
          
          // Reset positions after a tick
          setTimeout(() => {
            if (cancelled || lineageVersionRef.current !== currentVersion) return;
            const resetNodes = reactFlowInstance.getNodes().map(n => ({
              ...n,
              position: { x: Math.round(n.position.x), y: Math.round(n.position.y) }
            }));
            setNodes(resetNodes);
            
            // Call updateNodeInternals again after position reset
            if (updateNodeInternals) {
              nodeIds.forEach(nodeId => {
                updateNodeInternals(nodeId);
              });
            }
          }, 10);
          
          const createEdges = () => {
            // Skip if cancelled or version changed
            if (cancelled || lineageVersionRef.current !== currentVersion) {
              console.log('Skipping edge creation - cancelled:', cancelled, 'version mismatch:', lineageVersionRef.current !== currentVersion);
              return;
            }
            
            // Use refs to get the LATEST values (avoids stale closure issues)
            const currentSelectedColumn = selectedColumnLineageRef.current;
            const currentRelatedColumns = relatedColumnsRef.current;
            
            // Double-check we still have valid data
            if (!currentSelectedColumn || !currentRelatedColumns) {
              console.log('No selected column or related columns, skipping edge creation');
              return;
            }
            
            const { itemId, columnName: childName } = currentSelectedColumn;
            const lineage = window.columnLineage || [];
            
            // Build a map from item ID to node ID by checking current nodes
            const itemToNodeMap = new Map();
            const currentNodes = reactFlowInstance.getNodes() || [];
            currentNodes.forEach(node => {
              if (node.data?.items) {
                node.data.items.forEach(item => {
                  itemToNodeMap.set(item.id, node.id);
                });
              }
            });
            
            // Check if node data has been updated with the current sourceColumn
            // This is critical for same-table column switches where React batches updates
            const sourceNode = currentNodes.find(node => 
              node.data?.items?.some(item => item.id === itemId)
            );
            const nodeSourceColumn = sourceNode?.data?.sourceColumn;
            const nodeDataIsStale = !nodeSourceColumn || 
              nodeSourceColumn.itemId !== itemId || 
              nodeSourceColumn.columnName !== childName;
            
            if (nodeDataIsStale && retryCount < maxRetries) {
              retryCount++;
              const delay = retryDelays[Math.min(retryCount - 1, retryDelays.length - 1)];
              console.log(`Node data not yet updated (sourceColumn: ${nodeSourceColumn?.itemId}.${nodeSourceColumn?.columnName}, expected: ${itemId}.${childName}), retry ${retryCount}/${maxRetries} in ${delay}ms`);
              setTimeout(createEdges, delay);
              return;
            }
            
            // Check if at least the source column handle exists (indicates DOM is ready)
            const sourceColumnHandle = document.querySelector(`[data-handleid="column-out-${itemId}-${childName}"]`);
            
            // If source handle doesn't exist yet and we haven't exceeded retries, try again
            if (!sourceColumnHandle && retryCount < maxRetries) {
              retryCount++;
              const delay = retryDelays[Math.min(retryCount - 1, retryDelays.length - 1)];
              console.log(`Source handle not ready, retry ${retryCount}/${maxRetries} in ${delay}ms`);
              setTimeout(createEdges, delay);
              return;
            }
            
            console.log('Creating column lineage edges. Source:', itemId, childName, 'Retry count:', retryCount);
            console.log('Related columns:', Array.from(currentRelatedColumns.entries()).map(([k, v]) => [k, Array.from(v)]));
            
            const newColumnEdges = [];
            const visited = new Set();
            
            // Build edges for all related columns
            const addEdgesForColumn = (srcItemId, srcColumnName) => {
              const sourceNodeId = itemToNodeMap.get(srcItemId);
              if (!sourceNodeId) {
                console.log('  No node found for source:', srcItemId);
                return;
              }
              
              lineage.forEach(edge => {
                if (edge.sourceTable === srcItemId && edge.sourceColumn === srcColumnName) {
                  // Check if target is in our related set OR is the originally selected column
                  const isTargetRelated = currentRelatedColumns.has(edge.targetTable) && currentRelatedColumns.get(edge.targetTable).has(edge.targetColumn);
                  const isTargetSelected = edge.targetTable === itemId && edge.targetColumn === childName;
                  
                  if (isTargetRelated || isTargetSelected) {
                    const targetNodeId = itemToNodeMap.get(edge.targetTable);
                    if (!targetNodeId) {
                      console.log('  No node found for target:', edge.targetTable);
                      return;
                    }
                    
                    // Include version in edge ID to ensure React Flow updates edges when switching columns
                    // This prevents React Flow from reusing stale edge paths when handles change
                    const edgeId = `column-edge-v${currentVersion}-${edge.id}`;
                    if (!visited.has(edgeId)) {
                      visited.add(edgeId);
                      
                      // Check if handles exist in DOM
                      const sourceHandleId = `column-out-${srcItemId}-${srcColumnName}`;
                      const targetHandleId = `column-in-${edge.targetTable}-${edge.targetColumn}`;
                      const sourceHandle = document.querySelector(`[data-handleid="${sourceHandleId}"]`);
                      const targetHandle = document.querySelector(`[data-handleid="${targetHandleId}"]`);
                      
                      // Track if any handles are missing - we'll need to retry
                      if (!sourceHandle || !targetHandle) {
                        console.log(`  Edge ${edge.id}: handles missing - source: ${!!sourceHandle} (${sourceHandleId}), target: ${!!targetHandle} (${targetHandleId})`);
                        // Mark that we have missing handles
                        if (!window._missingHandles) window._missingHandles = [];
                        window._missingHandles.push({ sourceHandleId, targetHandleId, sourceExists: !!sourceHandle, targetExists: !!targetHandle });
                        // Skip this edge - don't add edges without handles, React Flow won't render them
                        return;
                      }
                      
                      // Always use column handles - don't fall back to object handles
                      // Object handles don't connect visually to the column items
                      const actualSourceHandle = sourceHandleId;
                      const actualTargetHandle = targetHandleId;
                      
                      console.log(`  Adding edge ${edge.id}: ${sourceNodeId}/${sourceHandleId} -> ${targetNodeId}/${targetHandleId}`);
                      
                      newColumnEdges.push({
                        id: edgeId,
                        source: sourceNodeId,
                        sourceHandle: actualSourceHandle,
                        target: targetNodeId,
                        targetHandle: actualTargetHandle,
                        type: 'default',
                        animated: true,
                        className: 'column-lineage animated',
                        data: { transformType: edge.transformType },
                        markerEnd: {
                          type: MarkerType.ArrowClosed,
                          width: 14,
                          height: 14,
                          color: '#1A6CE7',
                        },
                        style: {
                          stroke: '#1A6CE7',
                          strokeWidth: 2,
                        },
                      });
                    }
                  }
                }
              });
            };
            
            // Reset missing handles tracker
            window._missingHandles = [];
            
            // Add edges from source column
            addEdgesForColumn(itemId, childName);
            
            // Add edges from all related columns (to get the full chain)
            currentRelatedColumns.forEach((columns, relatedItemId) => {
              columns.forEach(colName => {
                addEdgesForColumn(relatedItemId, colName);
              });
            });
            
            console.log('Column lineage edges created:', newColumnEdges.length, 'Missing handles:', window._missingHandles.length);
            
            // If handles are missing and we haven't exceeded retries, wait and try again
            if (window._missingHandles.length > 0 && retryCount < maxRetries) {
              retryCount++;
              const delay = retryDelays[Math.min(retryCount - 1, retryDelays.length - 1)];
              console.log(`Handles missing for ${window._missingHandles.length} edges, retry ${retryCount}/${maxRetries} in ${delay}ms`);
              setTimeout(createEdges, delay);
              return;
            }
            
            // Only update if we created edges or this is the final attempt
            if (newColumnEdges.length > 0 || retryCount >= maxRetries) {
              console.log('Setting column lineage edges:', newColumnEdges.map(e => e.id));
              
              // Mark these edges as column lineage edges so we can identify them later
              // Use timestamp in edge ID to force React Flow to treat them as new edges
              // This prevents React Flow's edge path caching from using stale paths
              const timestamp = Date.now();
              const markedEdges = newColumnEdges.map(e => ({ 
                ...e, 
                id: `${e.id}-t${timestamp}`,
                data: { ...e.data, isColumnLineage: true } 
              }));
              
              // Add column lineage edges directly to React Flow's edge state
              // Use the baseEdges captured at effect start (before we cleared all edges)
              // This ensures React Flow properly manages them internally
              console.log('Restoring base edges:', baseEdges.length, 'Adding lineage edges:', markedEdges.length);
              setEdges([...baseEdges, ...markedEdges]);
              
              // Debug: Check immediately after setting edges
              setTimeout(() => {
                debugColumnLineageEdges('Immediately after setEdges');
              }, 50);
              
              // Also update our local state for combinedEdges calculation
              setColumnLineageEdges(newColumnEdges);
              
              // Schedule one more update to ensure edges are positioned correctly after handles settle
              if (!cancelled && lineageVersionRef.current === currentVersion) {
                setTimeout(() => {
                  if (!cancelled && lineageVersionRef.current === currentVersion) {
                    console.log('Final edge refresh');
                    
                    // Debug: Check if handles actually exist in DOM now
                    newColumnEdges.forEach(edge => {
                      const srcHandle = document.querySelector(`[data-handleid="${edge.sourceHandle}"]`);
                      const tgtHandle = document.querySelector(`[data-handleid="${edge.targetHandle}"]`);
                      console.log(`  Edge ${edge.id}: src handle exists: ${!!srcHandle}, tgt handle exists: ${!!tgtHandle}`);
                      if (srcHandle) {
                        const rect = srcHandle.getBoundingClientRect();
                        console.log(`    Src handle position: ${rect.left}, ${rect.top}, ${rect.width}x${rect.height}`);
                      }
                      if (tgtHandle) {
                        const rect = tgtHandle.getBoundingClientRect();
                        console.log(`    Tgt handle position: ${rect.left}, ${rect.top}, ${rect.width}x${rect.height}`);
                      }
                    });
                    
                    // Force React Flow to recalculate edge paths by creating NEW edge objects with fresh IDs
                    // This is critical - React Flow caches edge paths and won't recalculate if edge IDs are the same
                    const refreshTimestamp = Date.now();
                    const refreshedEdges = markedEdges.map(e => ({
                      ...e,
                      // Use timestamp suffix to force React Flow to treat as completely new edges
                      id: `${e.id}-t${refreshTimestamp}`,
                    }));
                    
                    // Use captured baseEdges, not current edges (which may be stale)
                    setEdges([...baseEdges, ...refreshedEdges]);
                    setColumnLineageEdges([...newColumnEdges]);
                    
                    // Also trigger a minor viewport nudge to force React Flow to recalculate
                    if (reactFlowInstance) {
                      const viewport = reactFlowInstance.getViewport();
                      // Nudge viewport by tiny amount and back to force edge recalculation
                      reactFlowInstance.setViewport({ ...viewport, x: viewport.x + 0.01 }, { duration: 0 });
                      setTimeout(() => {
                        reactFlowInstance.setViewport(viewport, { duration: 0 });
                      }, 10);
                    }
                    
                    // Debug: Comprehensive check for rendered column lineage edges
                    setTimeout(() => {
                      debugColumnLineageEdges('After final refresh');
                    }, 100);
                  }
                }, 150);
              }
            } else if (retryCount < maxRetries) {
              // No edges created but might be because handles aren't ready - retry
              retryCount++;
              const delay = retryDelays[Math.min(retryCount - 1, retryDelays.length - 1)];
              console.log(`No edges created, retry ${retryCount}/${maxRetries} in ${delay}ms`);
              setTimeout(createEdges, delay);
            }
          };
          
          // Start edge creation with a delay to let React Flow update its handle registry
          // The delay needs to be after the node position reset (10ms) + some buffer
          const initialTimeoutId = setTimeout(createEdges, 50);
          
          // Also schedule multiple backup edge creations in case earlier ones fail
          // This helps ensure edges are always created when switching columns
          const backupTimeoutId1 = setTimeout(() => {
            if (!cancelled && lineageVersionRef.current === currentVersion) {
              console.log('Backup edge creation triggered (500ms)');
              createEdges();
            }
          }, 500);
          
          const backupTimeoutId2 = setTimeout(() => {
            if (!cancelled && lineageVersionRef.current === currentVersion) {
              console.log('Backup edge creation triggered (1000ms)');
              createEdges();
            }
          }, 1000);
          
          return () => {
            cancelled = true;
            clearTimeout(initialTimeoutId);
            clearTimeout(backupTimeoutId1);
            clearTimeout(backupTimeoutId2);
          };
        }, [columnLineageMode, selectedColumnLineage, relatedColumns, expandedItems, reactFlowInstance, setEdges]);
        
        // Exit column lineage mode
        const exitColumnLineageMode = useCallback(() => {
          setColumnLineageMode(false);
          setSelectedColumnLineage(null);
          setRelatedColumns(new Map());
          setColumnLineageEdges([]);
          // Remove column lineage edges from React Flow's edge state
          setEdges(currentEdges => currentEdges.filter(e => !e.data?.isColumnLineage));
          setExpandedItems({});
          setSelectedChildren({});
          setShowAllColumnsItems({}); // Reset show all columns state
          // Clear refs
          selectedColumnLineageRef.current = null;
          relatedColumnsRef.current = new Map();
        }, [setEdges]);

        // Handle child hover - show preview of column lineage edges
        const handleChildHover = useCallback((itemId, childName) => {
          if (childName) {
            setHoveredChild({ itemId, childName });
            
            // Don't show preview if already in column lineage mode
            if (columnLineageMode) {
              setHoverPreviewEdges([]);
              return;
            }
            
            // Create preview edges for direct upstream (-1) and downstream (+1) connections
            const lineage = window.columnLineage || [];
            const currentNodes = reactFlowInstance?.getNodes() || [];
            
            // Build a map from item ID to node ID and handles
            const itemToNodeMap = new Map();
            currentNodes.forEach(node => {
              if (node.data?.items) {
                node.data.items.forEach(item => {
                  itemToNodeMap.set(item.id, {
                    nodeId: node.id,
                    leftHandle: `left-${item.id}`,
                    rightHandle: `right-${item.id}`
                  });
                });
              }
            });
            
            const sourceInfo = itemToNodeMap.get(itemId);
            if (!sourceInfo) {
              setHoverPreviewEdges([]);
              return;
            }
            
            const previewEdges = [];
            const addedEdges = new Set(); // Track unique edges
            
            // Find direct downstream connections (this column -> other columns)
            // Use object handles for preview (column handles only exist in lineage mode)
            lineage.forEach(edge => {
              if (edge.sourceTable === itemId && edge.sourceColumn === childName) {
                const targetInfo = itemToNodeMap.get(edge.targetTable);
                if (targetInfo) {
                  const edgeKey = `${sourceInfo.nodeId}-${targetInfo.nodeId}`;
                  if (!addedEdges.has(edgeKey)) {
                    addedEdges.add(edgeKey);
                    previewEdges.push({
                      id: `preview-down-${edge.id}`,
                      source: sourceInfo.nodeId,
                      sourceHandle: sourceInfo.rightHandle,
                      target: targetInfo.nodeId,
                      targetHandle: targetInfo.leftHandle,
                      type: 'default',
                      animated: true,
                      className: 'column-lineage-preview',
                      markerEnd: {
                        type: MarkerType.ArrowClosed,
                        width: 10,
                        height: 10,
                        color: '#D5DAE4',
                      },
                      style: {
                        stroke: '#D5DAE4',
                        strokeWidth: 1,
                      },
                    });
                  }
                }
              }
              
              // Find direct upstream connections (other columns -> this column)
              if (edge.targetTable === itemId && edge.targetColumn === childName) {
                const upstreamInfo = itemToNodeMap.get(edge.sourceTable);
                if (upstreamInfo) {
                  const edgeKey = `${upstreamInfo.nodeId}-${sourceInfo.nodeId}`;
                  if (!addedEdges.has(edgeKey)) {
                    addedEdges.add(edgeKey);
                    previewEdges.push({
                      id: `preview-up-${edge.id}`,
                      source: upstreamInfo.nodeId,
                      sourceHandle: upstreamInfo.rightHandle,
                      target: sourceInfo.nodeId,
                      targetHandle: sourceInfo.leftHandle,
                      type: 'default',
                      animated: true,
                      className: 'column-lineage-preview',
                      markerEnd: {
                        type: MarkerType.ArrowClosed,
                        width: 10,
                        height: 10,
                        color: '#D5DAE4',
                      },
                      style: {
                        stroke: '#D5DAE4',
                        strokeWidth: 1,
                      },
                    });
                  }
                }
              }
            });
            
            setHoverPreviewEdges(previewEdges);
          } else {
            setHoveredChild(null);
            setHoverPreviewEdges([]);
          }
        }, [columnLineageMode, reactFlowInstance]);

        // Handle item click - update shared selection, expand to show columns, and center view
        const handleItemClick = useCallback((item, nodeId) => {
          // Always clear ALL column lineage state (unconditionally)
          setColumnLineageMode(false);
          setSelectedColumnLineage(null);
          setRelatedColumns(new Map());
          setColumnLineageEdges([]);
          // Remove column lineage edges from React Flow's edge state
          setEdges(currentEdges => currentEdges.filter(e => !e.data?.isColumnLineage));
          setShowAllColumnsItems({});
          // Clear refs
          selectedColumnLineageRef.current = null;
          relatedColumnsRef.current = new Map();
          
          // Clear ALL previous selections and highlights
          setSelectedEdge(null);
          setAdjacentItemIds(new Set());
          setSelectedChildren({});
          setHoveredChild(null);
          setHoverPreviewEdges([]);
          
          // Reset edge styles to default
          setEdges(eds => eds.map(e => ({
            ...e,
            selected: false,
            zIndex: 0,
            className: '',
            animated: false,
            style: {},
            markerEnd: {
              type: MarkerType.ArrowClosed,
              width: 10,
              height: 10,
              color: '#BDC4D5',
            },
          })));
          
          // Set the new selected item
          setSelectedItem(item);
          
          // Reset expanded items - only expand the newly selected item (collapse all others)
          const hasChildren = item.columns?.length > 0 || item.features?.length > 0;
          setExpandedItems(hasChildren ? { [item.id]: true } : {});
          
          // Sync with global shared selection - pass all item data for side panel
          if (window.sharedSelection) {
            window.sharedSelection.setSelection(item.id, {
              id: item.id,
              name: item.name,
              icon: item.icon,
              database: item.database,
              schemaName: item.schemaName,
              schema: item.schema,
              platform: item.platform,
              sourceIcon: item.sourceIcon,
              platformIcon: item.platformIcon,
              objType: item.objType,
              columns: item.columns,
              features: item.features,
              outputs: item.outputs,
              description: item.description,
              comment: item.comment,
              owner: item.owner,
              createdAt: item.createdAt,
              rowCount: item.rowCount,
              dataQuality: item.dataQuality,
              tags: item.tags,
              downstream: item.downstream,
              upstream: item.upstream
            });
          }
          
          // Center view on the selected node (keep current zoom)
          if (reactFlowInstance && nodeId) {
            const node = reactFlowInstance.getNode(nodeId);
            if (node) {
              const currentZoom = reactFlowInstance.getZoom();
              const x = node.position.x + (node.width || 304) / 2;
              const y = node.position.y + (node.height || 40) / 2;
              reactFlowInstance.setCenter(x, y, { zoom: currentZoom, duration: 300 });
            }
          }
        }, [reactFlowInstance, setEdges]);

        // Handle edge click - select edge, deselect nodes/columns, highlight adjacent nodes
        const handleEdgeClick = useCallback((event, edge) => {
          event.stopPropagation();
          
          // Always clear ALL column lineage state (unconditionally)
          setColumnLineageMode(false);
          setSelectedColumnLineage(null);
          setRelatedColumns(new Map());
          setColumnLineageEdges([]);
          // Remove column lineage edges from React Flow's edge state
          setEdges(currentEdges => currentEdges.filter(e => !e.data?.isColumnLineage));
          setShowAllColumnsItems({});
          // Clear refs
          selectedColumnLineageRef.current = null;
          relatedColumnsRef.current = new Map();
          setHoveredChild(null);
          setHoverPreviewEdges([]);
          
          // Clear item selection
          setSelectedItem(null);
          setSelectedChildren({});
          setExpandedItems({});
          
          // Set selected edge
          const edgeData = edge.data || {};
          setSelectedEdge({
            id: edge.id,
            sourceItemId: edgeData.sourceItemId,
            targetItemId: edgeData.targetItemId,
            sourceItem: edgeData.sourceItem,
            targetItem: edgeData.targetItem,
          });
          
          // Set adjacent item IDs for highlighting
          const adjacent = new Set();
          if (edgeData.sourceItemId) adjacent.add(edgeData.sourceItemId);
          if (edgeData.targetItemId) adjacent.add(edgeData.targetItemId);
          setAdjacentItemIds(adjacent);
          
          // Update edges to mark selected edge (bring to top via CSS z-index)
          setEdges(eds => eds.map(e => ({
            ...e,
            selected: e.id === edge.id,
            zIndex: e.id === edge.id ? 1000 : 0,
            markerEnd: {
              ...e.markerEnd,
              color: e.id === edge.id ? '#1A6CE7' : '#BDC4D5',
            },
          })));
          
          // Update side panel with edge info
          if (window.sharedSelection && edgeData.sourceItem && edgeData.targetItem) {
            // Clear the regular selection first
            window.sharedSelection.selectedItemId = null;
            window.sharedSelection.selectedItemData = null;
            
            // Build edge metadata for the side panel
            const edgeMeta = {
              queryType: edgeData.queryType || null,
              runBy: edgeData.runBy || null,
              runOn: edgeData.runOn || edgeData.sourceItem?.createdAt || null,
              duration: edgeData.duration || null,
              queryId: edgeData.queryId || null,
              rowCount: edgeData.rowCount || null,
              sqlQuery: edgeData.sqlQuery || null,
              externalTool: edgeData.externalTool || null,
              storedProcedures: edgeData.storedProcedures || null,
              tasks: edgeData.tasks || null,
            };
            
            // Show edge info in side panel
            window.sharedSelection.updateEdgeSidePanel(edgeData.sourceItem, edgeData.targetItem, edgeMeta);
          }
          
          // Center view on the edge (midpoint between source and target nodes)
          if (reactFlowInstance) {
            const sourceNode = reactFlowInstance.getNode(edge.source);
            const targetNode = reactFlowInstance.getNode(edge.target);
            
            if (sourceNode && targetNode) {
              const currentZoom = reactFlowInstance.getZoom();
              
              // Calculate center points of source and target nodes
              const sourceX = sourceNode.position.x + (sourceNode.width || 304) / 2;
              const sourceY = sourceNode.position.y + (sourceNode.height || 100) / 2;
              const targetX = targetNode.position.x + (targetNode.width || 304) / 2;
              const targetY = targetNode.position.y + (targetNode.height || 100) / 2;
              
              // Calculate midpoint of the edge
              const midX = (sourceX + targetX) / 2;
              const midY = (sourceY + targetY) / 2;
              
              reactFlowInstance.setCenter(midX, midY, { zoom: currentZoom, duration: 300 });
            }
          }
        }, [setEdges, reactFlowInstance]);

        // Center on focal node when ReactFlow initializes and select the focal item
        const onInit = useCallback((instance) => {
          console.log('ReactFlow onInit called');
          setTimeout(() => {
            const allNodes = instance.getNodes();
            const focalNode = allNodes.find(n => 
              n.data.isFocal || 
              n.data.hasFocal || 
              n.data.items?.some(item => item.isFocal)
            );
            
            console.log('onInit - focalNode:', focalNode);
            
            if (focalNode) {
              const x = focalNode.position.x + (focalNode.data.width || 304) / 2;
              const y = focalNode.position.y + (focalNode.data.height || 100) / 2;
              
              // Select the focal item on initial load (this will open the side panel)
              const focalItem = focalNode.data.items?.find(item => item.isFocal) || focalNode.data.item;
              if (focalItem) {
                setSelectedItem(focalItem);
                
                // Auto-expand to show columns/features if it has any
                const hasChildren = focalItem.columns?.length > 0 || focalItem.features?.length > 0;
                if (hasChildren) {
                  setExpandedItems(prev => ({
                    ...prev,
                    [focalItem.id]: true
                  }));
                }
                
                // Sync with global shared selection (this opens the side panel)
                if (window.sharedSelection) {
                  window.sharedSelection.setSelection(focalItem.id, {
                    id: focalItem.id,
                    name: focalItem.name,
                    icon: focalItem.icon,
                    database: focalItem.database,
                    schemaName: focalItem.schemaName,
                    schema: focalItem.schema,
                    platform: focalItem.platform,
                    sourceIcon: focalItem.sourceIcon,
                    platformIcon: focalItem.platformIcon,
                    objType: focalItem.objType,
                    columns: focalItem.columns,
                    features: focalItem.features,
                    outputs: focalItem.outputs,
                    description: focalItem.description,
                    comment: focalItem.comment,
                    owner: focalItem.owner,
                    createdAt: focalItem.createdAt,
                    rowCount: focalItem.rowCount,
                    dataQuality: focalItem.dataQuality,
                    tags: focalItem.tags,
                    downstream: focalItem.downstream,
                    upstream: focalItem.upstream
                  });
                }
              }
              
              // Center after a short delay to allow side panel to open and layout to settle
              setTimeout(() => {
                // Use smaller zoom for narrower screens
                const zoomLevel = window.innerWidth < 1112 ? 0.75 : 1;
                console.log('onInit - centering to:', { x, y, zoomLevel });
                instance.setCenter(x, y, { zoom: zoomLevel, duration: 300 });
              }, 50);
            }
          }, 100);
        }, []);
        
        // Listen for selection changes from list view
        useEffect(() => {
          if (window.sharedSelection) {
            const handleSelectionChange = (itemId, itemData) => {
              if (itemId) {
                // Clear ALL column lineage state (same as handleItemClick)
                setColumnLineageMode(false);
                setSelectedColumnLineage(null);
                setRelatedColumns(new Map());
                setColumnLineageEdges([]);
                // Remove column lineage edges from React Flow's edge state
                setEdges(currentEdges => currentEdges.filter(e => !e.data?.isColumnLineage));
                setShowAllColumnsItems({});
                // Clear refs
                selectedColumnLineageRef.current = null;
                relatedColumnsRef.current = new Map();
                
                // Clear ALL previous selections and highlights
                setSelectedEdge(null);
                setAdjacentItemIds(new Set());
                setSelectedChildren({});
                setHoveredChild(null);
                setHoverPreviewEdges([]);
                
                // Reset edge styles to default
                setEdges(eds => eds.map(e => ({
                  ...e,
                  selected: false,
                  zIndex: 0,
                  className: '',
                  animated: false,
                  style: {},
                  markerEnd: {
                    type: MarkerType.ArrowClosed,
                    width: 10,
                    height: 10,
                    color: '#BDC4D5',
                  },
                })));
                
                // Set the new selected item
                setSelectedItem({ id: itemId, ...itemData });
                
                // Reset expanded items - only expand the newly selected item (collapse all others)
                const hasChildren = itemData?.columns?.length > 0 || itemData?.features?.length > 0;
                setExpandedItems(hasChildren ? { [itemId]: true } : {});
                
                // Center view on the selected node
                if (reactFlowInstance) {
                  // Find the node containing this item
                  const allNodes = reactFlowInstance.getNodes();
                  const targetNode = allNodes.find(node => {
                    // Check if this node contains the item
                    if (node.data.item?.id === itemId) return true;
                    if (node.data.items?.some(item => item.id === itemId)) return true;
                    return false;
                  });
                  
                  if (targetNode && targetNode.position) {
                    const posX = targetNode.position.x;
                    const posY = targetNode.position.y;
                    // Only center if we have valid coordinates
                    if (typeof posX === 'number' && typeof posY === 'number' && !isNaN(posX) && !isNaN(posY)) {
                      // Use responsive zoom level for consistency
                      const zoomLevel = window.innerWidth < 1112 ? 0.75 : 1;
                      const x = posX + (targetNode.width || targetNode.data.width || 304) / 2;
                      const y = posY + (targetNode.height || targetNode.data.height || 100) / 2;
                      reactFlowInstance.setCenter(x, y, { zoom: zoomLevel, duration: 300 });
                    }
                  }
                }
              } else {
                setSelectedItem(null);
              }
            };
            
            window.sharedSelection.addListener(handleSelectionChange);
            
            // Initialize with current selection if any
            if (window.sharedSelection.selectedItemId) {
              setSelectedItem({
                id: window.sharedSelection.selectedItemId,
                ...window.sharedSelection.selectedItemData
              });
            }
          }
        }, [reactFlowInstance]);

        // Initialize layout
        useEffect(() => {
          async function initLayout() {
            setIsLoading(true);
            
            // Read initial selection from shared state (may have been set by list view)
            const initialSelectedId = window.sharedSelection?.selectedItemId || selectedItem?.id;
            if (window.sharedSelection?.selectedItemId && !selectedItem) {
              setSelectedItem({
                id: window.sharedSelection.selectedItemId,
                ...window.sharedSelection.selectedItemData
              });
            }
            
            // Find focal node ID
            let focalId = null;
            window.mockLineageData.depths.forEach(depth => {
              depth.groups.forEach(group => {
                if (group.schemas) {
                  group.schemas.forEach(schema => {
                    schema.items.forEach(item => {
                      if (item.isFocal) focalId = item.id;
                    });
                  });
                } else if (group.items) {
                  group.items.forEach(item => {
                    if (item.isFocal) focalId = item.id;
                  });
                }
              });
            });
            
            // Initialize expansion state: focal node expanded in both directions
            const initialExpandedUpstream = new Set(focalId ? [focalId] : []);
            const initialExpandedDownstream = new Set(focalId ? [focalId] : []);
            setExpandedUpstream(initialExpandedUpstream);
            setExpandedDownstream(initialExpandedDownstream);
            
            // Compute visible nodes based on expansion
            const { visibleIds } = computeVisibleNodes(
              window.mockLineageData,
              initialExpandedUpstream,
              initialExpandedDownstream,
              focalId
            );
            
            // Filter data to only visible nodes
            const filteredData = filterDataByVisibility(window.mockLineageData, visibleIds);
            
            const { nodes: initialNodes, edges: initialEdges, allItems } = transformDataToNodesAndEdges(
              filteredData, 
              handleItemClick,
              initialSelectedId,
              {
                onToggleDbCollapse: handleToggleDbCollapse,
                onToggleSchemaCollapse: handleToggleSchemaCollapse,
                onTogglePlatformCollapse: handleTogglePlatformCollapse,
              }
            );
            
            try {
              const layoutedNodes = await calculateLayout(initialNodes, initialEdges);
              // Ensure selectedItemId and columnLeafStatus are set on all nodes
              const nodesWithSelection = layoutedNodes.map(node => ({
                ...node,
                data: {
                  ...node.data,
                  selectedItemId: initialSelectedId,
                  columnLeafStatus: columnLeafStatus
                }
              }));
              setNodes(nodesWithSelection);
              setEdges(initialEdges);
              
            } catch (error) {
              console.error('Layout error:', error);
              // Ensure selectedItemId and columnLeafStatus are set even on error
              const nodesWithSelection = initialNodes.map(node => ({
                ...node,
                data: {
                  ...node.data,
                  selectedItemId: initialSelectedId,
                  columnLeafStatus: columnLeafStatus
                }
              }));
              setNodes(nodesWithSelection);
              setEdges(initialEdges);
            }
            setIsLoading(false);
          }
          
          initLayout();
        // eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);

        // Re-layout when per-node expansion changes
        useEffect(() => {
          // Skip initial render (handled by initLayout)
          if (nodes.length === 0) return;
          
          async function relayoutOnExpansionChange() {
            const currentSelectedId = columnLineageMode ? null : (selectedItem?.id || window.sharedSelection?.selectedItemId);
            
            // Find focal node ID
            let focalId = null;
            window.mockLineageData.depths.forEach(depth => {
              depth.groups.forEach(group => {
                if (group.schemas) {
                  group.schemas.forEach(schema => {
                    schema.items.forEach(item => {
                      if (item.isFocal) focalId = item.id;
                    });
                  });
                } else if (group.items) {
                  group.items.forEach(item => {
                    if (item.isFocal) focalId = item.id;
                  });
                }
              });
            });
            
            // Compute visible nodes based on per-node expansion
            const { visibleIds } = computeVisibleNodes(
              window.mockLineageData,
              expandedUpstream,
              expandedDownstream,
              focalId
            );
            
            // Filter data to only visible nodes
            const filteredData = filterDataByVisibility(window.mockLineageData, visibleIds);
            
            const { nodes: newNodes, edges: newEdges } = transformDataToNodesAndEdges(
              filteredData, 
              handleItemClick,
              currentSelectedId,
              {
                onToggleDbCollapse: handleToggleDbCollapse,
                onToggleSchemaCollapse: handleToggleSchemaCollapse,
                onTogglePlatformCollapse: handleTogglePlatformCollapse,
              }
            );
            
            try {
              const layoutedNodes = await calculateLayout(newNodes, newEdges);
              
              // Get the current position of the focal node (or clicked node) before updating
              // This helps us maintain visual stability during layout changes
              let referenceNodeOldPos = null;
              let referenceItemId = focalId; // Use focal node as reference
              
              if (reactFlowInstance) {
                const currentNodes = reactFlowInstance.getNodes();
                for (const node of currentNodes) {
                  if (node.data.items) {
                    const itemIndex = node.data.items.findIndex(item => item.id === referenceItemId);
                    if (itemIndex !== -1) {
                      referenceNodeOldPos = {
                        x: node.position.x,
                        y: node.position.y
                      };
                      break;
                    }
                  }
                }
              }
              
              // Find the same reference node's new position after layout
              let referenceNodeNewPos = null;
              for (const node of layoutedNodes) {
                if (node.data.items) {
                  const itemIndex = node.data.items.findIndex(item => item.id === referenceItemId);
                  if (itemIndex !== -1) {
                    referenceNodeNewPos = {
                      x: node.position.x,
                      y: node.position.y
                    };
                    break;
                  }
                }
              }
              
              const nodesWithState = layoutedNodes.map(node => {
                const nodeCollapseInfo = collapseState[node.id] || {};
                return {
                  ...node,
                  data: {
                    ...node.data,
                    selectedItemId: currentSelectedId,
                    expandedItems: expandedItems,
                    itemSearchQueries: itemSearchQueries,
                    selectedChildren: selectedChildren,
                    onToggleItemExpand: handleToggleItemExpand,
                    onItemSearchChange: handleItemSearchChange,
                    onChildClick: handleChildClick,
                    onChildHover: handleChildHover,
                    columnLineageMode: columnLineageMode,
                    sourceColumn: selectedColumnLineage,
                    relatedColumns: relatedColumns,
                    columnLeafStatus: columnLeafStatus,
                    showAllColumnsItems: showAllColumnsItems,
                    onShowAllColumns: handleShowAllColumns,
                    itemActiveTabs: itemActiveTabs,
                    onTabChange: handleTabChange,
                    adjacentItemIds: adjacentItemIds,
                    dbCollapsed: !!nodeCollapseInfo.dbCollapsed,
                    schemaCollapsed: !!nodeCollapseInfo.schemaCollapsed,
                    collapsed: !!nodeCollapseInfo.collapsed,
                    onToggleDbCollapse: handleToggleDbCollapse,
                    onToggleSchemaCollapse: handleToggleSchemaCollapse,
                    onToggleCollapse: handleTogglePlatformCollapse,
                  }
                };
              });
              
              // If we have both old and new positions, compensate viewport immediately
              // This prevents the visual "jump" when layout shifts
              if (referenceNodeOldPos && referenceNodeNewPos && reactFlowInstance) {
                const deltaX = referenceNodeNewPos.x - referenceNodeOldPos.x;
                const deltaY = referenceNodeNewPos.y - referenceNodeOldPos.y;
                
                // Only compensate if there's a significant shift
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                  const viewport = reactFlowInstance.getViewport();
                  // Adjust viewport to compensate for layout shift (nodes moved, so move viewport same direction)
                  reactFlowInstance.setViewport({
                    x: viewport.x - deltaX * viewport.zoom,
                    y: viewport.y - deltaY * viewport.zoom,
                    zoom: viewport.zoom
                  }, { duration: 0 });
                }
              }
              
              setNodes(nodesWithState);
              setEdges(newEdges);
              
              // Center on the appropriate node after layout with smooth animation
              if (centerOnAfterLayout && reactFlowInstance) {
                setTimeout(() => {
                  const targetItemId = centerOnAfterLayout.itemId;
                  // Find the node containing this item
                  const allNodes = reactFlowInstance.getNodes();
                  let targetNode = null;
                  let itemPosition = null;
                  
                  for (const node of allNodes) {
                    if (node.data.items) {
                      const itemIndex = node.data.items.findIndex(item => item.id === targetItemId);
                      if (itemIndex !== -1) {
                        targetNode = node;
                        // Calculate position within the node (approximate item position)
                        const itemHeight = 40;
                        const headerHeight = node.type === 'groupNode' ? 72 : 72; // db + schema headers
                        itemPosition = {
                          x: node.position.x + (node.width || 340) / 2,
                          y: node.position.y + headerHeight + (itemIndex * itemHeight) + itemHeight / 2
                        };
                        break;
                      }
                    }
                  }
                  
                  if (targetNode && itemPosition) {
                    const currentZoom = reactFlowInstance.getZoom();
                    reactFlowInstance.setCenter(itemPosition.x, itemPosition.y, { 
                      zoom: currentZoom, 
                      duration: 300 
                    });
                  }
                  
                  // Clear the center target
                  setCenterOnAfterLayout(null);
                }, 50); // Reduced from 100ms since we now handle the instant shift
              }
            } catch (error) {
              console.error('Layout error on expansion change:', error);
              setNodes(newNodes);
              setEdges(newEdges);
            }
          }
          
          relayoutOnExpansionChange();
        // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [expandedUpstream, expandedDownstream, centerOnAfterLayout, reactFlowInstance]);

        // Update nodes when selection or expanded state changes
        useEffect(() => {
          const currentSelectedId = columnLineageMode ? null : (selectedItem?.id || window.sharedSelection?.selectedItemId);
          setNodes(nds => nds.map(node => {
            const nodeCollapseInfo = collapseState[node.id] || {};
            return {
              ...node,
              data: {
                ...node.data,
                selectedItemId: currentSelectedId,
                expandedItems: expandedItems,
                itemSearchQueries: itemSearchQueries,
                selectedChildren: selectedChildren,
                onToggleItemExpand: handleToggleItemExpand,
                onItemSearchChange: handleItemSearchChange,
                onChildClick: handleChildClick,
                onChildHover: handleChildHover,
                columnLineageMode: columnLineageMode,
                sourceColumn: selectedColumnLineage,
                relatedColumns: relatedColumns,
                columnLeafStatus: columnLeafStatus,
                showAllColumnsItems: showAllColumnsItems,
                onShowAllColumns: handleShowAllColumns,
                itemActiveTabs: itemActiveTabs,
                onTabChange: handleTabChange,
                adjacentItemIds: adjacentItemIds,
                // Ensure collapse handlers and state are always present
                dbCollapsed: !!nodeCollapseInfo.dbCollapsed,
                schemaCollapsed: !!nodeCollapseInfo.schemaCollapsed,
                collapsed: !!nodeCollapseInfo.collapsed,
                onToggleDbCollapse: handleToggleDbCollapse,
                onToggleSchemaCollapse: handleToggleSchemaCollapse,
                onToggleCollapse: handleTogglePlatformCollapse,
              },
            };
          }));
        }, [selectedItem, expandedItems, itemSearchQueries, selectedChildren, columnLineageMode, selectedColumnLineage, relatedColumns, setNodes, handleToggleItemExpand, handleItemSearchChange, handleChildClick, handleChildHover, showAllColumnsItems, handleShowAllColumns, itemActiveTabs, handleTabChange, collapseState, handleToggleDbCollapse, handleToggleSchemaCollapse, handleTogglePlatformCollapse, adjacentItemIds]);

        // Layout version counter to prevent stale updates
        const layoutVersionRef = React.useRef(0);
        
        // Re-layout when any state changes that affects node heights
        useEffect(() => {
          const currentSelectedId = selectedItem?.id || window.sharedSelection?.selectedItemId;
          
          // Increment layout version
          layoutVersionRef.current += 1;
          const currentVersion = layoutVersionRef.current;
          
          // First: Update node data with new state (without position changes)
          setNodes(nds => {
            // Skip if no nodes yet
            if (!nds || nds.length === 0) return nds;
            
            // Update nodes with new data
            return nds.map(node => {
              const nodeCollapseInfo = collapseState[node.id] || {};
              const estimatedHeight = calculateNodeHeight(node.type, node.data.items, nodeCollapseInfo, expandedItems, currentSelectedId, columnLineageMode, selectedColumnLineage, relatedColumns);
              
              return {
                ...node,
                data: {
                  ...node.data,
                  dbCollapsed: !!nodeCollapseInfo.dbCollapsed,
                  schemaCollapsed: !!nodeCollapseInfo.schemaCollapsed,
                  collapsed: !!nodeCollapseInfo.collapsed,
                  onToggleDbCollapse: handleToggleDbCollapse,
                  onToggleSchemaCollapse: handleToggleSchemaCollapse,
                  onToggleCollapse: handleTogglePlatformCollapse,
                  onToggleItemExpand: handleToggleItemExpand,
                  onItemSearchChange: handleItemSearchChange,
                  onChildClick: handleChildClick,
                  onChildHover: handleChildHover,
                  expandedItems: expandedItems,
                  selectedItemId: currentSelectedId,
                  adjacentItemIds: adjacentItemIds,
                  height: estimatedHeight,
                  showAllColumnsItems: showAllColumnsItems,
                  onShowAllColumns: handleShowAllColumns,
                  itemActiveTabs: itemActiveTabs,
                  onTabChange: handleTabChange,
                },
              };
            });
          });
          
          // Second: Schedule deferred measurement and re-centering after DOM updates
          // Use multiple frames to ensure DOM has fully rendered
          const scheduleLayoutUpdate = () => {
            requestAnimationFrame(() => {
              // Check if this update is still current
              if (layoutVersionRef.current !== currentVersion) return;
              
              // Wait one more frame to ensure CSS transitions have started
              requestAnimationFrame(() => {
                if (layoutVersionRef.current !== currentVersion) return;
                
                // Now measure and re-center
                setNodes(nds => {
                  if (!nds || nds.length === 0) return nds;
                  
                  // Create a copy of nodes to modify
                  const nodesToUpdate = nds.map(n => ({
                    ...n,
                    position: { ...n.position },
                    data: { ...n.data }
                  }));
                  
                  // Use the centralized function to center columns based on measured heights
                  return centerColumnsByMeasuredHeights(nodesToUpdate, 72);
                });
              });
            });
          };
          
          // Schedule the layout update
          scheduleLayoutUpdate();
          
          // Also schedule delayed updates for cases where CSS transitions affect height
          // CSS transitions on .graph-expanded-card take 200ms, so we need to measure after they complete
          const timeoutId1 = setTimeout(() => {
            if (layoutVersionRef.current !== currentVersion) return;
            
            setNodes(nds => {
              if (!nds || nds.length === 0) return nds;
              
              const nodesToUpdate = nds.map(n => ({
                ...n,
                position: { ...n.position },
                data: { ...n.data }
              }));
              
              return centerColumnsByMeasuredHeights(nodesToUpdate, 72);
            });
          }, 50);
          
          // Second delayed update after CSS transitions complete
          const timeoutId2 = setTimeout(() => {
            if (layoutVersionRef.current !== currentVersion) return;
            
            setNodes(nds => {
              if (!nds || nds.length === 0) return nds;
              
              const nodesToUpdate = nds.map(n => ({
                ...n,
                position: { ...n.position },
                data: { ...n.data }
              }));
              
              return centerColumnsByMeasuredHeights(nodesToUpdate, 72);
            });
          }, 250);
          
          return () => {
            clearTimeout(timeoutId1);
            clearTimeout(timeoutId2);
          };
        }, [collapseState, expandedItems, selectedItem, columnLineageMode, selectedColumnLineage, relatedColumns, adjacentItemIds, calculateNodeHeight, handleToggleDbCollapse, handleToggleSchemaCollapse, handleTogglePlatformCollapse, handleToggleItemExpand, handleItemSearchChange, handleChildClick, handleChildHover, setNodes, showAllColumnsItems, handleShowAllColumns, itemActiveTabs, handleTabChange]);

        // Expose global function to center on selected/focal node
        useEffect(() => {
          window.centerOnSelectedNode = () => {
            if (!reactFlowInstance) return;
            
            const allNodes = reactFlowInstance.getNodes();
            const currentSelectedId = selectedItem?.id || window.sharedSelection?.selectedItemId;
            
            let targetNode = null;
            
            // First try to find the selected node
            if (currentSelectedId) {
              targetNode = allNodes.find(node => {
                if (node.data.item?.id === currentSelectedId) return true;
                if (node.data.items?.some(item => item.id === currentSelectedId)) return true;
                return false;
              });
            }
            
            // Fall back to focal node if no selection
            if (!targetNode) {
              targetNode = allNodes.find(node => 
                node.data.isFocal || node.data.hasFocal || node.data.items?.some(item => item.isFocal)
              );
            }
            
            if (targetNode) {
              const currentZoom = reactFlowInstance.getZoom();
              const x = targetNode.position.x + (targetNode.width || targetNode.data.width || 304) / 2;
              const y = targetNode.position.y + (targetNode.height || targetNode.data.height || 100) / 2;
              reactFlowInstance.setCenter(x, y, { zoom: currentZoom, duration: 300 });
            }
          };
          
          // Center on a specific node by ID and apply focused style (without selecting)
          window.centerOnNode = (nodeId) => {
            if (!reactFlowInstance || !nodeId) return;
            
            const allNodes = reactFlowInstance.getNodes();
            const targetNode = allNodes.find(node => {
              if (node.data.item?.id === nodeId) return true;
              if (node.data.items?.some(item => item.id === nodeId)) return true;
              return false;
            });
            
            if (targetNode) {
              // Remove focused class from any previously focused items
              document.querySelectorAll('.focused').forEach(el => {
                el.classList.remove('focused');
              });
              
              // Find and highlight the specific item element within the node
              const nodeElement = document.querySelector(`[data-id="${targetNode.id}"]`);
              if (nodeElement) {
                // Try to find the specific item by data-item-id attribute
                let itemElement = nodeElement.querySelector(`[data-item-id="${nodeId}"]`);
                
                // If not found, it might be a single-item node (expanded card or regular card)
                if (!itemElement) {
                  itemElement = nodeElement.querySelector('.graph-expanded-card, .graph-regular-card');
                }
                
                if (itemElement) {
                  itemElement.classList.add('focused');
                  
                  // Auto-remove focused class after 2 seconds
                  setTimeout(() => {
                    itemElement.classList.remove('focused');
                  }, 2000);
                }
              }
              
              // Center on the node
              const currentZoom = reactFlowInstance.getZoom();
              const x = targetNode.position.x + (targetNode.width || targetNode.data.width || 304) / 2;
              const y = targetNode.position.y + (targetNode.height || targetNode.data.height || 100) / 2;
              reactFlowInstance.setCenter(x, y, { zoom: currentZoom, duration: 300 });
            }
          };
          
          return () => {
            delete window.centerOnSelectedNode;
            delete window.centerOnNode;
          };
        }, [reactFlowInstance, selectedItem]);
        
        // Expose expansion handlers globally (per-node)
        useEffect(() => {
          window.lineageExpansion = {
            expandedUpstream: expandedUpstream,
            expandedDownstream: expandedDownstream,
            expandUpstream: handleExpandUpstream,
            collapseUpstream: handleCollapseUpstream,
            expandDownstream: handleExpandDownstream,
            collapseDownstream: handleCollapseDownstream,
            // Check if a specific node can expand/collapse
            canExpandUpstream: (itemId) => !expandedUpstream.has(itemId),
            canCollapseUpstream: (itemId) => expandedUpstream.has(itemId),
            canExpandDownstream: (itemId) => !expandedDownstream.has(itemId),
            canCollapseDownstream: (itemId) => expandedDownstream.has(itemId),
          };
          
          return () => {
            delete window.lineageExpansion;
          };
        }, [expandedUpstream, expandedDownstream, handleExpandUpstream, handleCollapseUpstream, handleExpandDownstream, handleCollapseDownstream]);

        // Handle window resize to adjust zoom level at breakpoint
        useEffect(() => {
          if (!reactFlowInstance) return;
          
          let lastBreakpointState = window.innerWidth < 1112;
          
          const handleResize = () => {
            const isNarrow = window.innerWidth < 1112;
            
            // Only update zoom if we crossed the breakpoint
            if (isNarrow !== lastBreakpointState) {
              lastBreakpointState = isNarrow;
              const newZoom = isNarrow ? 0.75 : 1;
              const viewport = reactFlowInstance.getViewport();
              reactFlowInstance.setViewport({ ...viewport, zoom: newZoom }, { duration: 300 });
            }
          };
          
          window.addEventListener('resize', handleResize);
          
          return () => {
            window.removeEventListener('resize', handleResize);
          };
        }, [reactFlowInstance]);

        // Expose global function to select a column (for side panel interaction)
        useEffect(() => {
          window.selectColumn = (itemId, columnName) => {
            if (itemId && columnName) {
              handleChildClick(itemId, columnName);
            }
          };
          
          return () => {
            delete window.selectColumn;
          };
        }, [handleChildClick]);

        // Expose global function to collapse/expand all graph groups
        useEffect(() => {
          window.toggleGraphGroupsCollapse = () => {
            if (!reactFlowInstance) return { allCollapsed: false };
            
            const allNodes = reactFlowInstance.getNodes();
            
            // Count how many groups are collapsed vs expanded
            let collapsedCount = 0;
            let expandableCount = 0;
            
            allNodes.forEach(node => {
              if (node.type === 'groupNode') {
                expandableCount++;
                const nodeState = collapseState[node.id] || {};
                if (nodeState.dbCollapsed) collapsedCount++;
              } else if (node.type === 'platformGroup') {
                expandableCount++;
                const nodeState = collapseState[node.id] || {};
                if (nodeState.collapsed) collapsedCount++;
              }
            });
            
            // If all are collapsed, expand all. Otherwise, collapse all.
            const allCollapsed = collapsedCount === expandableCount && expandableCount > 0;
            
            const newCollapseState = {};
            allNodes.forEach(node => {
              if (node.type === 'groupNode') {
                newCollapseState[node.id] = {
                  ...collapseState[node.id],
                  dbCollapsed: !allCollapsed // collapse if not all collapsed, expand if all collapsed
                };
              } else if (node.type === 'platformGroup') {
                newCollapseState[node.id] = {
                  ...collapseState[node.id],
                  collapsed: !allCollapsed
                };
              }
            });
            
            setCollapseState(prev => ({ ...prev, ...newCollapseState }));
            
            // Return the new state (now all collapsed or all expanded)
            return { allCollapsed: !allCollapsed };
          };
          
          // Also expose a function to check current state
          window.getGraphGroupsCollapseState = () => {
            if (!reactFlowInstance) return { allCollapsed: false };
            
            const allNodes = reactFlowInstance.getNodes();
            let collapsedCount = 0;
            let expandableCount = 0;
            
            allNodes.forEach(node => {
              if (node.type === 'groupNode') {
                expandableCount++;
                const nodeState = collapseState[node.id] || {};
                if (nodeState.dbCollapsed) collapsedCount++;
              } else if (node.type === 'platformGroup') {
                expandableCount++;
                const nodeState = collapseState[node.id] || {};
                if (nodeState.collapsed) collapsedCount++;
              }
            });
            
            return { 
              allCollapsed: collapsedCount === expandableCount && expandableCount > 0,
              collapsedCount,
              expandableCount
            };
          };
          
          // Update button icon whenever collapse state changes
          if (window.updateGraphCollapseExpandButton) {
            window.updateGraphCollapseExpandButton();
          }
          
          return () => {
            delete window.toggleGraphGroupsCollapse;
            delete window.getGraphGroupsCollapseState;
          };
        }, [reactFlowInstance, collapseState, setCollapseState]);

        // Handle pane click - exit column lineage mode and clear edge selection (must be before loading check)
        const handlePaneClick = useCallback(() => {
          // Always clear ALL column lineage state (unconditionally)
          setColumnLineageMode(false);
          setSelectedColumnLineage(null);
          setRelatedColumns(new Map());
          setColumnLineageEdges([]);
          // Remove column lineage edges from React Flow's edge state
          setEdges(currentEdges => currentEdges.filter(e => !e.data?.isColumnLineage));
          setShowAllColumnsItems({});
          // Clear refs
          selectedColumnLineageRef.current = null;
          relatedColumnsRef.current = new Map();
          setHoveredChild(null);
          setHoverPreviewEdges([]);
          
          // Clear edge selection state and reset edge styles to default
          setSelectedEdge(null);
          setAdjacentItemIds(new Set());
          setEdges(eds => eds.map(e => ({
            ...e,
            selected: false,
            zIndex: 0,
            className: '',
            animated: false,
            style: {},
            markerEnd: {
              type: MarkerType.ArrowClosed,
              width: 10,
              height: 10,
              color: '#BDC4D5',
            },
          })));
        }, [setEdges]);

        if (isLoading) {
          return React.createElement('div', { className: 'graph-loading' },
            React.createElement('div', { className: 'graph-loading-spinner' }),
            'Loading graph...'
          );
        }

        // Combine regular edges with hover preview edges
        // In column lineage mode, dim non-lineage edges (lineage edges are already in the edges state)
        console.log('Render: columnLineageMode:', columnLineageMode, 'edges count:', edges.length, 'lineage edges:', edges.filter(e => e.data?.isColumnLineage).map(e => e.id));
        const combinedEdges = columnLineageMode 
          ? edges.map(edge => {
              // Don't dim column lineage edges
              if (edge.data?.isColumnLineage) {
                return edge;
              }
              // Dim regular edges
              return {
                ...edge,
                style: { ...edge.style, opacity: 0.2 }
              };
            })
          : [
              // Filter out any stale column lineage edges when not in lineage mode
              ...edges.filter(e => !e.data?.isColumnLineage),
              ...hoverPreviewEdges
            ];
        console.log('combinedEdges count:', combinedEdges.length, 'lineage edges in combined:', combinedEdges.filter(e => e.data?.isColumnLineage).length);

        const defaultZoom = 1;
        
        return React.createElement(ReactFlowComponent, {
          nodes,
          edges: combinedEdges,
          onNodesChange,
          onEdgesChange,
          onInit,
          onPaneClick: handlePaneClick,
          onEdgeClick: handleEdgeClick,
          nodeTypes,
          defaultViewport: { x: 0, y: 0, zoom: defaultZoom },
          minZoom: 0.1,
          maxZoom: 2,
          nodesDraggable: false, // Disabled for now - add lock/unlock UI later
          zoomOnScroll: false,
          panOnScroll: true,
          zoomActivationKeyCode: 'Meta',
          noPanClassName: 'nowheel',
          defaultEdgeOptions: {
            type: 'default',  // bezier curves
          },
          proOptions: { hideAttribution: true },
        },
          React.createElement(Background, {
            variant: BackgroundVariant.Dots,
            gap: 20,
            size: 1.5,
            color: 'rgba(213, 218, 228, 1)'
          }),
          React.createElement(MiniMap, {
            position: 'bottom-right',
            nodeStrokeWidth: 1,
            nodeColor: '#e2e8f0',
            nodeStrokeColor: '#94a3b8',
            maskColor: 'rgba(255, 255, 255, 0.7)',
            zoomable: true,
            pannable: true,
            style: {
              width: 150,
              height: 100,
              backgroundColor: '#ffffff',
              border: '1px solid #D5DAE4',
              borderRadius: '6px',
              right: 46,
              bottom: 16
            }
          }),
          React.createElement(Controls, { 
            showInteractive: false,
            position: 'bottom-right',
            style: {
              bottom: 16
            }
          })
        );
      }

      // =============================================
      // Mount React App with Provider
      // =============================================
      const container = document.getElementById('lineage-graph-container');
      if (container) {
        const root = createRoot(container);
        root.render(
          React.createElement(ReactFlowProvider, null,
            React.createElement(LineageGraph)
          )
        );
      }
      
      }); // End DOMContentLoaded
    </script>
  </body>
</html>
