<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lineage List</title>
    <link rel="stylesheet" href="./styles.css" />
    <link rel="stylesheet" href="./lineage-graph.css" />
    <!-- React Flow CSS -->
    <link rel="stylesheet" href="https://unpkg.com/reactflow@11.11.4/dist/style.css" />
  </head>
  <body>
    <script>
      // Disable browser's automatic scroll restoration on reload
      if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
      }
      
      document.addEventListener('DOMContentLoaded', () => {
        const HEADER_HEIGHT = 28;
        const CONTAINER_PADDING = 16;
        const PANEL_WIDTH = 280;
        const scrollContainer = document.querySelector('.lineage-scroll');
        const headers = Array.from(document.querySelectorAll('.depth-header'));
        
        // Store header data with order and natural positions
        const headerData = headers.map((header, index) => {
          return {
            el: header,
            order: index,
            naturalTop: 0 // Will be calculated after load
          };
        });

        function updateStickyHeaders() {
          if (!scrollContainer) return;
          
          const scrollTop = scrollContainer.scrollTop;
          const containerHeight = scrollContainer.clientHeight;
          const scrollBottom = scrollTop + containerHeight;
          
          // Calculate cumulative offsets for each header based on content above it
          let cumulativeOffset = 0;
          headerData.forEach((data, index) => {
            // Get the header's position relative to the scroll container's content
            const headerOffsetTop = data.el.offsetTop;
            
            // Calculate top sticky offset (how many headers above are stuck)
            const topOffset = index * HEADER_HEIGHT;
            
            // Calculate bottom sticky offset (how many headers below could be stuck)
            const bottomIndex = headerData.length - 1 - index;
            const bottomOffset = bottomIndex * HEADER_HEIGHT;
            
            // Apply sticky positioning with calculated offsets
            data.el.style.position = 'sticky';
            data.el.style.top = topOffset + 'px';
            data.el.style.bottom = bottomOffset + 'px';
            data.el.style.zIndex = 100 - index;
          });
        }

        // Function to recalculate natural positions
        function recalculateNaturalPositions() {
          if (!scrollContainer) return;
          headerData.forEach((data) => {
            data.naturalTop = getOffsetInContainer(data.el);
          });
        }

        // Run on scroll and resize
        scrollContainer.addEventListener('scroll', updateStickyHeaders, { passive: true });
        window.addEventListener('resize', () => {
          recalculateNaturalPositions();
          updateStickyHeaders();
        });
        
        // Initial calls - ensure layout is computed after images load
        updateStickyHeaders();
        requestAnimationFrame(updateStickyHeaders);
        
        // Helper to get element's top position relative to scroll container
        function getOffsetInContainer(element) {
          if (!scrollContainer) return 0;
          let offset = 0;
          let el = element;
          while (el && el !== scrollContainer && el !== document.body) {
            offset += el.offsetTop;
            el = el.offsetParent;
          }
          return offset;
        }

        // Also run after all resources (images) are loaded
        window.addEventListener('load', () => {
          // Calculate and store natural positions for all headers
          headerData.forEach((data) => {
            data.naturalTop = getOffsetInContainer(data.el);
          });
          
          // Scroll to center the focus section
          const focalHeader = document.querySelector('.depth-header--focal');
          const focalData = headerData.find(d => d.el === focalHeader);
          if (focalData && scrollContainer) {
            const containerHeight = scrollContainer.clientHeight;
            const targetScroll = focalData.naturalTop - (containerHeight / 2) + (HEADER_HEIGHT / 2);
            scrollContainer.scrollTo({ top: Math.max(0, targetScroll), behavior: 'instant' });
          }
          
          // Update sticky headers after scroll
          setTimeout(updateStickyHeaders, 10);
          setTimeout(updateStickyHeaders, 50);
          setTimeout(updateStickyHeaders, 100);
        });

        // Depth header click to scroll - scroll to show section at top
        headers.forEach((header, index) => {
          header.addEventListener('click', (e) => {
            if (!scrollContainer) return;
            
            // Use pre-calculated natural position
            const data = headerData[index];
            if (!data) return;
            
            // Recalculate natural positions if they are 0 (e.g., after switching from graph view)
            if (data.naturalTop === 0 && index > 0) {
              recalculateNaturalPositions();
            }
            
            // Scroll so this header is at the top, accounting for headers above
            const stickyOffset = index * HEADER_HEIGHT;
            const targetPosition = data.naturalTop - stickyOffset;
            scrollContainer.scrollTo({ top: Math.max(0, targetPosition), behavior: 'smooth' });
          });
        });

        // Group collapse toggle
        document.querySelectorAll('.group-header').forEach(groupHeader => {
          groupHeader.addEventListener('click', (e) => {
            e.stopPropagation();
            const group = groupHeader.closest('.object-group');
            group.classList.toggle('collapsed');
            // Update sticky headers after collapse animation
            setTimeout(updateStickyHeaders, 50);
            setTimeout(updateStickyHeaders, 150);
            setTimeout(updateStickyHeaders, 300);
            // Update collapse/expand all button state
            updateCollapseExpandAllButton();
          });
        });

        // Collapse/Expand all groups toggle
        let allGroupsCollapsed = false;
        const collapseExpandAllBtn = document.getElementById('collapse-expand-all');
        
        function updateCollapseExpandAllButton() {
          const allGroups = document.querySelectorAll('.object-group');
          const collapsedGroups = document.querySelectorAll('.object-group.collapsed');
          allGroupsCollapsed = collapsedGroups.length === allGroups.length;
          
          const img = collapseExpandAllBtn.querySelector('img');
          if (allGroupsCollapsed) {
            img.src = './img/chevrons-expand.svg';
            img.alt = 'Expand all';
            collapseExpandAllBtn.title = 'Expand all groups';
          } else {
            img.src = './img/chevrons-collapse.svg';
            img.alt = 'Collapse all';
            collapseExpandAllBtn.title = 'Collapse all groups';
          }
        }
        
        collapseExpandAllBtn.addEventListener('click', () => {
          const allGroups = document.querySelectorAll('.object-group');
          
          if (allGroupsCollapsed) {
            // Expand all
            allGroups.forEach(group => group.classList.remove('collapsed'));
          } else {
            // Collapse all
            allGroups.forEach(group => group.classList.add('collapsed'));
          }
          
          allGroupsCollapsed = !allGroupsCollapsed;
          updateCollapseExpandAllButton();
          
          // Update sticky headers after collapse animation
          setTimeout(updateStickyHeaders, 50);
          setTimeout(updateStickyHeaders, 150);
          setTimeout(updateStickyHeaders, 300);
          
          // Update connection overflow
          setTimeout(updateConnectionOverflow, 350);
        });

        // Hover highlighting for connected objects
        const allItems = document.querySelectorAll('.group-list li');
        
        // Build a map of object names to their elements
        const objectMap = new Map();
        allItems.forEach(item => {
          const nameEl = item.querySelector('.object-name');
          if (nameEl) {
            const name = nameEl.textContent.trim().toLowerCase();
            if (!objectMap.has(name)) {
              objectMap.set(name, []);
            }
            objectMap.get(name).push(item);
          }
        });

        // Get depth level of an item
        function getDepthRow(item) {
          const depthContent = item.closest('.depth-content');
          return depthContent ? parseInt(depthContent.dataset.row) : null;
        }

        // Find connected objects with direction
        function getConnectedObjects(item) {
          const upstream = []; // -1 level (connection tags highlight)
          const downstream = []; // +1 level (object name highlights)
          const currentRow = getDepthRow(item);
          const currentName = item.querySelector('.object-name')?.textContent.trim().toLowerCase();
          
          // Get objects referenced in this item's connection tags
          const connectionTags = item.querySelectorAll('.connection-tag');
          connectionTags.forEach(tag => {
            const refName = tag.textContent.trim().toLowerCase();
            const refItems = objectMap.get(refName) || [];
            refItems.forEach(refItem => {
              const refRow = getDepthRow(refItem);
              if (refRow === currentRow - 1) {
                upstream.push(refItem);
              } else if (refRow === currentRow + 1) {
                downstream.push(refItem);
              }
            });
          });
          
          // Find objects that reference this item
          allItems.forEach(otherItem => {
            const otherRow = getDepthRow(otherItem);
            const otherTags = otherItem.querySelectorAll('.connection-tag');
            otherTags.forEach(tag => {
              if (tag.textContent.trim().toLowerCase() === currentName) {
                if (otherRow === currentRow - 1) {
                  upstream.push(otherItem);
                } else if (otherRow === currentRow + 1) {
                  downstream.push(otherItem);
                }
              }
            });
          });
          
          return { upstream, downstream };
        }

        // Add hover listeners
        allItems.forEach(item => {
          item.addEventListener('mouseenter', () => {
            // Highlight current row's connection tags
            item.classList.add('highlight-current');
            
            // Get connected objects
            const { upstream, downstream } = getConnectedObjects(item);
            
            // Highlight upstream (-1) objects - their connection tags
            upstream.forEach(upItem => {
              upItem.classList.add('highlight-upstream');
            });
            
            // Highlight downstream (+1) objects - their object names
            downstream.forEach(downItem => {
              downItem.classList.add('highlight-downstream');
            });
          });
          
          item.addEventListener('mouseleave', () => {
            item.classList.remove('highlight-current');
            document.querySelectorAll('.highlight-upstream').forEach(el => {
              el.classList.remove('highlight-upstream');
            });
            document.querySelectorAll('.highlight-downstream').forEach(el => {
              el.classList.remove('highlight-downstream');
            });
          });
        });

        // Click on connection-tag to scroll to and select corresponding node
        document.querySelectorAll('.connection-tag').forEach(tag => {
          tag.style.cursor = 'pointer';
          tag.addEventListener('click', (e) => {
            e.stopPropagation();
            const refName = tag.textContent.trim().toLowerCase();
            const refItems = objectMap.get(refName) || [];
            
            if (refItems.length > 0) {
              const targetItem = refItems[0];
              
              // Expand parent group if collapsed
              const parentGroup = targetItem.closest('.object-group');
              if (parentGroup && parentGroup.classList.contains('collapsed')) {
                parentGroup.classList.toggle('collapsed');
                setTimeout(() => {
                  scrollToItem(targetItem);
                  selectItem(targetItem);
                }, 100);
              } else {
                scrollToItem(targetItem);
                selectItem(targetItem);
              }
            }
          });
        });

        // ===========================================
        // Connection Overflow Detection & Popover
        // ===========================================
        
        // Create popover element
        const popover = document.createElement('div');
        popover.className = 'connection-popover';
        popover.innerHTML = `
          <div class="connection-popover-section connection-popover-upstream">
            <div class="connection-popover-label connection-popover-label--upstream">Upstream</div>
            <ul class="connection-popover-list"></ul>
          </div>
          <div class="connection-popover-section connection-popover-downstream">
            <div class="connection-popover-label connection-popover-label--downstream">Downstream</div>
            <ul class="connection-popover-list"></ul>
          </div>
        `;
        document.body.appendChild(popover);
        
        let popoverTimeout = null;
        let activePopoverTrigger = null;
        
        // Hide popover function
        function hidePopover() {
          popover.classList.remove('visible');
          activePopoverTrigger = null;
        }
        
        // Show popover with connection data
        function showPopover(trigger, item) {
          if (popoverTimeout) clearTimeout(popoverTimeout);
          
          const { upstream, downstream } = getConnectedObjects(item);
          
          // Populate upstream section
          const upstreamSection = popover.querySelector('.connection-popover-upstream');
          const upstreamList = upstreamSection.querySelector('.connection-popover-list');
          upstreamList.innerHTML = '';
          
          if (upstream.length > 0) {
            upstreamSection.style.display = 'block';
            upstream.forEach(upItem => {
              const name = upItem.querySelector('.object-name')?.textContent || '';
              const iconSrc = upItem.querySelector('.object-icon')?.src || './img/ui/table.svg';
              const li = document.createElement('li');
              li.className = 'connection-popover-item';
              li.innerHTML = `
                <img class="connection-popover-item-icon" src="${iconSrc}" alt="">
                <span class="connection-popover-item-name">${name}</span>
              `;
              li.addEventListener('click', () => {
                hidePopover();
                scrollToItem(upItem);
                selectItem(upItem);
              });
              upstreamList.appendChild(li);
            });
          } else {
            upstreamSection.style.display = 'none';
          }
          
          // Populate downstream section
          const downstreamSection = popover.querySelector('.connection-popover-downstream');
          const downstreamList = downstreamSection.querySelector('.connection-popover-list');
          downstreamList.innerHTML = '';
          
          if (downstream.length > 0) {
            downstreamSection.style.display = 'block';
            downstream.forEach(downItem => {
              const name = downItem.querySelector('.object-name')?.textContent || '';
              const iconSrc = downItem.querySelector('.object-icon')?.src || './img/ui/table.svg';
              const li = document.createElement('li');
              li.className = 'connection-popover-item';
              li.innerHTML = `
                <img class="connection-popover-item-icon" src="${iconSrc}" alt="">
                <span class="connection-popover-item-name">${name}</span>
              `;
              li.addEventListener('click', () => {
                hidePopover();
                scrollToItem(downItem);
                selectItem(downItem);
              });
              downstreamList.appendChild(li);
            });
          } else {
            downstreamSection.style.display = 'none';
          }
          
          // Position popover
          const rect = trigger.getBoundingClientRect();
          const popoverHeight = popover.offsetHeight || 200;
          const popoverWidth = popover.offsetWidth || 240;
          
          let top = rect.bottom + 8;
          let left = rect.left;
          
          // Adjust if would go off screen
          if (top + popoverHeight > window.innerHeight) {
            top = rect.top - popoverHeight - 8;
          }
          if (left + popoverWidth > window.innerWidth) {
            left = window.innerWidth - popoverWidth - 16;
          }
          
          popover.style.top = `${top}px`;
          popover.style.left = `${left}px`;
          popover.classList.add('visible');
          activePopoverTrigger = trigger;
        }
        
        // Popover mouse events
        popover.addEventListener('mouseenter', () => {
          if (popoverTimeout) clearTimeout(popoverTimeout);
        });
        
        popover.addEventListener('mouseleave', () => {
          popoverTimeout = setTimeout(hidePopover, 150);
        });
        
        // Handle overflow detection and compact counters
        function updateConnectionOverflow() {
          const connectionsContainers = document.querySelectorAll('.connections');
          
          connectionsContainers.forEach(container => {
            const tags = Array.from(container.querySelectorAll('.connection-tag'));
            if (tags.length === 0) return;
            
            const item = container.closest('li');
            if (!item) return;
            
            // Remove existing overflow badge and compact counter
            const existingOverflow = container.querySelector('.connection-overflow');
            if (existingOverflow) existingOverflow.remove();
            const existingCompact = container.querySelector('.connection-compact-counter');
            if (existingCompact) existingCompact.remove();
            
            // Reset all tags to visible
            tags.forEach(tag => tag.style.display = '');
            
            const containerWidth = container.clientWidth;
            const arrowWidth = 20; // Arrow pseudo-element width
            const overflowBadgeWidth = 32; // Approximate width for "+N" badge
            const totalConnections = tags.length;
            
            // If only 1 connection, always show it (no overflow logic needed)
            if (totalConnections === 1) {
              // Just add compact counter for narrow screens (CSS will hide/show appropriately)
              addCompactCounter(container, item, totalConnections);
              return;
            }
            
            // First pass: measure all tags to see if they fit without overflow badge
            let totalWidthWithoutBadge = arrowWidth;
            let allFit = true;
            
            tags.forEach(tag => {
              const tagWidth = tag.offsetWidth + 4; // +4 for gap
              totalWidthWithoutBadge += tagWidth;
            });
            
            if (totalWidthWithoutBadge <= containerWidth) {
              // All tags fit, no overflow needed
              addCompactCounter(container, item, totalConnections);
              return;
            }
            
            // Second pass: determine how many fit with space reserved for overflow badge
            let totalWidth = arrowWidth;
            let visibleCount = 0;
            let hiddenCount = 0;
            const availableWidth = containerWidth - overflowBadgeWidth;
            
            tags.forEach((tag, index) => {
              const tagWidth = tag.offsetWidth + 4; // +4 for gap
              if (totalWidth + tagWidth <= availableWidth) {
                totalWidth += tagWidth;
                visibleCount++;
              } else {
                tag.style.display = 'none';
                hiddenCount++;
              }
            });
            
            // Ensure at least 1 tag is always visible (don't hide all in overflow)
            if (visibleCount === 0 && tags.length > 0) {
              tags[0].style.display = '';
              visibleCount = 1;
              hiddenCount = tags.length - 1;
            }
            
            // Add overflow badge if some tags are hidden
            if (hiddenCount > 0) {
              const overflowBadge = document.createElement('span');
              overflowBadge.className = 'connection-overflow';
              overflowBadge.textContent = `+${hiddenCount}`;
              overflowBadge.title = `${hiddenCount} more connection${hiddenCount > 1 ? 's' : ''}`;
              
              // Hover to show popover
              overflowBadge.addEventListener('mouseenter', () => {
                showPopover(overflowBadge, item);
              });
              overflowBadge.addEventListener('mouseleave', () => {
                popoverTimeout = setTimeout(hidePopover, 150);
              });
              overflowBadge.addEventListener('click', (e) => {
                e.stopPropagation();
                showPopover(overflowBadge, item);
              });
              
              container.appendChild(overflowBadge);
            }
            
            // Add compact counter for narrow screens
            addCompactCounter(container, item, totalConnections);
            
            // Add hover listeners to the entire connections container
            addConnectionsHover(container, item);
          });
        }
        
        // Helper function to add hover behavior to connections container
        function addConnectionsHover(container, item) {
          // Remove existing listeners by cloning (to avoid duplicates on resize)
          if (!container.dataset.hoverEnabled) {
            container.dataset.hoverEnabled = 'true';
            
            container.addEventListener('mouseenter', () => {
              showPopover(container, item);
            });
            container.addEventListener('mouseleave', () => {
              popoverTimeout = setTimeout(hidePopover, 150);
            });
          }
        }
        
        // Helper function to add compact counter
        function addCompactCounter(container, item, totalConnections) {
          const isDownstream = container.classList.contains('connections--downstream');
          
          const compactCounter = document.createElement('span');
          compactCounter.className = `connection-compact-counter ${isDownstream ? 'connection-compact-counter--downstream' : 'connection-compact-counter--upstream'}`;
          compactCounter.textContent = totalConnections;
          compactCounter.title = `${totalConnections} ${isDownstream ? 'downstream' : 'upstream'} connection${totalConnections > 1 ? 's' : ''}`;
          
          // Hover to show popover
          compactCounter.addEventListener('mouseenter', () => {
            showPopover(compactCounter, item);
          });
          compactCounter.addEventListener('mouseleave', () => {
            popoverTimeout = setTimeout(hidePopover, 150);
          });
          compactCounter.addEventListener('click', (e) => {
            e.stopPropagation();
            showPopover(compactCounter, item);
          });
          
          container.appendChild(compactCounter);
        }
        
        // Run overflow detection on load and resize
        updateConnectionOverflow();
        window.addEventListener('resize', () => {
          updateConnectionOverflow();
        });
        
        // Also update when groups collapse/expand
        document.querySelectorAll('.group-header').forEach(groupHeader => {
          groupHeader.addEventListener('click', () => {
            setTimeout(updateConnectionOverflow, 350);
          });
        });

        function scrollToItem(targetItem, highlight = true) {
          if (!scrollContainer || !targetItem) return;
          const targetTop = getOffsetInContainer(targetItem);
          const containerHeight = scrollContainer.clientHeight;
          const targetScroll = targetTop - (containerHeight / 2) + 16;
          
          scrollContainer.scrollTo({ top: Math.max(0, targetScroll), behavior: 'smooth' });
          
          // Briefly highlight the target (optional)
          if (highlight) {
            targetItem.style.transition = 'background 0.3s';
            targetItem.style.background = 'hsla(217, 13%, 94%, 1)';
            setTimeout(() => {
              targetItem.style.background = '';
              setTimeout(() => {
                targetItem.style.transition = '';
              }, 300);
            }, 1000);
          }
        }

        // Global function to center list view on focused/selected item
        window.centerListOnSelected = function() {
          // First try to find selected item
          const selectedItem = document.querySelector('.group-list li.selected');
          if (selectedItem) {
            scrollToItem(selectedItem, false);
            return;
          }
          
          // Fall back to focal item (in the focal depth section)
          const focalSection = document.querySelector('.depth-content--focal');
          if (focalSection) {
            const focalItem = focalSection.querySelector('.group-list li');
            if (focalItem) {
              scrollToItem(focalItem, false);
            }
          }
        };

        // Object selection and side panel
        const sidePanel = document.getElementById('sidePanel');
        const panelClose = document.getElementById('panelClose');
        const panelIcon = document.getElementById('panelIcon');
        const panelTitle = document.getElementById('panelTitle');
        const panelSchema = document.getElementById('panelSchema');
        const panelComment = document.getElementById('panelComment');
        const panelOwner = document.getElementById('panelOwner');
        const panelCreated = document.getElementById('panelCreated');
        const panelQuality = document.getElementById('panelQuality');
        const panelRows = document.getElementById('panelRows');
        const panelTags = document.getElementById('panelTags');
        const panelColumns = document.getElementById('panelColumns');
        let selectedListItem = null;

        // Helper: Get column type icon path (same logic as graph view)
        function getPanelColumnIcon(type) {
          const normalizedType = (type || '').toUpperCase();
          if (['VARCHAR', 'TEXT', 'STRING', 'CHAR'].some(t => normalizedType.includes(t))) return 'img/ui/text.svg';
          if (['INTEGER', 'INT', 'BIGINT', 'NUMBER', 'SMALLINT', 'TINYINT'].some(t => normalizedType.includes(t))) return 'img/ui/number.svg';
          if (['DECIMAL', 'FLOAT', 'DOUBLE', 'NUMERIC', 'REAL'].some(t => normalizedType.includes(t))) return 'img/ui/number.svg';
          if (['BOOLEAN', 'BOOL'].some(t => normalizedType.includes(t))) return 'img/ui/boolean.svg';
          if (['BINARY', 'VARBINARY', 'BLOB', 'BYTES'].some(t => normalizedType.includes(t))) return 'img/ui/binary.svg';
          if (normalizedType.includes('DATE') && !normalizedType.includes('TIME')) return 'img/ui/calendar.svg';
          if (['TIMESTAMP', 'DATETIME', 'TIME'].some(t => normalizedType.includes(t))) return 'img/ui/calendar.svg';
          if (['JSON', 'VARIANT'].some(t => normalizedType.includes(t))) return 'img/ui/format-code.svg';
          if (['OBJECT', 'STRUCT', 'MAP'].some(t => normalizedType.includes(t))) return 'img/ui/object.svg';
          if (normalizedType.includes('ARRAY')) return 'img/ui/array.svg';
          if (normalizedType === 'MEASURE') return 'img/ui/number.svg';
          if (normalizedType === 'DIMENSION') return 'img/ui/object.svg';
          return 'img/ui/column-single.svg';
        }

        // Global shared selection state (accessible by graph view)
        window.sharedSelection = {
          selectedItemId: null,
          selectedItemData: null,
          listeners: [],
          
          // Update selection from any view
          setSelection: function(itemId, itemData) {
            this.selectedItemId = itemId;
            this.selectedItemData = itemData;
            this.notifyListeners();
            this.updateSidePanel(itemData);
          },
          
          // Clear selection
          clearSelection: function() {
            this.selectedItemId = null;
            this.selectedItemData = null;
            this.notifyListeners();
            sidePanel.classList.add('hidden');
          },
          
          // Subscribe to selection changes
          addListener: function(callback) {
            this.listeners.push(callback);
          },
          
          // Notify all listeners of selection change
          notifyListeners: function() {
            this.listeners.forEach(cb => cb(this.selectedItemId, this.selectedItemData));
          },
          
          // Update side panel with item data
          updateSidePanel: function(itemData) {
            if (!itemData) return;
            
            // Header
            panelTitle.textContent = itemData.name || 'Unknown';
            panelIcon.src = itemData.icon || './img/ui/table.svg';
            
            // Database / Schema
            let schemaText = '-';
            if (itemData.database && itemData.schemaName) {
              schemaText = `${itemData.database} / ${itemData.schemaName}`;
            } else if (itemData.schema) {
              schemaText = itemData.schema;
            } else if (itemData.platform) {
              schemaText = itemData.platform;
            }
            panelSchema.textContent = schemaText;
            
            // Comment/Description
            panelComment.textContent = itemData.description || itemData.comment || '-';
            
            // Owner
            panelOwner.textContent = itemData.owner || 'ACCOUNTADMIN';
            
            // Created date
            panelCreated.textContent = itemData.createdAt || itemData.created || '-';
            
            // Data quality
            panelQuality.textContent = itemData.dataQuality || '-';
            
            // Row count
            panelRows.textContent = itemData.rowCount ? itemData.rowCount.toLocaleString() : '-';
            
            // Tags
            if (itemData.tags && itemData.tags.length > 0) {
              panelTags.innerHTML = itemData.tags.map(tag => 
                `<span class="panel-tag">${tag}</span>`
              ).join('');
              panelTags.parentElement.style.display = 'block';
            } else {
              panelTags.innerHTML = '';
              panelTags.parentElement.style.display = 'none';
            }
            
            // Columns
            const columns = itemData.columns || itemData.features || [];
            if (columns.length > 0) {
              panelColumns.innerHTML = columns.map(col => {
                const iconSrc = getPanelColumnIcon(col.type);
                const keyIcon = col.isPrimaryKey ? '<img src="img/ui/ownership.svg" class="panel-column-key" title="Primary Key">' :
                               col.isForeignKey ? '<img src="img/ui/format-link.svg" class="panel-column-key" title="Foreign Key">' : '';
                return `<div class="panel-column-item">
                  <img src="${iconSrc}" class="panel-column-icon" alt="${col.type || 'column'}">
                  <span class="panel-column-name">${col.name}</span>
                  ${keyIcon}
                </div>`;
              }).join('');
              panelColumns.parentElement.style.display = 'block';
            } else {
              panelColumns.innerHTML = '<div class="panel-column-empty">No columns</div>';
            }
            
            sidePanel.classList.remove('hidden');
          }
        };

        // Helper: Find full item data from mockLineageData by name
        function findItemDataByName(name) {
          if (!window.mockLineageData) return null;
          const normalizedName = name.toLowerCase().trim();
          
          for (const depth of window.mockLineageData.depths) {
            for (const group of depth.groups) {
              // Some groups have items directly
              if (group.items) {
                for (const item of group.items) {
                  if (item.name.toLowerCase().trim() === normalizedName) {
                    return item;
                  }
                }
              }
              // Database groups have schemas which contain items
              if (group.schemas) {
                for (const schema of group.schemas) {
                  if (schema.items) {
                    for (const item of schema.items) {
                      if (item.name.toLowerCase().trim() === normalizedName) {
                        return item;
                      }
                    }
                  }
                }
              }
            }
          }
          return null;
        }

        // Function to select an item in list view and sync globally
        function selectItem(item) {
          // Deselect previous in list
          if (selectedListItem) {
            selectedListItem.classList.remove('selected');
          }
          
          // Select new
          selectedListItem = item;
          item.classList.add('selected');
          
          // Get object info from DOM
          const objectName = item.querySelector('.object-name')?.textContent || 'Unknown';
          const objectIcon = item.querySelector('.object-icon')?.src || './img/ui/table.svg';
          const groupName = item.closest('.object-group')?.querySelector('.group-name')?.textContent || '-';
          
          // Try to find full item data from mockLineageData
          const fullItemData = findItemDataByName(objectName);
          
          if (fullItemData) {
            // Use full item data (same as graph view)
            window.sharedSelection.setSelection(fullItemData.id, {
              id: fullItemData.id,
              name: fullItemData.name,
              icon: fullItemData.icon || objectIcon,
              database: fullItemData.database,
              schemaName: fullItemData.schemaName,
              schema: fullItemData.schema || groupName,
              platform: fullItemData.platform,
              objType: fullItemData.objType,
              columns: fullItemData.columns,
              features: fullItemData.features,
              outputs: fullItemData.outputs,
              description: fullItemData.description,
              comment: fullItemData.comment,
              owner: fullItemData.owner,
              createdAt: fullItemData.createdAt,
              created: fullItemData.created,
              dataQuality: fullItemData.dataQuality,
              rowCount: fullItemData.rowCount,
              tags: fullItemData.tags
            });
          } else {
            // Fallback to minimal data from DOM
            const itemId = objectName.toLowerCase().replace(/\s+/g, '_');
            window.sharedSelection.setSelection(itemId, {
              id: itemId,
              name: objectName,
              icon: objectIcon,
              schema: groupName
            });
          }
        }

        // Listen for selection changes from graph view
        window.sharedSelection.addListener((itemId, itemData) => {
          // Update list view selection
          if (selectedListItem) {
            selectedListItem.classList.remove('selected');
            selectedListItem = null;
          }
          
          if (itemId && itemData) {
            // Find and highlight matching item in list view
            const matchName = itemData.name?.toUpperCase();
            allItems.forEach(item => {
              const nameEl = item.querySelector('.object-name');
              if (nameEl && nameEl.textContent.trim().toUpperCase() === matchName) {
                item.classList.add('selected');
                selectedListItem = item;
              }
            });
          }
        });

        // Click to select object in list view
        allItems.forEach(item => {
          item.style.cursor = 'pointer';
          item.addEventListener('click', (e) => {
            // Don't select if clicking on connection tag
            if (e.target.classList.contains('connection-tag')) return;
            
            selectItem(item);
          });
        });

        // Listen for selection changes from graph view to update list view
        window.sharedSelection.addListener((itemId, itemData) => {
          if (!itemId) {
            // Clear selection in list view
            if (selectedListItem) {
              selectedListItem.classList.remove('selected');
              selectedListItem = null;
            }
            return;
          }
          
          // Find and select the item in the list view
          const listItems = document.querySelectorAll('.group-list li');
          listItems.forEach(li => {
            const nameSpan = li.querySelector('.object-name');
            if (nameSpan && itemData && nameSpan.textContent.toLowerCase() === itemData.name?.toLowerCase()) {
              // Deselect previous
              if (selectedListItem) {
                selectedListItem.classList.remove('selected');
              }
              // Select new
              li.classList.add('selected');
              selectedListItem = li;
              
              // Scroll to the selected item if list view is visible
              const lineageScroll = document.querySelector('.lineage-scroll');
              if (lineageScroll && lineageScroll.style.display !== 'none') {
                scrollToItem(li, false);
              }
            }
          });
        });

        // Close panel
        panelClose.addEventListener('click', () => {
          window.sharedSelection.clearSelection();
          if (selectedListItem) {
            selectedListItem.classList.remove('selected');
            selectedListItem = null;
          }
          updateStickyHeaders();
        });

        // Segmented button toggle (Graph/List)
        const toggleBtns = document.querySelectorAll('.view-toggle .toggle-btn');
        const viewPanel = document.querySelector('.view-panel');
        const lineageScroll = document.querySelector('.lineage-scroll');
        const lineageGraph = document.querySelector('.lineage-graph');
        const toolBar = document.querySelector('.tool-bar');
        
        toggleBtns.forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Remove active from all
            toggleBtns.forEach(b => b.classList.remove('active'));
            // Add active to clicked
            btn.classList.add('active');
            
            // Toggle views based on button text
            const isGraphView = btn.textContent.trim() === 'Graph';
            
            // Get view-specific buttons
            const collapseExpandBtn = document.getElementById('collapse-expand-all');
            const maximizeBtn = document.getElementById('maximize-btn');
            
            if (isGraphView) {
              viewPanel.classList.add('graph-mode');
              lineageScroll.style.display = 'none';
              lineageGraph.style.display = 'block';
              
              // Show graph-view buttons, hide list-view buttons
              if (collapseExpandBtn) collapseExpandBtn.style.display = 'none';
              if (maximizeBtn) maximizeBtn.style.display = '';
              
              // Center on selected node when switching to graph view
              setTimeout(() => {
                if (window.centerOnSelectedNode) {
                  window.centerOnSelectedNode();
                }
              }, 100);
            } else {
              viewPanel.classList.remove('graph-mode');
              lineageScroll.style.display = 'block';
              lineageGraph.style.display = 'none';
              
              // Show list-view buttons, hide graph-view buttons
              if (collapseExpandBtn) collapseExpandBtn.style.display = '';
              if (maximizeBtn) maximizeBtn.style.display = 'none';
              
              // Recalculate natural positions after list view is visible
              // This is needed because positions are 0 when list is hidden
              setTimeout(() => {
                recalculateNaturalPositions();
                updateStickyHeaders();
                
                // Center on selected/focal item when switching to list view
                if (window.centerListOnSelected) {
                  window.centerListOnSelected();
                }
              }, 50);
            }
          });
        });
      });
    </script>

    <div class="main-layout">

      <div class="view-panel graph-mode">

        <div class="tool-bar">
          <div class="toolbar-left">
            <div class="view-toggle">
              <button class="toggle-btn active">Graph</button>
              <button class="toggle-btn">List</button>
            </div>
            <button class="toolbar-btn">
              <img src="./img/filter.svg" alt="" width="16" height="16">
              Filter
            </button>
          </div>
          <div class="toolbar-right">
            <button class="toolbar-btn icon-only list-view-only" id="collapse-expand-all" title="Collapse all groups" style="display: none;">
              <img src="./img/chevrons-collapse.svg" alt="Collapse all" width="16" height="16">
            </button>
            <button class="toolbar-btn icon-only graph-view-only" id="maximize-btn" title="Maximize">
              <img src="./img/maximize.svg" alt="Maximize" width="16" height="16">
            </button>
            <button class="toolbar-btn dropdown">
              <img src="./img/circle.svg" alt="" width="8" height="8">
              ORGADMIN
              <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 5l3 3 3-3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
          </div>
        </div>

        <div class="lineage-scroll" style="display: none;">
          <section class="lineage-table" aria-label="Lineage list">
            <!-- Upstream Level 3 (furthest) - Row 1 -->
            <div class="depth-header" data-row="1" data-order="0">
              <span class="depth-badge depth-badge--upstream">Upstream −3</span>
              
            </div>
            <div class="depth-content" data-row="1">
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/ui/api.svg" alt="API">
                  <span class="group-name">External APIs</span>
                  <span class="group-count">6</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="API">
                      <span class="object-name">Shopify Orders API</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">orders</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="API">
                      <span class="object-name">Stripe Payments API</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">payments</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="API">
                      <span class="object-name">Salesforce CRM</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">customers</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="API">
                      <span class="object-name">Google Analytics 4</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">ga_sessions</span>
                      <span class="connection-tag">ga_events</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="API">
                      <span class="object-name">Facebook Ads API</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">ad_spend</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="API">
                      <span class="object-name">Mixpanel Events</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">product_events</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
      
            <!-- Upstream Level 2 - Row 2 -->
            <div class="depth-header" data-row="2" data-order="1">
              <span class="depth-badge depth-badge--upstream">Upstream −2</span>
              
            </div>
            <div class="depth-content" data-row="2">
              <!-- Snowflake: RAW_ECOMMERCE -->
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-snowflake.svg" alt="Snowflake">
                  <span class="group-name"><!--ACME_PROD /--> RAW_DB / RAW_ECOMMERCE</span>
                  <span class="group-count">3</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">orders</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_orders</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">payments</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_payments</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">customers</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_customers</span>
                      <span class="connection-tag">stg_orders</span>
                    </div>
                  </li>
                </ul>
              </div>
      
              <!-- Snowflake: RAW_MARKETING -->
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-snowflake.svg" alt="Snowflake">
                  <span class="group-name"><!--ACME_PROD /--> RAW_DB / RAW_MARKETING</span>
                  <span class="group-count">4</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">ga_sessions</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_sessions</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">ga_events</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_web_events</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">ad_spend</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_ad_spend</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">product_events</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">stg_web_events</span>
                      <span class="connection-tag">stg_sessions</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
      
            <!-- Upstream Level 1 - Row 3 -->
            <div class="depth-header" data-row="3" data-order="2">
              <span class="depth-badge depth-badge--upstream">Upstream −1</span>
              
            </div>
            <div class="depth-content" data-row="3">
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-snowflake.svg" alt="Snowflake">
                  <span class="group-name"><!--ACME_PROD /--> TRANSFORM_DB / STAGING</span>
                  <span class="group-count">6</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/view.svg" alt="View">
                      <span class="object-name">stg_orders</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--blue">orders</span>
                      <span class="connection-tag tag--blue">customers</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/view.svg" alt="View">
                      <span class="object-name">stg_payments</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--blue">payments</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/view.svg" alt="View">
                      <span class="object-name">stg_customers</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--blue">customers</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/view.svg" alt="View">
                      <span class="object-name">stg_sessions</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--green">ga_sessions</span>
                      <span class="connection-tag tag--green">product_events</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/view.svg" alt="View">
                      <span class="object-name">stg_web_events</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--green">ga_events</span>
                      <span class="connection-tag tag--green">product_events</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/view.svg" alt="View">
                      <span class="object-name">stg_ad_spend</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--green">ad_spend</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
      
            <!-- Focal object - Row 4 -->
            <div class="depth-header depth-header--focal" data-row="4" data-order="3">
              <span class="depth-badge depth-badge--focal">Currently viewing</span>
              
            </div>
            <div class="depth-content depth-content--focal" data-row="4">
              <div class="object-group">
                <div class="group-header group-header--focal">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-snowflake.svg" alt="Snowflake">
                  <span class="group-name"><!--ACME_ANALYTICS /--> ANALYTICS_DB / ANALYTICS</span>
                  <span class="group-count">1</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/dataset.svg" alt="Dataset">
                      <span class="object-name">fct_customer_orders</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--gray">stg_orders</span>
                      <span class="connection-tag tag--gray">stg_payments</span>
                      <span class="connection-tag tag--gray">stg_customers</span>
                      <span class="connection-tag tag--gray">stg_sessions</span>
                      <span class="connection-tag tag--gray">stg_web_events</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
      
            <!-- Downstream Level 1 - Row 5 -->
            <div class="depth-header" data-row="5" data-order="4">
              <span class="depth-badge depth-badge--downstream">Downstream +1</span>
              
            </div>
            <div class="depth-content" data-row="5">
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-snowflake.svg" alt="Snowflake">
                  <span class="group-name"><!--ACME_ANALYTICS /--> ANALYTICS_DB / MARTS</span>
                  <span class="group-count">4</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">dim_customers</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">Customer 360</span>
                      <span class="connection-tag">churn_model</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">fct_daily_revenue</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">Exec Dashboard</span>
                      <span class="connection-tag">Finance Report</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">fct_attribution</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">Marketing ROI</span>
                      <span class="connection-tag">attribution_model</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/table.svg" alt="Table">
                      <span class="object-name">user_journey_agg</span>
                    </div>
                    <div class="connections connections--downstream">
                      <span class="connection-tag">Product Analytics</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
      
            <!-- Downstream Level 2 - Row 6 -->
            <div class="depth-header" data-row="6" data-order="5">
              <span class="depth-badge depth-badge--downstream">Downstream +2</span>
              
            </div>
            <div class="depth-content" data-row="6">
              <!-- Tableau -->
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-tableau.svg" alt="Tableau">
                  <span class="group-name">Tableau</span>
                  <span class="group-count">1</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/dashboards.svg" alt="Dashboard">
                      <span class="object-name">Exec Revenue Dashboard</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--purple">fct_daily_revenue</span>
                    </div>
                  </li>
                </ul>
              </div>
      
              <!-- Looker -->
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/logo-looker.svg" alt="Looker">
                  <span class="group-name">Looker</span>
                  <span class="group-count">2</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/dashboards.svg" alt="Dashboard">
                      <span class="object-name">Customer 360 Dashboard</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--purple">dim_customers</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/dashboards.svg" alt="Dashboard">
                      <span class="object-name">Marketing ROI Dashboard</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--purple">fct_attribution</span>
                    </div>
                  </li>
                </ul>
              </div>
      
              <!-- ML Models -->
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/ui/machine-learning-model.svg" alt="Model">
                  <span class="group-name">ML Models</span>
                  <span class="group-count">2</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/machine-learning-model.svg" alt="Model">
                      <span class="object-name">churn_prediction_model</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--purple">dim_customers</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/machine-learning-model.svg" alt="Model">
                      <span class="object-name">attribution_model</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag tag--purple">fct_attribution</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
      
            <!-- Downstream Level 3 - Row 7 -->
            <div class="depth-header" data-row="7" data-order="6">
              <span class="depth-badge depth-badge--downstream">Downstream +3</span>
              
            </div>
            <div class="depth-content" data-row="7">
              <div class="object-group">
                <div class="group-header">
                  <img class="chevron" src="./img/ui/chevron-down-small.svg" alt="">
                  <img class="group-icon" src="./img/ui/api.svg" alt="Export">
                  <span class="group-name">Exports</span>
                  <span class="group-count">2</span>
                </div>
                <ul class="group-list">
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="Email">
                      <span class="object-name">Finance Weekly Report</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag">Exec Dashboard</span>
                    </div>
                  </li>
                  <li>
                    <div class="object-info">
                      <img class="object-icon" src="./img/ui/api.svg" alt="Export">
                      <span class="object-name">Investor Data Room</span>
                    </div>
                    <div class="connections connections--upstream">
                      <span class="connection-tag">Exec Dashboard</span>
                      <span class="connection-tag">Customer 360</span>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
          </section>    
        </div>

        <div class="lineage-graph" id="lineage-graph-container" style="display: block;">
        </div>
      
      </div>

    <!-- Side Panel -->
    <aside class="side-panel hidden" id="sidePanel">
      <div class="panel-header">
        <img class="panel-header-icon" id="panelIcon" src="./img/ui/table.svg" alt="">
        <span class="panel-header-title" id="panelTitle">Object Name</span>
        <button class="panel-close" id="panelClose" aria-label="Close panel">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 4L4 12M4 4L12 12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
      <div class="panel-content">
        <div class="panel-section">
          <div class="panel-label">Database / schema</div>
          <div class="panel-value" id="panelSchema">-</div>
        </div>
        <div class="panel-section">
          <div class="panel-label">Comment</div>
          <div class="panel-value" id="panelComment">-</div>
        </div>
        <div class="panel-section">
          <div class="panel-label">Owner</div>
          <div class="panel-value" id="panelOwner">ACCOUNTADMIN</div>
        </div>
        <div class="panel-section">
          <div class="panel-label">Created</div>
          <div class="panel-value" id="panelCreated">-</div>
        </div>
        <div class="panel-section">
          <div class="panel-label">Data quality</div>
          <div class="panel-value" id="panelQuality">-</div>
        </div>
        <div class="panel-section">
          <div class="panel-label">Rows</div>
          <div class="panel-value" id="panelRows">-</div>
        </div>
        <div class="panel-section">
          <div class="panel-label">Tags</div>
          <div class="panel-tags" id="panelTags">
            <span class="panel-tag">⟨⟩ SEMANTIC_CATEGORY | EMAIL</span>
            <span class="panel-tag">🏢 COST_CENTER | PRODUCT</span>
            <span class="panel-tag">🔒 PII | DATA</span>
          </div>
        </div>
        <div class="panel-section">
          <div class="panel-columns-header">Columns</div>
          <div class="panel-search">
            <input type="text" placeholder="Search columns">
          </div>
          <div class="panel-column-list" id="panelColumns">
            <div class="panel-column-item"><span class="panel-column-icon">⏱</span> PTIME</div>
            <div class="panel-column-item"><span class="panel-column-icon">△</span> TOPIC</div>
            <div class="panel-column-item"><span class="panel-column-icon">△</span> PRODUCT_KEY</div>
            <div class="panel-column-item"><span class="panel-column-icon">△</span> CITY</div>
          </div>
        </div>
      </div>
    </aside>
    </div>

    <!-- React Flow Graph View - UMD builds (dev for debugging) -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/reactflow@11.11.4/dist/umd/index.js"></script>
    <script src="https://unpkg.com/elkjs@0.9.3/lib/elk.bundled.js"></script>
    
    <!-- Mock Data with Column Lineage -->
    <script src="./mockData.js"></script>

    <script>
      // Wait for DOM and libraries to load
      document.addEventListener('DOMContentLoaded', function() {
        // Extract from globals
        const { useState, useCallback, useEffect, useMemo, createElement } = React;
        const { createRoot } = ReactDOM;
        
        // Extract ReactFlow components - use named exports, not default
        const ReactFlowComponent = window.ReactFlow.ReactFlow;
        const Controls = window.ReactFlow.Controls;
        const Background = window.ReactFlow.Background;
        const MiniMap = window.ReactFlow.MiniMap;
        const useNodesState = window.ReactFlow.useNodesState;
        const useEdgesState = window.ReactFlow.useEdgesState;
        const Position = window.ReactFlow.Position;
        const Handle = window.ReactFlow.Handle;
        const ReactFlowProvider = window.ReactFlow.ReactFlowProvider;
        const useReactFlow = window.ReactFlow.useReactFlow;
        const BackgroundVariant = window.ReactFlow.BackgroundVariant;
        const MarkerType = window.ReactFlow.MarkerType;
        
        // Check if ReactFlow loaded
        if (!ReactFlowComponent) {
          console.error('ReactFlow not loaded. Available:', Object.keys(window.ReactFlow || {}));
          return;
        }
        
        const ELK = window.ELK;

      // =============================================
      // Mock Data - loaded from mockData.js
      // Contains columns/features and column lineage
      // =============================================
      // Use the global mockLineageData from mockData.js
      // Also available: window.columnLineage, window.findRelatedColumns, etc.

      // =============================================
      // Data source color definitions
      // =============================================
      const NODE_COLORS = {
        // Data Warehouses
        snowflake: { primary: "#29B5E8", secondary: "#E7F6FD" },
        databricks: { primary: "#475467", secondary: "#F2F5F9" },
        bigquery: { primary: "#5086EC", secondary: "#F6F7FB" },
        redshift: { primary: "#205B99", secondary: "#F6F7FB" },
        
        // Databases
        postgres: { primary: "#336791", secondary: "#EFF2F3" },
        mysql: { primary: "#00546B", secondary: "#E6EFF2" },
        mssql: { primary: "#EA1B22", secondary: "#FCE9EA" },
        oracle: { primary: "#EA1B22", secondary: "#FCE9EA" },
        maria: { primary: "#32818E", secondary: "#EAF4F6" },
        mongo: { primary: "#26BC6A", secondary: "#E9F9F0" },
        cockroachdb: { primary: "#6431F9", secondary: "#F0EBFE" },
        
        // BI Tools
        tableau: { primary: "#2A5875", secondary: "#F5F5F5" },
        looker: { primary: "#33059F", secondary: "#F9F8FB" },
        metabase: { primary: "#227DE1", secondary: "#EEF6FC" },
        power_bi: { primary: "#F79009", secondary: "#FEF0C7" },
        sigma: { primary: "#101828", secondary: "#F1FFFD" },
        thoughtspot: { primary: "#4E55FD", secondary: "#E8EFFD" },
        mode: { primary: "#1D5243", secondary: "#EEF2E3" },
        hex: { primary: "#473982", secondary: "#F2F1F6" },
        omni: { primary: "#0176D3", secondary: "#E6F0FA" },
        periscope: { primary: "#F79009", secondary: "#FEF0C7" },
        quicksight: { primary: "#00B7F4", secondary: "#EEF6FC" },
        
        // ETL/Orchestration
        airflow: { primary: "#087B88", secondary: "#E6F4F5" },
        dbt: { primary: "#FB6514", secondary: "#FFF6ED" },
        fivetran: { primary: "#242527", secondary: "#F2F2F3" },
        glue: { primary: "#FB6514", secondary: "#FFF6ED" },
        
        // CRM/Marketing
        salesforce: { primary: "#00A1E0", secondary: "#E6F5FF" },
        hubspot: { primary: "#FF7A59", secondary: "#FFF2EE" },
        marketo: { primary: "#473866", secondary: "#F2F0F5" },
        braze: { primary: "#801ED7", secondary: "#F5EBFC" },
        
        // Cloud/Azure
        azure: { primary: "#2687CF", secondary: "#E8F4FC" },
        azure_sql_data_warehouse: { primary: "#2687CF", secondary: "#E8F4FC" },
        azure_sql_database: { primary: "#2687CF", secondary: "#E8F4FC" },
        
        // Google
        google_sheets: { primary: "#0F9D58", secondary: "#E7F6EE" },
        data_studio: { primary: "#1A73E8", secondary: "#EEF6FC" },
        
        // Other
        splunk: { primary: "#242527", secondary: "#F2F2F3" },
        workday: { primary: "#1565C0", secondary: "#E9F1FA" },
        
        // Default/fallback - neutral gray (equal R, G, B)
        default: { 
          primary: "#808080", 
          secondary: "#F5F5F5",
          bgColor: "rgba(128, 128, 128, 0.02)",
          borderColor: "rgba(128, 128, 128, 0.12)"
        },
        ml_models: { primary: "#7C3AED", secondary: "#F3E8FF" },
        exports: { 
          primary: "#808080", 
          secondary: "#F5F5F5",
          bgColor: "rgba(128, 128, 128, 0.02)",
          borderColor: "rgba(128, 128, 128, 0.12)"
        },
        external_apis: { 
          primary: "#808080", 
          secondary: "#F5F5F5",
          bgColor: "rgba(128, 128, 128, 0.02)",
          borderColor: "rgba(128, 128, 128, 0.12)"
        },
      };

      // Helper: Convert hex to RGB
      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (!result) return null;
        return {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        };
      }

      // Helper: Get source colors with fallback
      function getSourceColors(sourceId) {
        const normalizedId = (sourceId || '').toLowerCase().replace(/[^a-z0-9_]/g, '_');
        return NODE_COLORS[normalizedId] || NODE_COLORS.default;
      }

      // Helper: Extract source type from icon path
      function getSourceFromIcon(iconPath) {
        if (!iconPath) return 'default';
        // Extract filename from path like './img/logo-snowflake.svg' -> 'snowflake'
        const match = iconPath.match(/logo[_-]?([a-z0-9_]+)\.svg$/i) || 
                      iconPath.match(/([a-z0-9_]+)\.svg$/i);
        if (match) {
          return match[1].toLowerCase();
        }
        return 'default';
      }

      // Helper: Create background color with opacity
      function getSourceBgColor(sourceId, opacity = 0.03) {
        const colors = getSourceColors(sourceId);
        // Use pre-defined bgColor if available (for default/external_apis)
        if (colors.bgColor) return colors.bgColor;
        const rgb = hexToRgb(colors.primary);
        if (!rgb) return 'rgba(175, 206, 252, 0.04)'; // fallback to default
        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
      }

      // Helper: Create border color with opacity
      function getSourceBorderColor(sourceId, opacity = 0.12) {
        const colors = getSourceColors(sourceId);
        // Use pre-defined borderColor if available (for default/external_apis)
        if (colors.borderColor) return colors.borderColor;
        const rgb = hexToRgb(colors.primary);
        if (!rgb) return 'rgba(26, 108, 231, 0.20)'; // fallback to default
        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
      }

      // =============================================
      // Helper: Get column type icon image path
      // =============================================
      function getColumnTypeIcon(type) {
        const normalizedType = (type || '').toUpperCase();
        
        // String types
        if (['VARCHAR', 'TEXT', 'STRING', 'CHAR'].some(t => normalizedType.includes(t))) {
          return 'img/ui/text.svg';
        }
        // Integer/Number types
        if (['INTEGER', 'INT', 'BIGINT', 'NUMBER', 'SMALLINT', 'TINYINT'].some(t => normalizedType.includes(t))) {
          return 'img/ui/number.svg';
        }
        // Decimal/Float types
        if (['DECIMAL', 'FLOAT', 'DOUBLE', 'NUMERIC', 'REAL'].some(t => normalizedType.includes(t))) {
          return 'img/ui/number.svg';
        }
        // Boolean types
        if (['BOOLEAN', 'BOOL'].some(t => normalizedType.includes(t))) {
          return 'img/ui/boolean.svg';
        }
        // Binary types
        if (['BINARY', 'VARBINARY', 'BLOB', 'BYTES'].some(t => normalizedType.includes(t))) {
          return 'img/ui/binary.svg';
        }
        // Date types
        if (normalizedType.includes('DATE') && !normalizedType.includes('TIME')) {
          return 'img/ui/calendar.svg';
        }
        // Timestamp types
        if (['TIMESTAMP', 'DATETIME', 'TIME'].some(t => normalizedType.includes(t))) {
          return 'img/ui/calendar.svg';
        }
        // JSON/Code types
        if (['JSON', 'VARIANT'].some(t => normalizedType.includes(t))) {
          return 'img/ui/format-code.svg';
        }
        // Object types
        if (['OBJECT', 'STRUCT', 'MAP'].some(t => normalizedType.includes(t))) {
          return 'img/ui/object.svg';
        }
        // Array types
        if (normalizedType.includes('ARRAY')) {
          return 'img/ui/array.svg';
        }
        // Measure (BI) - numeric
        if (normalizedType === 'MEASURE') {
          return 'img/ui/number.svg';
        }
        // Dimension (BI) - object-like
        if (normalizedType === 'DIMENSION') {
          return 'img/ui/object.svg';
        }
        // ML Feature types
        if (normalizedType === 'CATEGORICAL' || normalizedType === 'SEQUENCE') {
          return 'img/ui/object.svg';
        }
        // Default
        return 'img/ui/column-single.svg';
      }

      // =============================================
      // Component: Column/Feature Type Icon
      // =============================================
      function ColumnTypeIcon({ type }) {
        const iconSrc = getColumnTypeIcon(type);
        return React.createElement('img', { 
          className: 'graph-child-type-icon',
          src: iconSrc,
          alt: type || 'column',
          title: type,
          width: 16,
          height: 16
        });
      }

      // =============================================
      // Component: Key Icon (Primary/Foreign)
      // =============================================
      function KeyIcon({ isPrimaryKey, isForeignKey }) {
        if (isPrimaryKey) {
          return React.createElement('img', { 
            className: 'graph-child-key-icon primary-key',
            src: 'img/ui/ownership.svg',
            alt: 'Primary Key',
            title: 'Primary Key',
            width: 16,
            height: 16
          });
        }
        if (isForeignKey) {
          return React.createElement('img', { 
            className: 'graph-child-key-icon foreign-key',
            src: 'img/ui/format-link.svg',
            alt: 'Foreign Key',
            title: 'Foreign Key',
            width: 16,
            height: 16
          });
        }
        return null;
      }

      // =============================================
      // Component: Children List (Columns/Features)
      // =============================================
      function ChildrenList({ 
        children, 
        searchQuery, 
        onSearchChange,
        selectedChildren,
        onChildClick,
        onChildHover,
        listHeight,
        isFeatureList,
        nodeId,
        itemId,
        columnLineageMode,
        sourceColumn,
        relatedColumns
      }) {
        // Determine if a child is the source column or a related column
        const getColumnLineageClass = (childName) => {
          if (!columnLineageMode) return '';
          if (sourceColumn?.itemId === itemId && sourceColumn?.columnName === childName) {
            return 'column-lineage-source';
          }
          if (relatedColumns?.has?.(itemId) && relatedColumns.get(itemId).has(childName)) {
            return 'column-lineage-related';
          }
          return '';
        };
        
        // Separate pinned (lineage-related) columns from regular columns
        const pinnedColumns = [];
        const regularColumns = [];
        
        (children || []).forEach(child => {
          const lineageClass = getColumnLineageClass(child.name);
          if (lineageClass) {
            pinnedColumns.push({ ...child, lineageClass });
          } else {
            regularColumns.push(child);
          }
        });
        
        // Filter regular children by search query (pinned columns are always shown)
        const filteredRegularChildren = regularColumns.filter(child => {
          if (!searchQuery) return true;
          const query = searchQuery.toLowerCase();
          return child.name.toLowerCase().includes(query) || 
                 (child.type && child.type.toLowerCase().includes(query));
        });
        
        // Render a single column item
        const renderColumnItem = (child, index, isPinned, lineageClass) => {
          const isSelected = selectedChildren?.has?.(child.name);
          const showHandles = isPinned; // Only render handles when in column lineage mode
          
          return React.createElement('div', {
            key: child.name + '-' + index + (isPinned ? '-pinned' : ''),
            className: `graph-child-item ${isSelected ? 'selected' : ''} ${lineageClass || ''} ${isPinned ? 'pinned' : ''}`,
            onClick: (e) => {
              e.stopPropagation();
              onChildClick?.(child.name);
            },
            onMouseEnter: () => onChildHover?.(child.name),
            onMouseLeave: () => onChildHover?.(null)
          },
            // Left handle for column input (target)
            showHandles && React.createElement(Handle, {
              type: 'target',
              position: Position.Left,
              id: `column-in-${itemId}-${child.name}`,
              className: 'column-handle-left',
              style: { 
                left: -4,
                top: '50%',
                transform: 'translateY(-50%)',
                width: 8,
                height: 8,
                background: '#1A6CE7',
                border: '2px solid #FFF'
              }
            }),
            // Type icon
            React.createElement(ColumnTypeIcon, { type: child.type }),
            // Name
            React.createElement('span', { className: 'graph-child-name' }, child.name),
            // Key indicator
            React.createElement(KeyIcon, { 
              isPrimaryKey: child.isPrimaryKey, 
              isForeignKey: child.isForeignKey 
            }),
            // Feature importance bar (for ML models)
            child.importance !== undefined && React.createElement('div', { 
              className: 'graph-child-importance',
              title: `Importance: ${(child.importance * 100).toFixed(0)}%`
            },
              React.createElement('div', { 
                className: 'graph-child-importance-bar',
                style: { width: `${child.importance * 100}%` }
              })
            ),
            // Type label (optional, hide for pinned/lineage mode)
            !child.importance && !isPinned && React.createElement('span', { 
              className: 'graph-child-type' 
            }, child.type),
            // Right handle for column output (source)
            showHandles && React.createElement(Handle, {
              type: 'source',
              position: Position.Right,
              id: `column-out-${itemId}-${child.name}`,
              className: 'column-handle-right',
              style: { 
                right: -4,
                top: '50%',
                transform: 'translateY(-50%)',
                width: 8,
                height: 8,
                background: '#1A6CE7',
                border: '2px solid #FFF'
              }
            })
          );
        };

        return React.createElement('div', { className: 'graph-children-section' },
          // Pinned columns (outside scrollable area)
          pinnedColumns.length > 0 && React.createElement('div', { className: 'graph-children-pinned' },
            pinnedColumns.map((child, index) => 
              renderColumnItem(child, index, true, child.lineageClass)
            )
          ),
          // Search input (hide in lineage mode)
          !columnLineageMode && React.createElement('div', { className: 'graph-children-search' },
            React.createElement('input', {
              type: 'text',
              className: 'graph-children-search-input',
              placeholder: isFeatureList ? 'Features' : 'Columns.',
              value: searchQuery || '',
              onChange: (e) => {
                e.stopPropagation();
                onSearchChange?.(e.target.value);
              },
              onClick: (e) => e.stopPropagation(),
              onMouseDown: (e) => e.stopPropagation()
            })
          ),
          // Regular children list (scrollable)
          React.createElement('div', { 
            className: 'graph-children-list nowheel',
            style: { maxHeight: listHeight || 240 },
            onWheelCapture: (e) => {
              e.stopPropagation();
              e.nativeEvent.stopImmediatePropagation();
            }
          },
            filteredRegularChildren.length === 0 
              ? React.createElement('div', { className: 'graph-children-empty' }, 
                  searchQuery ? 'No matches found' : (pinnedColumns.length > 0 ? '' : 'No columns')
                )
              : filteredRegularChildren.map((child, index) => 
                  renderColumnItem(child, index, false, '')
                )
          )
        );
      }

      // =============================================
      // Component: Expanded Item Card with Children
      // =============================================
      function ExpandedItemCard({
        item,
        isSelected,
        isFocal,
        childrenExpanded,
        onToggleChildren,
        searchQuery,
        onSearchChange,
        selectedChildren,
        onChildClick,
        onChildHover,
        nodeId,
        columnLineageMode,
        sourceColumn,
        relatedColumns,
        onItemClick
      }) {
        const hasChildren = item.columns?.length > 0 || item.features?.length > 0;
        const children = item.features || item.columns || [];
        const isFeatureList = item.features?.length > 0;
        const childLabel = isFeatureList ? 'features' : 'columns';
        
        // Check if this card is active in column lineage mode
        const isLineageActive = columnLineageMode && (
          sourceColumn?.itemId === item.id || 
          relatedColumns?.has?.(item.id)
        );

        return React.createElement('div', { 
          className: `graph-expanded-card ${isSelected ? 'selected' : ''} ${isFocal ? 'focal' : ''} ${isLineageActive ? 'column-lineage-active' : ''}`
        },
          // Header (clickable to select item)
          React.createElement('div', { 
            className: 'graph-expanded-header',
            onClick: (e) => {
              e.stopPropagation();
              onItemClick?.();
            },
            style: { cursor: 'pointer' }
          },
            isFocal && React.createElement('div', { className: 'graph-expanded-badge' }, 'Currently viewing'),
            React.createElement('div', { className: 'graph-expanded-info' },
              React.createElement('img', { className: 'graph-expanded-icon', src: item.icon, alt: '' }),
              React.createElement('span', { className: 'graph-expanded-name' }, item.name)
            )
          ),
          // Children section (when expanded)
          childrenExpanded && hasChildren && React.createElement(ChildrenList, {
            children: children,
            searchQuery: searchQuery,
            onSearchChange: onSearchChange,
            selectedChildren: selectedChildren,
            onChildClick: onChildClick,
            onChildHover: onChildHover,
            isFeatureList: isFeatureList,
            nodeId: nodeId,
            itemId: item.id,
            columnLineageMode: columnLineageMode,
            sourceColumn: sourceColumn,
            relatedColumns: relatedColumns
          }),
          // Model outputs section (for ML models)
          childrenExpanded && item.outputs?.length > 0 && React.createElement('div', { className: 'graph-outputs-section' },
            React.createElement('div', { className: 'graph-outputs-header' }, 'Outputs'),
            React.createElement(ChildrenList, {
              children: item.outputs,
              searchQuery: '',
              isFeatureList: false,
              nodeId: nodeId,
              itemId: item.id,
              columnLineageMode: columnLineageMode,
              sourceColumn: sourceColumn,
              relatedColumns: relatedColumns
            })
          ),
          // Toggle button
          hasChildren && React.createElement('button', {
            className: `graph-toggle-children-btn ${childrenExpanded ? 'expanded' : ''}`,
            onClick: (e) => {
              e.stopPropagation();
              onToggleChildren?.();
            }
          },
            childrenExpanded 
              ? `Hide ${childLabel}` 
              : `${children.length} ${childLabel}`,
            React.createElement('svg', { 
              viewBox: '0 0 12 12', 
              fill: 'none',
              xmlns: 'http://www.w3.org/2000/svg'
            },
              React.createElement('path', {
                d: 'M3 5l3 3 3-3',
                stroke: 'currentColor',
                strokeWidth: '1.5',
                strokeLinecap: 'round',
                strokeLinejoin: 'round'
              })
            )
          )
        );
      }

      // =============================================
      // Custom Node: Object Card (single table/view)
      // =============================================
      function ObjectCardNode({ data, selected, id }) {
        const { item, onItemClick, selectedItemId, isFocal } = data;
        const isSelected = selected || selectedItemId === item.id;

        return React.createElement('div', { 
          className: `graph-object-card ${isSelected ? 'selected' : ''} ${isFocal ? 'focal' : ''}`,
          onClick: () => onItemClick?.(item, id)
        },
          React.createElement(Handle, {
            type: 'target',
            position: Position.Left,
            id: 'left'
          }),
          // Focal badge
          isFocal && React.createElement('div', { className: 'graph-object-focal-badge' }, 'Currently viewing'),
          // Object info
          React.createElement('div', { className: 'graph-object-info' },
            React.createElement('img', { className: 'graph-object-icon', src: item.icon, alt: '' }),
            React.createElement('span', { className: 'graph-object-name' }, item.name)
          ),
          React.createElement(Handle, {
            type: 'source',
            position: Position.Right,
            id: 'right'
          })
        );
      }

      // =============================================
      // Custom Node: Group Node (database > schema > items)
      // =============================================
      function GroupNode({ data, id }) {
        const { 
          database, schema, icon, sourceId, items, onItemClick, selectedItemId, 
          dbCollapsed, schemaCollapsed, onToggleDbCollapse, onToggleSchemaCollapse,
          expandedItems, onToggleItemExpand, itemSearchQueries, onItemSearchChange,
          selectedChildren, onChildClick, onChildHover,
          columnLineageMode, sourceColumn, relatedColumns
        } = data;
        
        // Get colors for this source
        const bgColor = getSourceBgColor(sourceId, 0.03);
        const borderColor = getSourceBorderColor(sourceId, 0.12);
        const isSingleItem = items.length === 1;
        const isCollapsed = dbCollapsed || schemaCollapsed;

        // Calculate handle position based on collapse state
        const getCollapsedHandleTop = () => {
          if (dbCollapsed) {
            return '24px';
          }
          if (schemaCollapsed) {
            return '62px';
          }
          return '50%';
        };

        const handleDbHeaderClick = (e) => {
          e.stopPropagation();
          onToggleDbCollapse?.(id);
        };

        const handleSchemaHeaderClick = (e) => {
          e.stopPropagation();
          onToggleSchemaCollapse?.(id);
        };

        const collapsedHandleTop = getCollapsedHandleTop();

        // Render an item - either expanded or compact
        const renderItem = (item, index) => {
          const isSelected = selectedItemId === item.id;
          const isExpanded = expandedItems?.[item.id] || false;
          const hasChildren = item.columns?.length > 0 || item.features?.length > 0;
          const searchQuery = itemSearchQueries?.[item.id] || '';
          
          // Check if this item is involved in column lineage
          const isInColumnLineage = columnLineageMode && (
            sourceColumn?.itemId === item.id || 
            relatedColumns?.has?.(item.id)
          );

          // In column lineage mode, show expanded card for items with related columns
          if (isInColumnLineage && hasChildren && isExpanded) {
            return React.createElement('div', {
              key: item.id,
              style: { position: 'relative' }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '28px' }
              }),
              React.createElement(ExpandedItemCard, {
                item: item,
                isSelected: false,
                isFocal: item.isFocal,
                childrenExpanded: true,
                onToggleChildren: () => onToggleItemExpand?.(item.id),
                searchQuery: searchQuery,
                onSearchChange: (query) => onItemSearchChange?.(item.id, query),
                selectedChildren: selectedChildren?.[item.id],
                onChildClick: (childName) => onChildClick?.(item.id, childName),
                onChildHover: (childName) => onChildHover?.(item.id, childName),
                nodeId: id,
                columnLineageMode: columnLineageMode,
                sourceColumn: sourceColumn,
                relatedColumns: relatedColumns,
                onItemClick: () => onItemClick?.(item, id)
              }),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '28px' }
              })
            );
          }

          // If selected AND has children AND expanded, show expanded card
          if (isSelected && hasChildren && isExpanded) {
            return React.createElement('div', {
              key: item.id,
              style: { position: 'relative' }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '28px' }
              }),
              React.createElement(ExpandedItemCard, {
                item: item,
                isSelected: true,
                isFocal: item.isFocal,
                childrenExpanded: true,
                onToggleChildren: () => onToggleItemExpand?.(item.id),
                searchQuery: searchQuery,
                onSearchChange: (query) => onItemSearchChange?.(item.id, query),
                selectedChildren: selectedChildren?.[item.id],
                onChildClick: (childName) => onChildClick?.(item.id, childName),
                onChildHover: (childName) => onChildHover?.(item.id, childName),
                nodeId: id,
                columnLineageMode: columnLineageMode,
                sourceColumn: sourceColumn,
                relatedColumns: relatedColumns,
                onItemClick: () => onItemClick?.(item, id)
              }),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '28px' }
              })
            );
          }

          // If selected with children but NOT expanded, show card with toggle button
          if (isSelected && hasChildren) {
            const children = item.features || item.columns || [];
            const childLabel = item.features?.length > 0 ? 'features' : 'columns';
            
            return React.createElement('div', {
              key: item.id,
              className: `graph-expanded-card selected ${item.isFocal ? 'focal' : ''}`,
              onClick: (e) => {
                e.stopPropagation();
                onItemClick?.(item, id);
              },
              style: { position: 'relative' }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '28px' }
              }),
              React.createElement('div', { className: 'graph-expanded-header' },
                item.isFocal && React.createElement('div', { className: 'graph-expanded-badge' }, 'Currently viewing'),
                React.createElement('div', { className: 'graph-expanded-info' },
                  React.createElement('img', { className: 'graph-expanded-icon', src: item.icon, alt: '' }),
                  React.createElement('span', { className: 'graph-expanded-name' }, item.name)
                )
              ),
              React.createElement('button', {
                className: 'graph-toggle-children-btn',
                onClick: (e) => {
                  e.stopPropagation();
                  onToggleItemExpand?.(item.id);
                }
              },
                `${children.length} ${childLabel}`,
                React.createElement('svg', { 
                  viewBox: '0 0 12 12', 
                  fill: 'none',
                  xmlns: 'http://www.w3.org/2000/svg'
                },
                  React.createElement('path', {
                    d: 'M3 5l3 3 3-3',
                    stroke: 'currentColor',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round'
                  })
                )
              ),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '28px' }
              })
            );
          }

          // Default: Single item card or compact item
          if (isSingleItem) {
            return React.createElement('div', {
              key: item.id,
              className: `graph-group-card ${isSelected ? 'selected' : ''} ${item.isFocal ? 'focal' : ''}`,
              onClick: (e) => {
                e.stopPropagation();
                onItemClick?.(item, id);
              }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '50%', transform: 'translateY(-50%)' }
              }),
              item.isFocal && React.createElement('div', { className: 'graph-group-card-badge' }, 'Currently viewing'),
              React.createElement('div', { className: 'graph-group-card-content' },
                React.createElement('img', { className: 'graph-group-card-icon', src: item.icon, alt: '' }),
                React.createElement('span', { className: 'graph-group-card-name' }, item.name)
              ),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '50%', transform: 'translateY(-50%)' }
              })
            );
          }

          // Multiple items - compact list item
          return React.createElement('div', {
            key: item.id,
            className: `graph-group-item ${isSelected ? 'selected' : ''} ${item.isFocal ? 'focal' : ''}`,
            onClick: (e) => {
              e.stopPropagation();
              onItemClick?.(item, id);
            }
          },
            React.createElement(Handle, {
              type: 'target',
              position: Position.Left,
              id: `left-${item.id}`,
              style: { top: 'auto', bottom: 'auto' }
            }),
            React.createElement('img', { className: 'graph-group-item-icon', src: item.icon, alt: '' }),
            React.createElement('span', { className: 'graph-group-item-name' }, item.name),
            React.createElement(Handle, {
              type: 'source',
              position: Position.Right,
              id: `right-${item.id}`,
              style: { top: 'auto', bottom: 'auto' }
            })
          );
        };

        return React.createElement('div', { 
          className: 'graph-group-container',
          style: {
            padding: '0'
          }
        },
          // Collapsed handles
          isCollapsed && items.map(item => 
            React.createElement(React.Fragment, { key: `collapsed-handles-${item.id}` },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: collapsedHandleTop, transform: 'translateY(-50%)' }
              }),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: collapsedHandleTop, transform: 'translateY(-50%)' }
              })
            )
          ),
          // Database header
          React.createElement('div', { 
            className: `graph-group-db-header ${dbCollapsed ? 'collapsed' : ''}`,
            onClick: handleDbHeaderClick
          },
            React.createElement('img', { className: 'graph-group-db-icon', src: icon, alt: '' }),
            React.createElement('img', { className: 'graph-group-db-icon', src: './img/ui/database.svg', alt: '' }),
            React.createElement('span', { className: 'graph-group-db-name' }, database)
          ),
          // Schema section
          !dbCollapsed && React.createElement('div', { 
            className: 'graph-group-schema-section',
            style: {
              background: bgColor,
              border: `1px solid ${borderColor}`,
              borderRadius: '8px',
              padding: '8px'
            }
          },
            React.createElement('div', { 
              className: `graph-group-schema-header ${schemaCollapsed ? 'collapsed' : ''}`,
              onClick: handleSchemaHeaderClick
            },
              React.createElement('img', { className: 'graph-group-schema-icon', src: './img/ui/schema.svg', alt: '' }),
              React.createElement('span', { className: 'graph-group-schema-name' }, schema)
            ),
            !schemaCollapsed && React.createElement('div', { className: 'graph-group-items' },
              items.map(renderItem)
            )
          )
        );
      }

      // =============================================
      // Custom Node: Platform Group (Tableau, Looker, etc)
      // =============================================
      function PlatformGroupNode({ data, id }) {
        const { 
          name, icon, items, platformId, onItemClick, selectedItemId, collapsed, onToggleCollapse,
          expandedItems, onToggleItemExpand, itemSearchQueries, onItemSearchChange,
          selectedChildren, onChildClick, onChildHover,
          columnLineageMode, sourceColumn, relatedColumns
        } = data;

        const handleHeaderClick = (e) => {
          e.stopPropagation();
          onToggleCollapse?.(id);
        };

        const collapsedHandleTop = '24px';

        // Render an item - either expanded or compact
        const renderItem = (item, index) => {
          const isSelected = selectedItemId === item.id;
          const isExpanded = expandedItems?.[item.id] || false;
          const hasChildren = item.columns?.length > 0 || item.features?.length > 0;
          const searchQuery = itemSearchQueries?.[item.id] || '';
          
          // Check if this item is involved in column lineage
          const isInColumnLineage = columnLineageMode && (
            sourceColumn?.itemId === item.id || 
            relatedColumns?.has?.(item.id)
          );

          // In column lineage mode, show expanded card for items with related columns
          if (isInColumnLineage && hasChildren && isExpanded) {
            return React.createElement('div', {
              key: item.id,
              style: { position: 'relative' }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '28px' }
              }),
              React.createElement(ExpandedItemCard, {
                item: item,
                isSelected: false,
                isFocal: false,
                childrenExpanded: true,
                onToggleChildren: () => onToggleItemExpand?.(item.id),
                searchQuery: searchQuery,
                onSearchChange: (query) => onItemSearchChange?.(item.id, query),
                selectedChildren: selectedChildren?.[item.id],
                onChildClick: (childName) => onChildClick?.(item.id, childName),
                onChildHover: (childName) => onChildHover?.(item.id, childName),
                nodeId: id,
                columnLineageMode: columnLineageMode,
                sourceColumn: sourceColumn,
                relatedColumns: relatedColumns,
                onItemClick: () => onItemClick?.(item, id)
              }),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '28px' }
              })
            );
          }

          // If selected AND has children AND expanded, show expanded card
          if (isSelected && hasChildren && isExpanded) {
            return React.createElement('div', {
              key: item.id,
              style: { position: 'relative' }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '28px' }
              }),
              React.createElement(ExpandedItemCard, {
                item: item,
                isSelected: true,
                isFocal: false,
                childrenExpanded: true,
                onToggleChildren: () => onToggleItemExpand?.(item.id),
                searchQuery: searchQuery,
                onSearchChange: (query) => onItemSearchChange?.(item.id, query),
                selectedChildren: selectedChildren?.[item.id],
                onChildClick: (childName) => onChildClick?.(item.id, childName),
                onChildHover: (childName) => onChildHover?.(item.id, childName),
                nodeId: id,
                columnLineageMode: columnLineageMode,
                sourceColumn: sourceColumn,
                relatedColumns: relatedColumns,
                onItemClick: () => onItemClick?.(item, id)
              }),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '28px' }
              })
            );
          }

          // If selected with children but NOT expanded, show card with toggle button
          if (isSelected && hasChildren) {
            const children = item.features || item.columns || [];
            const childLabel = item.features?.length > 0 ? 'features' : 'columns';
            
            return React.createElement('div', {
              key: item.id,
              className: 'graph-expanded-card selected',
              onClick: (e) => {
                e.stopPropagation();
                onItemClick?.(item, id);
              },
              style: { position: 'relative' }
            },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: '28px' }
              }),
              React.createElement('div', { className: 'graph-expanded-header' },
                React.createElement('div', { className: 'graph-expanded-info' },
                  React.createElement('img', { className: 'graph-expanded-icon', src: item.icon, alt: '' }),
                  React.createElement('span', { className: 'graph-expanded-name' }, item.name)
                )
              ),
              React.createElement('button', {
                className: 'graph-toggle-children-btn',
                onClick: (e) => {
                  e.stopPropagation();
                  onToggleItemExpand?.(item.id);
                }
              },
                `${children.length} ${childLabel}`,
                React.createElement('svg', { 
                  viewBox: '0 0 12 12', 
                  fill: 'none',
                  xmlns: 'http://www.w3.org/2000/svg'
                },
                  React.createElement('path', {
                    d: 'M3 5l3 3 3-3',
                    stroke: 'currentColor',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round'
                  })
                )
              ),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: '28px' }
              })
            );
          }

          // Default compact platform item
          return React.createElement('div', {
            key: item.id,
            className: `graph-platform-item ${isSelected ? 'selected' : ''}`,
            onClick: (e) => {
              e.stopPropagation();
              onItemClick?.(item, id);
            }
          },
            React.createElement(Handle, {
              type: 'target',
              position: Position.Left,
              id: `left-${item.id}`,
              style: { top: 'auto', bottom: 'auto' }
            }),
            React.createElement('img', { className: 'graph-platform-item-icon', src: item.icon, alt: '' }),
            React.createElement('span', { className: 'graph-platform-item-name' }, item.name),
            React.createElement(Handle, {
              type: 'source',
              position: Position.Right,
              id: `right-${item.id}`,
              style: { top: 'auto', bottom: 'auto' }
            })
          );
        };

        // Get colors for this platform
        const bgColor = getSourceBgColor(platformId, 0.03);
        const borderColor = getSourceBorderColor(platformId, 0.12);

        // Determine group label based on item types
        const getGroupLabel = () => {
          if (!items || items.length === 0) return 'Items';
          const firstItem = items[0];
          if (firstItem.type === 'dashboard' || firstItem.icon?.includes('dashboard')) return 'Dashboards';
          if (firstItem.type === 'semantic_model' || firstItem.type === 'semanticModel') return 'Semantic models';
          if (firstItem.type === 'report') return 'Reports';
          if (firstItem.type === 'look') return 'Looks';
          if (firstItem.type === 'explore') return 'Explores';
          if (firstItem.type === 'worksheet') return 'Worksheets';
          if (firstItem.type === 'workbook') return 'Workbooks';
          return data.groupLabel || 'Items';
        };

        const groupLabel = getGroupLabel();

        // Get icon for group label
        const getGroupIcon = () => {
          if (groupLabel === 'Dashboards') return './img/ui/dashboards.svg';
          if (groupLabel === 'Semantic models') return './img/ui/data-semantic.svg';
          if (groupLabel === 'Reports') return './img/ui/dashboards.svg';
          if (groupLabel === 'Looks') return './img/ui/dashboards.svg';
          if (groupLabel === 'Explores') return './img/ui/table.svg';
          if (groupLabel === 'Worksheets') return './img/ui/table.svg';
          if (groupLabel === 'Workbooks') return './img/ui/dashboards.svg';
          return './img/ui/table.svg';
        };

        const groupIcon = getGroupIcon();

        return React.createElement('div', { 
          className: `graph-platform-container platform-${platformId}`,
          style: {
            background: 'transparent',
            border: 'none',
            borderRadius: '12px',
            padding: '8px'
          }
        },
          // Collapsed handles
          collapsed && items.map(item => 
            React.createElement(React.Fragment, { key: `collapsed-handles-${item.id}` },
              React.createElement(Handle, {
                type: 'target',
                position: Position.Left,
                id: `left-${item.id}`,
                style: { top: collapsedHandleTop, transform: 'translateY(-50%)' }
              }),
              React.createElement(Handle, {
                type: 'source',
                position: Position.Right,
                id: `right-${item.id}`,
                style: { top: collapsedHandleTop, transform: 'translateY(-50%)' }
              })
            )
          ),
          // Platform header (outside colored section - like db header)
          React.createElement('div', { 
            className: `graph-group-db-header ${collapsed ? 'collapsed' : ''}`,
            onClick: handleHeaderClick
          },
            React.createElement('img', { className: 'graph-group-db-icon', src: icon, alt: '' }),
            React.createElement('span', { className: 'graph-group-db-name' }, name)
          ),
          // Inner group section (colored container - like schema section)
          !collapsed && React.createElement('div', { 
            className: 'graph-group-schema-section',
            style: {
              background: bgColor,
              border: `1px solid ${borderColor}`,
              borderRadius: '8px',
              padding: '8px'
            }
          },
            // Group type header (like schema header)
            React.createElement('div', { 
              className: 'graph-group-schema-header'
            },
              React.createElement('img', { className: 'graph-group-schema-icon', src: groupIcon, alt: '' }),
              React.createElement('span', { className: 'graph-group-schema-name' }, groupLabel),
              React.createElement('span', { className: 'graph-group-schema-count' }, items.length)
            ),
            // Items list
            React.createElement('div', { className: 'graph-platform-items' },
              items.map(renderItem)
            )
          )
        );
      }

      // =============================================
      // Node Types Registry
      // =============================================
      const nodeTypes = {
        objectCard: ObjectCardNode,
        groupNode: GroupNode,
        platformGroup: PlatformGroupNode,
      };

      // =============================================
      // ELK Layout Configuration
      // =============================================
      const elk = new ELK();

      const elkLayoutOptions = {
        'elk.algorithm': 'layered',
        'elk.direction': 'RIGHT',
        'elk.spacing.nodeNode': '72',
        'elk.layered.spacing.nodeNodeBetweenLayers': '120',
        'elk.layered.spacing.edgeNodeBetweenLayers': '40',
        'elk.edgeRouting': 'SPLINES',
        'elk.layered.nodePlacement.strategy': 'BRANDES_KOEPF',
        'elk.layered.nodePlacement.bk.fixedAlignment': 'BALANCED',
        'elk.layered.crossingMinimization.strategy': 'LAYER_SWEEP',
        'elk.contentAlignment': 'V_CENTER',
        'elk.nodeLabels.placement': 'INSIDE V_CENTER H_CENTER',
      };

      async function calculateLayout(nodes, edges) {
        const elkGraph = {
          id: 'root',
          layoutOptions: elkLayoutOptions,
          children: nodes.map(node => ({
            id: node.id,
            width: node.data.width || 240,
            height: node.data.height || 100,
            // Assign layer based on depth
            layoutOptions: {
              'elk.layered.layerConstraint': node.data.layer !== undefined ? node.data.layer.toString() : undefined,
            }
          })),
          edges: edges.map(edge => ({
            id: edge.id,
            sources: [edge.source],
            targets: [edge.target],
          })),
        };

        const layoutedGraph = await elk.layout(elkGraph);

        // First pass: get positions from ELK
        const layoutedNodes = nodes.map(node => {
          const layoutedNode = layoutedGraph.children.find(n => n.id === node.id);
          return {
            ...node,
            position: {
              x: layoutedNode?.x || 0,
              y: layoutedNode?.y || 0,
            },
          };
        });

        // Second pass: center each column vertically
        // Group nodes by layer
        const nodesByLayer = {};
        layoutedNodes.forEach(node => {
          const layer = node.data.layer;
          if (layer !== undefined) {
            if (!nodesByLayer[layer]) {
              nodesByLayer[layer] = [];
            }
            nodesByLayer[layer].push(node);
          }
        });

        // Find global min and max Y across all nodes to determine canvas height
        let globalMinY = Infinity;
        let globalMaxY = -Infinity;
        layoutedNodes.forEach(node => {
          const nodeHeight = node.data.height || 100;
          globalMinY = Math.min(globalMinY, node.position.y);
          globalMaxY = Math.max(globalMaxY, node.position.y + nodeHeight);
        });
        const canvasHeight = globalMaxY - globalMinY;
        const canvasCenterY = globalMinY + canvasHeight / 2;

        // Center each layer's nodes vertically
        Object.keys(nodesByLayer).forEach(layer => {
          const layerNodes = nodesByLayer[layer];
          
          // Find layer's vertical extent
          let layerMinY = Infinity;
          let layerMaxY = -Infinity;
          layerNodes.forEach(node => {
            const nodeHeight = node.data.height || 100;
            layerMinY = Math.min(layerMinY, node.position.y);
            layerMaxY = Math.max(layerMaxY, node.position.y + nodeHeight);
          });
          
          const layerHeight = layerMaxY - layerMinY;
          const layerCenterY = layerMinY + layerHeight / 2;
          const offsetY = canvasCenterY - layerCenterY;
          
          // Apply offset to center the layer
          layerNodes.forEach(node => {
            node.position.y += offsetY;
          });
        });

        return layoutedNodes;
      }

      // =============================================
      // Transform Mock Data to Nodes & Edges
      // Groups with compact cards, focal as single card
      // =============================================
      function transformDataToNodesAndEdges(data, onItemClick, selectedItemId, collapseHandlers = {}) {
        const { onToggleDbCollapse, onToggleSchemaCollapse, onTogglePlatformCollapse } = collapseHandlers;
        const nodes = [];
        const edges = [];
        const allItems = [];
        const itemToHandleMap = new Map(); // Map item id to node id and handle id

        data.depths.forEach((depth, depthIndex) => {
          depth.groups.forEach((group, groupIndex) => {
            
            if (group.type === 'database' && group.schemas) {
              // Database group with schemas - create group nodes
              group.schemas.forEach((schema, schemaIndex) => {
                const groupNodeId = `group-${group.id}-${schema.id}`;
                const itemHeight = 40;
                const headerHeight = 70;
                const nodeHeight = headerHeight + (schema.items.length * itemHeight) + 24;
                
                // Check if this group contains the focal item
                const hasFocal = schema.items.some(item => item.isFocal);
                
                // Always use groupNode for database/schema structures
                // Enrich items with database and schema info
                const enrichedItems = schema.items.map(item => ({
                  ...item,
                  database: group.database,
                  schemaName: schema.name
                }));
                
                nodes.push({
                  id: groupNodeId,
                  type: 'groupNode',
                  position: { x: 0, y: 0 },
                  data: {
                    database: group.database,
                    schema: schema.name,
                    icon: group.icon,
                    sourceId: getSourceFromIcon(group.icon), // e.g., 'snowflake', 'databricks'
                    items: enrichedItems,
                    onItemClick,
                    selectedItemId,
                    hasFocal,
                    layer: depthIndex,
                    width: 340,
                    height: nodeHeight,
                    dbCollapsed: false,
                    schemaCollapsed: false,
                    onToggleDbCollapse,
                    onToggleSchemaCollapse,
                  },
                });
                  
                // Map each item to handles on this group node
                enrichedItems.forEach(item => {
                  itemToHandleMap.set(item.id, { 
                    nodeId: groupNodeId, 
                    sourceHandle: `right-${item.id}`,
                    targetHandle: `left-${item.id}`
                  });
                  allItems.push({ ...item, nodeId: groupNodeId, isFocal: item.isFocal });
                });
              });
              
            } else if (group.type === 'platform' && group.items) {
              // Platform group (Tableau, Looker, etc)
              const platformNodeId = `platform-${group.id}`;
              const itemHeight = 40;
              const headerHeight = 40;
              const nodeHeight = headerHeight + (group.items.length * itemHeight) + 16;
              
              // Enrich items with platform info
              const enrichedPlatformItems = group.items.map(item => ({
                ...item,
                platform: group.name
              }));
              
              nodes.push({
                id: platformNodeId,
                type: 'platformGroup',
                position: { x: 0, y: 0 },
                data: {
                  name: group.name,
                  icon: group.icon,
                  items: enrichedPlatformItems,
                  platformId: group.id,
                  onItemClick,
                  selectedItemId,
                  layer: depthIndex,
                  width: 340,
                  height: nodeHeight,
                  collapsed: false,
                  onToggleCollapse: onTogglePlatformCollapse,
                },
              });
              
              // Map each item to handles on this platform node
              enrichedPlatformItems.forEach(item => {
                itemToHandleMap.set(item.id, { 
                  nodeId: platformNodeId, 
                  sourceHandle: `right-${item.id}`,
                  targetHandle: `left-${item.id}`
                });
                allItems.push({ ...item, nodeId: platformNodeId });
              });
            }
          });
        });

        // Create edges between items using handle mapping
        allItems.forEach(item => {
          if (item.downstream && item.downstream.length > 0) {
            item.downstream.forEach(targetItemId => {
              const sourceMapping = itemToHandleMap.get(item.id);
              const targetMapping = itemToHandleMap.get(targetItemId);
              
              if (sourceMapping && targetMapping) {
                edges.push({
                  id: `edge-${item.id}-${targetItemId}`,
                  source: sourceMapping.nodeId,
                  sourceHandle: sourceMapping.sourceHandle,
                  target: targetMapping.nodeId,
                  targetHandle: targetMapping.targetHandle,
                  type: 'default',
                  animated: false,
                  markerEnd: {
                    type: MarkerType.ArrowClosed,
                    width: 12,
                    height: 12,
                    color: '#BDC4D5',
                  },
                });
              }
            });
          }
        });

        return { nodes, edges, allItems };
      }

      // =============================================
      // Main Graph Component
      // =============================================
      function LineageGraph() {
        const [nodes, setNodes, onNodesChange] = useNodesState([]);
        const [edges, setEdges, onEdgesChange] = useEdgesState([]);
        const [selectedItem, setSelectedItem] = useState(null);
        const [isLoading, setIsLoading] = useState(true);
        const [collapseState, setCollapseState] = useState({}); // { nodeId: { dbCollapsed, schemaCollapsed, collapsed } }
        
        // New state for column/feature expansion
        const [expandedItems, setExpandedItems] = useState({}); // { itemId: boolean }
        const [itemSearchQueries, setItemSearchQueries] = useState({}); // { itemId: string }
        const [selectedChildren, setSelectedChildren] = useState({}); // { itemId: Set<string> }
        const [hoveredChild, setHoveredChild] = useState(null); // { itemId, childName }
        
        // Column lineage mode state
        const [columnLineageMode, setColumnLineageMode] = useState(false);
        const [selectedColumnLineage, setSelectedColumnLineage] = useState(null); // { itemId, columnName }
        const [relatedColumns, setRelatedColumns] = useState(new Map()); // Map<itemId, Set<columnName>>
        const [columnLineageEdges, setColumnLineageEdges] = useState([]); // Additional edges for column lineage
        const [hoverPreviewEdges, setHoverPreviewEdges] = useState([]); // Preview edges on column hover
        const lineageVersionRef = React.useRef(0); // Track lineage version to avoid stale updates
        
        const reactFlowInstance = useReactFlow();

        // Calculate node height based on collapse state and expanded items
        const calculateNodeHeight = useCallback((nodeType, items, collapseInfo, expandedItemsState, selectedItemId, columnLineageModeState, sourceColumnState, relatedColumnsState) => {
          const itemHeight = 40;
          const expandedItemHeight = 420; // Height when item is expanded with columns list (header + search + list + button + margins)
          const selectedItemHeight = 100; // Height when item is selected but not expanded (card + margins)
          const dbHeaderHeight = 32;
          const schemaHeaderHeight = 40;
          const schemaPadding = 16;
          const containerPadding = 16;
          
          // Calculate total items height accounting for expanded/selected items
          const calculateItemsHeight = (itemsList) => {
            let height = 0;
            itemsList.forEach(item => {
              const isSelected = selectedItemId === item.id;
              const isExpanded = expandedItemsState?.[item.id] || false;
              const hasChildren = item.columns?.length > 0 || item.features?.length > 0;
              
              // Check if this item is involved in column lineage
              const isInColumnLineage = columnLineageModeState && (
                sourceColumnState?.itemId === item.id || 
                relatedColumnsState?.has?.(item.id)
              );
              
              // Item is expanded if: (selected AND expanded) OR (in column lineage AND expanded)
              if ((isSelected || isInColumnLineage) && hasChildren && isExpanded) {
                height += expandedItemHeight;
              } else if (isSelected && hasChildren) {
                height += selectedItemHeight;
              } else {
                height += itemHeight;
              }
            });
            return height;
          };
          
          if (nodeType === 'groupNode') {
            if (collapseInfo?.dbCollapsed) {
              return dbHeaderHeight + containerPadding;
            }
            if (collapseInfo?.schemaCollapsed) {
              return dbHeaderHeight + schemaHeaderHeight + schemaPadding + containerPadding;
            }
            const itemsHeight = calculateItemsHeight(items || []);
            return dbHeaderHeight + schemaHeaderHeight + itemsHeight + schemaPadding + containerPadding + 24;
          }
          
          if (nodeType === 'platformGroup') {
            const platformHeaderHeight = 40;
            if (collapseInfo?.collapsed) {
              return platformHeaderHeight + 16;
            }
            const itemsHeight = calculateItemsHeight(items || []);
            return platformHeaderHeight + itemsHeight + 16;
          }
          
          return 100;
        }, []);

        // Handle toggle collapse for database header
        const handleToggleDbCollapse = useCallback((nodeId) => {
          setCollapseState(prev => ({
            ...prev,
            [nodeId]: {
              ...prev[nodeId],
              dbCollapsed: !prev[nodeId]?.dbCollapsed
            }
          }));
        }, []);

        // Handle toggle collapse for schema header
        const handleToggleSchemaCollapse = useCallback((nodeId) => {
          setCollapseState(prev => ({
            ...prev,
            [nodeId]: {
              ...prev[nodeId],
              schemaCollapsed: !prev[nodeId]?.schemaCollapsed
            }
          }));
        }, []);

        // Handle toggle collapse for platform header
        const handleTogglePlatformCollapse = useCallback((nodeId) => {
          setCollapseState(prev => ({
            ...prev,
            [nodeId]: {
              ...prev[nodeId],
              collapsed: !prev[nodeId]?.collapsed
            }
          }));
        }, []);

        // Handle toggle item children expansion (columns/features)
        const handleToggleItemExpand = useCallback((itemId) => {
          setExpandedItems(prev => ({
            ...prev,
            [itemId]: !prev[itemId]
          }));
        }, []);

        // Handle item search query change
        const handleItemSearchChange = useCallback((itemId, query) => {
          setItemSearchQueries(prev => ({
            ...prev,
            [itemId]: query
          }));
        }, []);

        // Handle child (column/feature) click - enters column lineage mode
        const handleChildClick = useCallback((itemId, childName) => {
          // Check if clicking the same column again - exit lineage mode
          if (columnLineageMode && selectedColumnLineage?.itemId === itemId && selectedColumnLineage?.columnName === childName) {
            exitColumnLineageMode();
            return;
          }
          
          // Find all related columns using the columnLineage data
          const lineage = window.columnLineage || [];
          
          // Recursively find all upstream and downstream columns
          const findAllRelatedColumns = (sourceItemId, sourceColumnName) => {
            const related = new Map();
            const visited = new Set();
            const queue = [{ itemId: sourceItemId, columnName: sourceColumnName, direction: 'both' }];
            
            while (queue.length > 0) {
              const current = queue.shift();
              const key = `${current.itemId}:${current.columnName}`;
              
              if (visited.has(key)) continue;
              visited.add(key);
              
              // Find upstream (sources)
              if (current.direction === 'both' || current.direction === 'upstream') {
                lineage.forEach(edge => {
                  if (edge.targetTable === current.itemId && edge.targetColumn === current.columnName) {
                    const upstreamKey = `${edge.sourceTable}:${edge.sourceColumn}`;
                    if (!visited.has(upstreamKey)) {
                      if (!related.has(edge.sourceTable)) {
                        related.set(edge.sourceTable, new Set());
                      }
                      related.get(edge.sourceTable).add(edge.sourceColumn);
                      queue.push({ itemId: edge.sourceTable, columnName: edge.sourceColumn, direction: 'upstream' });
                    }
                  }
                });
              }
              
              // Find downstream (targets)
              if (current.direction === 'both' || current.direction === 'downstream') {
                lineage.forEach(edge => {
                  if (edge.sourceTable === current.itemId && edge.sourceColumn === current.columnName) {
                    const downstreamKey = `${edge.targetTable}:${edge.targetColumn}`;
                    if (!visited.has(downstreamKey)) {
                      if (!related.has(edge.targetTable)) {
                        related.set(edge.targetTable, new Set());
                      }
                      related.get(edge.targetTable).add(edge.targetColumn);
                      queue.push({ itemId: edge.targetTable, columnName: edge.targetColumn, direction: 'downstream' });
                    }
                  }
                });
              }
            }
            
            return related;
          };
          
          const related = findAllRelatedColumns(itemId, childName);
          
          // If no related columns found, exit lineage mode and clear all selections
          if (related.size === 0) {
            // Exit column lineage mode if active
            if (columnLineageMode) {
              exitColumnLineageMode();
            } else {
              // Just clear existing selections and select this column only
              setExpandedItems({ [itemId]: true });
              setSelectedChildren({ [itemId]: new Set([childName]) });
            }
            return;
          }
          
          // Increment version to invalidate any pending edge updates
          lineageVersionRef.current += 1;
          
          // Clear existing edges first when switching columns
          setColumnLineageEdges([]);
          
          // Enter column lineage mode
          setColumnLineageMode(true);
          setSelectedColumnLineage({ itemId, columnName: childName });
          setRelatedColumns(related);
          
          // Clear item selection
          setSelectedItem(null);
          if (window.sharedSelection) {
            window.sharedSelection.setSelection(null, null);
          }
          
          // Set up expanded items and selected children for lineage view
          const newExpandedItems = { [itemId]: true };
          const newSelectedChildren = { [itemId]: new Set([childName]) };
          
          related.forEach((columns, relatedItemId) => {
            newExpandedItems[relatedItemId] = true;
            newSelectedChildren[relatedItemId] = columns;
          });
          
          setExpandedItems(newExpandedItems);
          setSelectedChildren(newSelectedChildren);
          
          // Edge creation is handled by useEffect below after render
          
        }, [columnLineageMode, selectedColumnLineage, reactFlowInstance]);
        
        // Create column lineage edges AFTER items are expanded (handles must exist first)
        useEffect(() => {
          if (!columnLineageMode || !selectedColumnLineage || !reactFlowInstance) {
            return;
          }
          
          const { itemId, columnName: childName } = selectedColumnLineage;
          const lineage = window.columnLineage || [];
          const currentVersion = lineageVersionRef.current;
          
          // Delay to ensure DOM has updated with expanded items and handles are rendered
          const timeoutId = setTimeout(() => {
            // Skip if version changed (user selected a different column)
            if (lineageVersionRef.current !== currentVersion) {
              console.log('Skipping stale edge update, version changed');
              return;
            }
            const newColumnEdges = [];
            const visited = new Set();
            
            // Build a map from item ID to node ID by checking current nodes
            const itemToNodeMap = new Map();
            const currentNodes = reactFlowInstance.getNodes() || [];
            currentNodes.forEach(node => {
              if (node.data?.items) {
                node.data.items.forEach(item => {
                  itemToNodeMap.set(item.id, node.id);
                });
              }
            });
            
            console.log('Creating column lineage edges. Source:', itemId, childName);
            console.log('Related columns:', Array.from(relatedColumns.entries()).map(([k, v]) => [k, Array.from(v)]));
            
            // Build edges for all related columns
            const addEdgesForColumn = (srcItemId, srcColumnName) => {
              const sourceNodeId = itemToNodeMap.get(srcItemId);
              if (!sourceNodeId) {
                console.log('  No node found for source:', srcItemId);
                return;
              }
              
              lineage.forEach(edge => {
                if (edge.sourceTable === srcItemId && edge.sourceColumn === srcColumnName) {
                  // Check if target is in our related set OR is the originally selected column
                  const isTargetRelated = relatedColumns.has(edge.targetTable) && relatedColumns.get(edge.targetTable).has(edge.targetColumn);
                  const isTargetSelected = edge.targetTable === itemId && edge.targetColumn === childName;
                  
                  if (isTargetRelated || isTargetSelected) {
                    const targetNodeId = itemToNodeMap.get(edge.targetTable);
                    if (!targetNodeId) {
                      console.log('  No node found for target:', edge.targetTable);
                      return;
                    }
                    
                    const edgeId = `column-edge-${edge.id}`;
                    if (!visited.has(edgeId)) {
                      visited.add(edgeId);
                      
                      // Check if handles exist in DOM
                      const sourceHandle = document.querySelector(`[data-handleid="column-out-${srcItemId}-${srcColumnName}"]`);
                      const targetHandle = document.querySelector(`[data-handleid="column-in-${edge.targetTable}-${edge.targetColumn}"]`);
                      console.log('  Edge:', srcItemId + '.' + srcColumnName, '->', edge.targetTable + '.' + edge.targetColumn,
                        'Handles exist:', !!sourceHandle, !!targetHandle);
                      
                      // Use column handles if they exist, otherwise fall back to object handles
                      const actualSourceHandle = sourceHandle 
                        ? `column-out-${srcItemId}-${srcColumnName}` 
                        : `right-${srcItemId}`;
                      const actualTargetHandle = targetHandle 
                        ? `column-in-${edge.targetTable}-${edge.targetColumn}` 
                        : `left-${edge.targetTable}`;
                      
                      newColumnEdges.push({
                        id: edgeId,
                        source: sourceNodeId,
                        sourceHandle: actualSourceHandle,
                        target: targetNodeId,
                        targetHandle: actualTargetHandle,
                        type: 'default',
                        animated: true,
                        className: 'column-lineage animated',
                        data: { transformType: edge.transformType },
                        markerEnd: {
                          type: MarkerType.ArrowClosed,
                          width: 14,
                          height: 14,
                          color: '#1A6CE7',
                        },
                        style: {
                          stroke: '#1A6CE7',
                          strokeWidth: 2,
                        },
                      });
                    }
                  }
                }
              });
            };
            
            // Add edges from source column
            addEdgesForColumn(itemId, childName);
            
            // Add edges from all related columns (to get the full chain)
            relatedColumns.forEach((columns, relatedItemId) => {
              columns.forEach(colName => {
                addEdgesForColumn(relatedItemId, colName);
              });
            });
            
            console.log('Column lineage edges created:', newColumnEdges.length);
            setColumnLineageEdges(newColumnEdges);
            
            // Force a second update after handles are fully positioned
            setTimeout(() => {
              // Skip if version changed
              if (lineageVersionRef.current !== currentVersion) {
                console.log('Skipping stale force update, version changed');
                return;
              }
              console.log('Force re-setting column lineage edges');
              setColumnLineageEdges([...newColumnEdges]);
            }, 200);
          }, 350); // Delay for DOM to update
          
          return () => clearTimeout(timeoutId);
        }, [columnLineageMode, selectedColumnLineage, relatedColumns, expandedItems, reactFlowInstance]);
        
        // Exit column lineage mode
        const exitColumnLineageMode = useCallback(() => {
          setColumnLineageMode(false);
          setSelectedColumnLineage(null);
          setRelatedColumns(new Map());
          setColumnLineageEdges([]);
          setExpandedItems({});
          setSelectedChildren({});
        }, []);

        // Handle child hover - show preview of column lineage edges
        const handleChildHover = useCallback((itemId, childName) => {
          if (childName) {
            setHoveredChild({ itemId, childName });
            
            // Don't show preview if already in column lineage mode
            if (columnLineageMode) {
              setHoverPreviewEdges([]);
              return;
            }
            
            // Create preview edges for direct upstream (-1) and downstream (+1) connections
            const lineage = window.columnLineage || [];
            const currentNodes = reactFlowInstance?.getNodes() || [];
            
            // Build a map from item ID to node ID and handles
            const itemToNodeMap = new Map();
            currentNodes.forEach(node => {
              if (node.data?.items) {
                node.data.items.forEach(item => {
                  itemToNodeMap.set(item.id, {
                    nodeId: node.id,
                    leftHandle: `left-${item.id}`,
                    rightHandle: `right-${item.id}`
                  });
                });
              }
            });
            
            const sourceInfo = itemToNodeMap.get(itemId);
            if (!sourceInfo) {
              setHoverPreviewEdges([]);
              return;
            }
            
            const previewEdges = [];
            const addedEdges = new Set(); // Track unique edges
            
            // Find direct downstream connections (this column -> other columns)
            // Use object handles for preview (column handles only exist in lineage mode)
            lineage.forEach(edge => {
              if (edge.sourceTable === itemId && edge.sourceColumn === childName) {
                const targetInfo = itemToNodeMap.get(edge.targetTable);
                if (targetInfo) {
                  const edgeKey = `${sourceInfo.nodeId}-${targetInfo.nodeId}`;
                  if (!addedEdges.has(edgeKey)) {
                    addedEdges.add(edgeKey);
                    previewEdges.push({
                      id: `preview-down-${edge.id}`,
                      source: sourceInfo.nodeId,
                      sourceHandle: sourceInfo.rightHandle,
                      target: targetInfo.nodeId,
                      targetHandle: targetInfo.leftHandle,
                      type: 'default',
                      animated: true,
                      className: 'column-lineage-preview',
                      markerEnd: {
                        type: MarkerType.ArrowClosed,
                        width: 10,
                        height: 10,
                        color: '#D5DAE4',
                      },
                      style: {
                        stroke: '#D5DAE4',
                        strokeWidth: 1,
                      },
                    });
                  }
                }
              }
              
              // Find direct upstream connections (other columns -> this column)
              if (edge.targetTable === itemId && edge.targetColumn === childName) {
                const upstreamInfo = itemToNodeMap.get(edge.sourceTable);
                if (upstreamInfo) {
                  const edgeKey = `${upstreamInfo.nodeId}-${sourceInfo.nodeId}`;
                  if (!addedEdges.has(edgeKey)) {
                    addedEdges.add(edgeKey);
                    previewEdges.push({
                      id: `preview-up-${edge.id}`,
                      source: upstreamInfo.nodeId,
                      sourceHandle: upstreamInfo.rightHandle,
                      target: sourceInfo.nodeId,
                      targetHandle: sourceInfo.leftHandle,
                      type: 'default',
                      animated: true,
                      className: 'column-lineage-preview',
                      markerEnd: {
                        type: MarkerType.ArrowClosed,
                        width: 10,
                        height: 10,
                        color: '#D5DAE4',
                      },
                      style: {
                        stroke: '#D5DAE4',
                        strokeWidth: 1,
                      },
                    });
                  }
                }
              }
            });
            
            setHoverPreviewEdges(previewEdges);
          } else {
            setHoveredChild(null);
            setHoverPreviewEdges([]);
          }
        }, [columnLineageMode, reactFlowInstance]);

        // Handle item click - update shared selection, expand to show columns, and center view
        const handleItemClick = useCallback((item, nodeId) => {
          // Exit column lineage mode if active
          if (columnLineageMode) {
            exitColumnLineageMode();
          }
          
          setSelectedItem(item);
          
          // Auto-expand item to show columns/features if it has any
          const hasChildren = item.columns?.length > 0 || item.features?.length > 0;
          if (hasChildren) {
            setExpandedItems(prev => ({
              ...prev,
              [item.id]: true
            }));
          }
          
          // Sync with global shared selection - pass all item data for side panel
          if (window.sharedSelection) {
            window.sharedSelection.setSelection(item.id, {
              id: item.id,
              name: item.name,
              icon: item.icon,
              database: item.database,
              schemaName: item.schemaName,
              schema: item.schema,
              platform: item.platform,
              objType: item.objType,
              columns: item.columns,
              features: item.features,
              outputs: item.outputs,
              description: item.description,
              comment: item.comment,
              owner: item.owner,
              createdAt: item.createdAt,
              rowCount: item.rowCount,
              dataQuality: item.dataQuality,
              tags: item.tags,
              downstream: item.downstream,
              upstream: item.upstream
            });
          }
          
          // Center view on the selected node (keep current zoom)
          if (reactFlowInstance && nodeId) {
            const node = reactFlowInstance.getNode(nodeId);
            if (node) {
              const currentZoom = reactFlowInstance.getZoom();
              const x = node.position.x + (node.width || 304) / 2;
              const y = node.position.y + (node.height || 40) / 2;
              reactFlowInstance.setCenter(x, y, { zoom: currentZoom, duration: 300 });
            }
          }
        }, [reactFlowInstance, columnLineageMode, exitColumnLineageMode]);

        // Center on focal node when ReactFlow initializes and select the focal item
        const onInit = useCallback((instance) => {
          console.log('ReactFlow onInit called');
          setTimeout(() => {
            const allNodes = instance.getNodes();
            const focalNode = allNodes.find(n => 
              n.data.isFocal || 
              n.data.hasFocal || 
              n.data.items?.some(item => item.isFocal)
            );
            
            console.log('onInit - focalNode:', focalNode);
            
            if (focalNode) {
              const x = focalNode.position.x + (focalNode.data.width || 304) / 2;
              const y = focalNode.position.y + (focalNode.data.height || 100) / 2;
              console.log('onInit - centering to:', { x, y });
              instance.setCenter(x, y, { zoom: 0.875, duration: 0 });
              
              // Select the focal item on initial load
              const focalItem = focalNode.data.items?.find(item => item.isFocal) || focalNode.data.item;
              if (focalItem) {
                setSelectedItem(focalItem);
                
                // Auto-expand to show columns/features if it has any
                const hasChildren = focalItem.columns?.length > 0 || focalItem.features?.length > 0;
                if (hasChildren) {
                  setExpandedItems(prev => ({
                    ...prev,
                    [focalItem.id]: true
                  }));
                }
                
                // Sync with global shared selection
                if (window.sharedSelection) {
                  window.sharedSelection.setSelection(focalItem.id, {
                    id: focalItem.id,
                    name: focalItem.name,
                    icon: focalItem.icon,
                    database: focalItem.database,
                    schemaName: focalItem.schemaName,
                    schema: focalItem.schema,
                    platform: focalItem.platform,
                    objType: focalItem.objType,
                    columns: focalItem.columns,
                    features: focalItem.features,
                    outputs: focalItem.outputs,
                    description: focalItem.description,
                    comment: focalItem.comment,
                    owner: focalItem.owner,
                    createdAt: focalItem.createdAt,
                    rowCount: focalItem.rowCount,
                    dataQuality: focalItem.dataQuality,
                    tags: focalItem.tags,
                    downstream: focalItem.downstream,
                    upstream: focalItem.upstream
                  });
                }
              }
            }
          }, 100);
        }, []);
        
        // Listen for selection changes from list view
        useEffect(() => {
          if (window.sharedSelection) {
            const handleSelectionChange = (itemId, itemData) => {
              if (itemId) {
                setSelectedItem({ id: itemId, ...itemData });
                
                // Center view on the selected node
                if (reactFlowInstance) {
                  // Find the node containing this item
                  const allNodes = reactFlowInstance.getNodes();
                  const targetNode = allNodes.find(node => {
                    // Check if this node contains the item
                    if (node.data.item?.id === itemId) return true;
                    if (node.data.items?.some(item => item.id === itemId)) return true;
                    return false;
                  });
                  
                  if (targetNode && targetNode.position) {
                    const posX = targetNode.position.x;
                    const posY = targetNode.position.y;
                    // Only center if we have valid coordinates
                    if (typeof posX === 'number' && typeof posY === 'number' && !isNaN(posX) && !isNaN(posY)) {
                      const currentZoom = reactFlowInstance.getZoom();
                      const x = posX + (targetNode.width || targetNode.data.width || 304) / 2;
                      const y = posY + (targetNode.height || targetNode.data.height || 100) / 2;
                      reactFlowInstance.setCenter(x, y, { zoom: currentZoom, duration: 300 });
                    }
                  }
                }
              } else {
                setSelectedItem(null);
              }
            };
            
            window.sharedSelection.addListener(handleSelectionChange);
            
            // Initialize with current selection if any
            if (window.sharedSelection.selectedItemId) {
              setSelectedItem({
                id: window.sharedSelection.selectedItemId,
                ...window.sharedSelection.selectedItemData
              });
            }
          }
        }, [reactFlowInstance]);

        // Initialize layout
        useEffect(() => {
          async function initLayout() {
            setIsLoading(true);
            
            // Read initial selection from shared state (may have been set by list view)
            const initialSelectedId = window.sharedSelection?.selectedItemId || selectedItem?.id;
            if (window.sharedSelection?.selectedItemId && !selectedItem) {
              setSelectedItem({
                id: window.sharedSelection.selectedItemId,
                ...window.sharedSelection.selectedItemData
              });
            }
            
            const { nodes: initialNodes, edges: initialEdges, allItems } = transformDataToNodesAndEdges(
              window.mockLineageData, 
              handleItemClick,
              initialSelectedId,
              {
                onToggleDbCollapse: handleToggleDbCollapse,
                onToggleSchemaCollapse: handleToggleSchemaCollapse,
                onTogglePlatformCollapse: handleTogglePlatformCollapse,
              }
            );
            
            try {
              const layoutedNodes = await calculateLayout(initialNodes, initialEdges);
              // Ensure selectedItemId is set on all nodes
              const nodesWithSelection = layoutedNodes.map(node => ({
                ...node,
                data: {
                  ...node.data,
                  selectedItemId: initialSelectedId
                }
              }));
              setNodes(nodesWithSelection);
              setEdges(initialEdges);
              
            } catch (error) {
              console.error('Layout error:', error);
              // Ensure selectedItemId is set even on error
              const nodesWithSelection = initialNodes.map(node => ({
                ...node,
                data: {
                  ...node.data,
                  selectedItemId: initialSelectedId
                }
              }));
              setNodes(nodesWithSelection);
              setEdges(initialEdges);
            }
            setIsLoading(false);
          }
          
          initLayout();
        // eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);

        // Update nodes when selection or expanded state changes
        useEffect(() => {
          const currentSelectedId = columnLineageMode ? null : (selectedItem?.id || window.sharedSelection?.selectedItemId);
          setNodes(nds => nds.map(node => ({
            ...node,
            data: {
              ...node.data,
              selectedItemId: currentSelectedId,
              expandedItems: expandedItems,
              itemSearchQueries: itemSearchQueries,
              selectedChildren: selectedChildren,
              onToggleItemExpand: handleToggleItemExpand,
              onItemSearchChange: handleItemSearchChange,
              onChildClick: handleChildClick,
              onChildHover: handleChildHover,
              columnLineageMode: columnLineageMode,
              sourceColumn: selectedColumnLineage,
              relatedColumns: relatedColumns,
            },
          })));
        }, [selectedItem, expandedItems, itemSearchQueries, selectedChildren, columnLineageMode, selectedColumnLineage, relatedColumns, setNodes, handleToggleItemExpand, handleItemSearchChange, handleChildClick, handleChildHover]);

        // Re-layout when collapse state or expanded items change
        useEffect(() => {
          const currentSelectedId = selectedItem?.id || window.sharedSelection?.selectedItemId;
          
          // Update node data with collapse state and recalculate heights
          setNodes(nds => {
            const gap = 72; // spacing between nodes
            
            // FIRST: Calculate old layer centers BEFORE updating heights
            // Group old nodes by layer
            const oldNodesByLayer = {};
            nds.forEach(node => {
              const layer = node.data.layer;
              if (layer !== undefined) {
                if (!oldNodesByLayer[layer]) {
                  oldNodesByLayer[layer] = [];
                }
                oldNodesByLayer[layer].push(node);
              }
            });
            
            // Sort by Y position and calculate old layer centers
            const oldLayerCenters = {};
            Object.keys(oldNodesByLayer).forEach(layer => {
              const layerNodes = oldNodesByLayer[layer].sort((a, b) => a.position.y - b.position.y);
              let layerMinY = Infinity;
              let layerMaxY = -Infinity;
              layerNodes.forEach(node => {
                const oldHeight = node.data.height || 100;
                layerMinY = Math.min(layerMinY, node.position.y);
                layerMaxY = Math.max(layerMaxY, node.position.y + oldHeight);
              });
              oldLayerCenters[layer] = (layerMinY + layerMaxY) / 2;
            });
            
            // SECOND: Update nodes with new heights and data
            const updatedNodes = nds.map(node => {
              const nodeCollapseInfo = collapseState[node.id] || {};
              const newHeight = calculateNodeHeight(node.type, node.data.items, nodeCollapseInfo, expandedItems, currentSelectedId, columnLineageMode, selectedColumnLineage, relatedColumns);
              
              return {
                ...node,
                data: {
                  ...node.data,
                  dbCollapsed: nodeCollapseInfo.dbCollapsed,
                  schemaCollapsed: nodeCollapseInfo.schemaCollapsed,
                  collapsed: nodeCollapseInfo.collapsed,
                  onToggleDbCollapse: handleToggleDbCollapse,
                  onToggleSchemaCollapse: handleToggleSchemaCollapse,
                  onToggleCollapse: handleTogglePlatformCollapse,
                  onToggleItemExpand: handleToggleItemExpand,
                  onItemSearchChange: handleItemSearchChange,
                  onChildClick: handleChildClick,
                  onChildHover: handleChildHover,
                  expandedItems: expandedItems,
                  selectedItemId: currentSelectedId,
                  height: newHeight,
                },
              };
            });
            
            // THIRD: Re-center nodes vertically per layer using OLD centers
            const nodesByLayer = {};
            updatedNodes.forEach(node => {
              const layer = node.data.layer;
              if (layer !== undefined) {
                if (!nodesByLayer[layer]) {
                  nodesByLayer[layer] = [];
                }
                nodesByLayer[layer].push(node);
              }
            });
            
            // Sort nodes by their original Y position within each layer
            Object.keys(nodesByLayer).forEach(layer => {
              nodesByLayer[layer].sort((a, b) => a.position.y - b.position.y);
            });
            
            // Re-center each layer vertically, using pre-calculated old centers
            Object.keys(nodesByLayer).forEach(layer => {
              const layerNodes = nodesByLayer[layer];
              const layerCenterY = oldLayerCenters[layer] || 0;
              
              // Calculate new layer height with updated node heights
              let totalHeight = 0;
              layerNodes.forEach((node, idx) => {
                totalHeight += node.data.height || 100;
                if (idx < layerNodes.length - 1) totalHeight += gap;
              });
              
              // Position nodes centered around the layer's original center
              let currentY = layerCenterY - totalHeight / 2;
              layerNodes.forEach(node => {
                node.position = {
                  ...node.position,
                  y: currentY
                };
                currentY += (node.data.height || 100) + gap;
              });
            });
            
            return updatedNodes;
          });
        }, [collapseState, expandedItems, selectedItem, columnLineageMode, selectedColumnLineage, relatedColumns, calculateNodeHeight, handleToggleDbCollapse, handleToggleSchemaCollapse, handleTogglePlatformCollapse, handleToggleItemExpand, handleItemSearchChange, handleChildClick, handleChildHover, setNodes]);

        // Expose global function to center on selected/focal node
        useEffect(() => {
          window.centerOnSelectedNode = () => {
            if (!reactFlowInstance) return;
            
            const allNodes = reactFlowInstance.getNodes();
            const currentSelectedId = selectedItem?.id || window.sharedSelection?.selectedItemId;
            
            let targetNode = null;
            
            // First try to find the selected node
            if (currentSelectedId) {
              targetNode = allNodes.find(node => {
                if (node.data.item?.id === currentSelectedId) return true;
                if (node.data.items?.some(item => item.id === currentSelectedId)) return true;
                return false;
              });
            }
            
            // Fall back to focal node if no selection
            if (!targetNode) {
              targetNode = allNodes.find(node => 
                node.data.isFocal || node.data.hasFocal || node.data.items?.some(item => item.isFocal)
              );
            }
            
            if (targetNode) {
              const currentZoom = reactFlowInstance.getZoom();
              const x = targetNode.position.x + (targetNode.width || targetNode.data.width || 304) / 2;
              const y = targetNode.position.y + (targetNode.height || targetNode.data.height || 100) / 2;
              reactFlowInstance.setCenter(x, y, { zoom: currentZoom, duration: 300 });
            }
          };
          
          return () => {
            delete window.centerOnSelectedNode;
          };
        }, [reactFlowInstance, selectedItem]);

        // Handle pane click - exit column lineage mode (must be before loading check)
        const handlePaneClick = useCallback(() => {
          if (columnLineageMode) {
            exitColumnLineageMode();
          }
        }, [columnLineageMode, exitColumnLineageMode]);

        if (isLoading) {
          return React.createElement('div', { className: 'graph-loading' },
            React.createElement('div', { className: 'graph-loading-spinner' }),
            'Loading graph...'
          );
        }

        // Combine regular edges with column lineage edges and hover preview edges
        // Dim regular edges to 40% opacity when showing column lineage
        const combinedEdges = columnLineageMode 
          ? [
              ...edges.map(edge => ({
                ...edge,
                style: { ...edge.style, opacity: 0.4 }
              })),
              ...columnLineageEdges
            ]
          : [
              ...edges,
              ...hoverPreviewEdges
            ];

        return React.createElement(ReactFlowComponent, {
          nodes,
          edges: combinedEdges,
          onNodesChange,
          onEdgesChange,
          onInit,
          onPaneClick: handlePaneClick,
          nodeTypes,
          defaultViewport: { x: 0, y: 0, zoom: 0.875 },
          minZoom: 0.1,
          maxZoom: 2,
          nodesDraggable: false, // Disabled for now - add lock/unlock UI later
          zoomOnScroll: false,
          panOnScroll: true,
          zoomActivationKeyCode: 'Meta',
          noPanClassName: 'nowheel',
          defaultEdgeOptions: {
            type: 'default',  // bezier curves
          },
          proOptions: { hideAttribution: true },
        },
          React.createElement(Background, {
            variant: BackgroundVariant.Dots,
            gap: 20,
            size: 1.5,
            color: 'rgba(213, 218, 228, 1)'
          }),
          React.createElement(MiniMap, {
            position: 'bottom-right',
            nodeStrokeWidth: 1,
            nodeColor: '#e2e8f0',
            nodeStrokeColor: '#94a3b8',
            maskColor: 'rgba(255, 255, 255, 0.7)',
            zoomable: true,
            pannable: true,
            style: {
              width: 150,
              height: 100,
              backgroundColor: '#ffffff',
              border: '1px solid #D5DAE4',
              borderRadius: '6px',
              right: 46,
              bottom: 16
            }
          }),
          React.createElement(Controls, { 
            showInteractive: false,
            position: 'bottom-right',
            style: {
              bottom: 16
            }
          })
        );
      }

      // =============================================
      // Mount React App with Provider
      // =============================================
      const container = document.getElementById('lineage-graph-container');
      if (container) {
        const root = createRoot(container);
        root.render(
          React.createElement(ReactFlowProvider, null,
            React.createElement(LineageGraph)
          )
        );
      }
      
      }); // End DOMContentLoaded
    </script>
  </body>
</html>
